/**
 * Copyright (C) 2020 TU Dresden
 * 
 * This benchmark implements a parallel all pairs shortest path algorithm. In
 * order to split the workload, the large input matrix of size graphSize x
 * graphSize is split into smaller blocks of size blockSize x blockSize. Each of
 * the worker reactors (ApspFloydWarshallBlock) processes one of these blocks.
 * The worker reactors are organized in the same matrix pattern, replication the
 * structure of the blocks within the large input matrix. Each of the workers
 * operates on its local block data, and sends results to all other workers in
 * the same column or in the same row. The data from the neighbors is then used
 * to compute the next intermediate result and to update the local state
 * accordingly.
 * 
 * @author Christian Menard
 * @author Hannes Klein
 * @author Soroush Bateni
 */

target C {
    build-type : RelWithDebInfo,
    cmake-include: "../lib/matrix.cmake",
    files: ["../include/matrix.h", "../lib/matrix.c", "../include/PseudoRandom.h"]
};

preamble {=
    #include "matrix.h"
    #include "PseudoRandom.h"
=}

reactor ApspFloydWarshallBlock(
    bank_index: int(0),
    row_index: size_t(0),
    graph_size: size_t(300),
    block_size: size_t(50),
    dimension: size_t(6),
    verbose: bool(false))
{
    preamble {=
        

        // Extract (copy) the data block that is relevant for this instance from the given matrix 
        matrix_t extract_data_from_matrix(matrix_t matrix, size_t block_size, size_t row_offset, size_t col_offset) {
            matrix_t local_matrix = mat_new_i(block_size, block_size);
            
            // FIXME memcpy should be much faster here, but on the other hand this is only done during initialization
            for(size_t i = 0; i < blockSize; i++) {
                for(size_t j = 0; j < blockSize; j++) {
                    int* value = mat_at_i(matrix, rowOffset + i, colOffset + j);
                    mat_set_i(local_matrix, i, j, *value);
                }
            }
            return local_matrix;
        }
        
        // retrieve the element at the given position from the known data
        int get_element_at(size_t row, size_t col, void* row_ports, void* col_ports, size_t block_size, int bank_index) {

            size_t dest_row = row / blockSize;
            size_t dest_col = col / blockSize;
            
            size_t local_row = row % blockSize;
            size_t local_col = col % blockSize;
            
            if (dest_row == row_index) {
                matrix_t data = row_ports[dest_col]->value;
                int* cell = mat_at_i(data, local_row, local_col);
                return *cell;
            } else if (dest_col == bank_index) {
                matrix_t data = col_ports[dest_row]->value;
                int* cell = mat_at_i(data, local_row, local_col);
                return *cell;
            } else {
                error_print_and_exit("Error: unexpected target location (%d, %d).", dest_col, dest_row);
            }
            
        }
    =}
    
    state num_neighbors:size_t;
    state row_offset:size_t; // row offset of the block of this reactor
    state col_offset:size_t; // column offset of the block of this reactor
    
    input start:matrix_t;

    state k:size_t(0); // iteration counter
    state reported_finish:bool(false);

    input[dimension] from_row:matrix_t;
    input[dimension] from_col:matrix_t;

    output to_neighbors:matrix_t;    
    output finished:bool;
    
    logical action notify_neighbors:matrix_t;
    
    reaction(start) -> notify_neighbors {=
        // Initialize state variables
        self->num_neighbors = 2 * (self->dimension - 1);
        self->row_offset = self->row_index * self->block_size;
        self->col_offset = self->bank_index * self->blockSize;
        
        // reset local state
        self->k = 0;
        self->reported_finish = false;
        
        // start execution
        matrix_t matrix = extract_data_from_matrix(start->value, self->block_size, self->row_offset, self->col_offset);
        schedule_value(notify_neighbors, 0, matrix, sizeof(matrix_t));
    =}
    
    reaction(notify_neighbors) -> to_neighbors {=
        //notify all neighbors
        SET(to_neighbors, notify_neighbors->value);
    =}
    
    reaction(from_row, from_col) -> notify_neighbors, finished {=
        // do nothing if complete
        if(self->k == self->graph_size) {
            return;
        }
        
        // perform computation
        matrix_t local_matrix = mat_new_i(block_size, block_size);
        
        for(size_t i = 0; i < blockSize; i++) {
            for(size_t j = 0; j < blockSize; j++) {
                int gi = rowOffset + i;
                int gj = colOffset + j;
                
                long result = get_element_at(gi, k, from_row, from_col) + getElementAt(k, gj, from_row, from_col, self->block_size, self->bank_index);
                mat_set_i(matrix, i, j, min(get_element_at(gi, gj, from_row, from_col), result);
            }
        }
       
       // increment iteration count
       k++;
       
       if(k == graphSize) {
            if(self->verbose && self->bank_index == 0 && self->row_index == 0) {
                // debugging and result checking
                for(size_t i = 0; i < blockSize; i++) {
                    for(size_t j = 0; j < blockSize; j++) {
                        printf("%d ", mat_at_i(matrix, i, j));
                    }
                    printf("\n");
                }
            }
            SET(finished, true);
        }
       
        // send the result to all neighbors in the next iteration
        schedule_value(notify_neighbors, matrix, sizeof(matrix));        
    =}
}


reactor ApspRow(
    bank_index: int(0),
    block_size: size_t(50),
    num_nodes: size_t(300),
    dimension: size_t(6),
    dimension2: size_t(36), // dimension * dimension
    verbose: bool(false)
) {
        
    input start:matrix_t;
    output[dimension] finished:bool;

    input[dimension2] from_col:matrix_t;
    output[dimension] to_col:matrix_t;
        
    blocks = new[dimension] ApspFloydWarshallBlock(
        row_index=bank_index,
        block_size=block_size,
        graph_size=num_nodes,
        dimension=dimension,
        verbose=verbose
    );
    
    // connect all blocks within the row
    (blocks.to_neighbors)+ -> blocks.from_row;
    
    // block output to all column neighbours
    blocks.to_neighbors -> to_col;
    // block input from all column neighbours
    from_col -> interleaved(blocks.from_col);
    
    // broadcast the incoming matrix to all blocks
    (start)+ -> blocks.start;
    // collect and forward finished signals from all blocks
    blocks.finished -> finished;
}

reactor ApspMatrix(
    block_size: size_t(50),
    num_nodes: size_t(300),
    dimension: size_t(6),
    dimension2: size_t(36),
    verbose: bool(false))
{
    input start:matrix_t;
    output[dimension2] finished:bool;
    
    rows = new[dimension] ApspRow(block_size=block_size, num_nodes=num_nodes, dimension=dimension, verbose=verbose);
    
    // broadcast the incoming matrix to all rows
    (start)+ -> rows.start;
    // collect and forward finished signals from all blocks
    rows.finished -> finished;
    
    (rows.to_col)+ -> rows.from_col;
}

main reactor (
    num_iterations: size_t(12),
    max_edge_weight: size_t(100),
    block_size: size_t(50),
    num_nodes: size_t(300),
    verbose: bool(false)) {
    
    state graph_data: matrix_t;
    state num_blocks_finished: size_t(0);
    state random:PseudoRandom;
    
    matrix = new ApspMatrix(
        block_size=block_size,
        num_nodes=num_nodes,
        dimension={=numNodes / blockSize=},
        verbose=verbose
    );
      
    reaction(startup) {=
//        printBenchmarkInfo("ApspBenchmark");
//        printArgs("numIterations", numIterations, "maxEdgeWeight", maxEdgeWeight, "numNodes", numNodes, "blockSize", blockSize);
//        printSystemInfo();
        
        // Initialize the random state variable
        initPseudoRandom(&self->random, self->num_nodes);
        
        graph_data = generate_graph(self->num_nodes, self->max_edge_weight));
        // reset local state
        self->num_blocks_finished = 0;

        // start execution
        SET(matrix.start, graph_data);
    =}

    reaction (matrix.finished) {=
        for (int i=0; i<matrix.finished_width; i++) {
            if (matrix.finished[i].is_present) {
                self->num_blocks_finished++;
            }
        }
        size_t dimension = self->num_nodes / self->block_size;
        if (self->num_blocks_finished != dimension*dimension) {
            error_print_and_exit("Did not receive the expected number of blocks.");
        }
        request_stop();
    =}

    preamble {=  
        #include "PseudoRandom.hh"
        
        matrix_t generate_graph(size_t N, size_t W, PseudoRandom random) {
            matrix_t local_data = mat_new_i(N, N);
            
            for(size_t i = 0; i < N; i++) {
                for(size_t j = i+1; j < N; j++) {
                    int r = nextIntEMax(&self->random, W) + 1;
                    mat_set_i(local_data, i, j, r);
                    mat_set_i(local_data, j, i, r);
                }
            }
            
            return local_data;
        }
    =}
}