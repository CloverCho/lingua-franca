/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 * @author Matthew Chorlian
 */

/* [[[cog
# This file is a code generator using the python module cog:
# See https://nedbatchelder.com/code/cog/
#
# All instructions for code  generation are in-lined in comments
# like this one. With that you can use this file as a normal source file
# but also to generate code.
# 
# To change the generated code in-line within this file run:
# $ python -m cog -r this-file.lf
# To generate a new file from this file stripping the generator code in the process run:
# $ python -m cog -d -o output-file.lf this-file.lf
#
# Use the command line option -D to specify generator parameters, for example:
# $ python -m cog -r -D parameter=100 this-file.lf
#
# Generator parameters used in this file:
# -D numSeries=10
# 
]]] */
// [[[end]]]

/* [[[cog
  # force existence, type and default values of generator parameters
  if 'numSeries' in globals():
    numSeries = int(numSeries)
  else:
    globals()['numSeries'] = 10
  
  # output the current value of the generator parameters used in the last generation run
  cog.outl(f'// Generated file with the following parameters:')
  cog.outl(f'// numSeries = {numSeries}')
]]] */
// Generated file with the following parameters:
// numSeries = 10
// [[[end]]]

target C;

import BenchmarkRunner from "../BenchmarkRunner.lf";


preamble {=
    #include <stdlib.h>
    #include <stddef.h>
    
    typedef double message_content_t;
    
    typedef enum MsgType {
      ResetMsg,
      ComputeMsg,
      ResultMsg,
      NextTermMsg,
      GetTermMsg
    } msg_type_t;
    
    typedef struct Message {
      msg_type_t type;
      message_content_t data;
    } message_t;
=}

reactor RateComputer(instance:int(0), startRate:double(3.46), rateIncrement:double(0.0025)) {

    

    state rate:double;
    
    input inSeriesWorker:message_t;
    output outSeriesWorker:message_t;
    
    reaction(startup) {=
        self->rate = self->startRate + (self->instance * self->rateIncrement);
    =}
    
    reaction(inSeriesWorker) -> outSeriesWorker {=
        
        if(inSeriesWorker->value.type == ComputeMsg) {
            
            double result = computeNextTerm(inSeriesWorker->value.data, self->rate);
            //message_t* msg;
            //msg = (message_t*) malloc(sizeof(struct Message));
            //msg->type = ResultMsg;
            //msg->data = result;
            message_t msg = {ResultMsg, result};
            SET(outSeriesWorker, msg);
        }
    =}

    preamble {=
        double computeNextTerm(double curTerm, double rate) {
            return rate * curTerm * (1 - curTerm);
        }
    =}

}

reactor SeriesWorker(instance:int(0), termIncrement:double(0.0025)) {
    
    state curTerm:{=double[]=};
    state startTerm:double;
    
    input inMaster:message_t;
    output outMaster:message_t;
    output outRateComputer:message_t;
    input inRateComputer:message_t;
    
    reaction(startup) {=
        self->startTerm = self->instance * self->termIncrement;
    =}
    
    reaction(inMaster) -> outRateComputer, outMaster {=
        
        if(inMaster->value.type == ResetMsg) {
            
            //reset local state
            self->curTerm = calloc(100, sizeof(double));
            self->curTerm[0] = self->startTerm;

            
        } else if(inMaster->value.type == NextTermMsg) {
            //message_t* msg;
            //msg = (message_t*) malloc(sizeof(struct Message));
            //msg->type = ComputeMsg;
            //msg->data = self->curTerm[0];
            message_t msg = {ComputeMsg, self->curTerm[0]};
            SET(outRateComputer, msg);
            
        } else if(inMaster->value.type == GetTermMsg) {
            //message_t* msg;
            //msg = (message_t*) malloc(sizeof(struct Message));
            //msg->type = ResultMsg;
            //msg->data = self->curTerm[0];
            message_t msg = {ResultMsg, self->curTerm[0]};
            SET(outMaster, msg);
        }
    =}
    
    reaction(inRateComputer) {=
        
        if(inRateComputer->value.type == ResultMsg) {
            
            self->curTerm[0] = inRateComputer->value.data;
        }
    =}
}


reactor Master(numSeries:int(10), numTerms:int(25000)) {
    
    state numWorkRequested:int(0);
    state numWorkReceived:int(0);
    state termsSum:double(0.0);
    state currentTerm:int(0);
    
    input inStart:bool;
    output outFinished:bool;
    
    
    output[10] outSeriesWorkers:message_t;
    input[10] inSeriesWorkers:message_t;
    
    logical action nextTerms;
    
    reaction(inStart) -> nextTerms, outSeriesWorkers {=
        
        //reset local state
        self->numWorkRequested = 0;
        self->numWorkReceived = 0;
        self->termsSum = 0.0;
        self->currentTerm = 0;
        
        schedule(nextTerms, 0);
        //message_t* msg;
        //msg = (message_t*) malloc(sizeof(struct Message));
        //msg->type = ResetMsg;
        //msg->data = 0.0;
        message_t msg = {ResetMsg, 0.0};
        for(int i = 0; i < self->numSeries; i++) {
            SET(outSeriesWorkers[i], msg);
        }
        
    =}
    
    reaction(nextTerms) -> outSeriesWorkers, nextTerms {=
        
        if(self->currentTerm == self->numTerms) {
            //message_t* msg;
            //msg = (message_t*) malloc(sizeof(struct Message));
            //msg->type = GetTermMsg;
            //msg->data = 0.0;
            message_t msg = {GetTermMsg, 0.0};
            for(int i = 0; i < self->numSeries; ++i) {
                SET(outSeriesWorkers[i], msg);
                self->numWorkRequested++;
            }
            return;
        }
        //message_t* msg;
        //msg = (message_t*) malloc(sizeof(struct Message));
        //msg->type = NextTermMsg;
        //msg->data = 0.0;
        message_t msg = {NextTermMsg, 0.0};
        for(int i = 0; i < self->numSeries; ++i) {
            SET(outSeriesWorkers[i], msg);
        }
        self->currentTerm++;
        schedule(nextTerms, 0);
        
    =}
    
    reaction(inSeriesWorkers) -> outFinished {=
        
        for(int i = 0; i < self->numSeries; ++i) {
            if(inSeriesWorkers[i]->is_present) {
                if(inSeriesWorkers[i]->value.type == ResultMsg) {
                    
                    self->termsSum += inSeriesWorkers[i]->value.data;
                    self->numWorkReceived++;
                    
                    if(self->numWorkRequested == self->numWorkReceived) {
                        
                        printf("Terms sum: %f  ",  self->termsSum);
                        SET(outFinished, true);
                    }
                }
            }
        }
    =}
}


main reactor (numIterations:int(12), numTerms:int(25000), startRate:double(3.46)) {
    
    master = new Master(numSeries=10, numTerms=numTerms);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("LogisticMapBenchmark");
        printf("numIterations: %d, numTerms: %d, startRate: %f, numSeries: %d\n", 
                self->numIterations, self->numTerms, self->startRate, 10);
        printSystemInfo();
        SET(runner.inStart, true);
    =}
    
    
    rateComputers = new[10] RateComputer(startRate=startRate, rateIncrement=0.0025);
    seriesWorkers = new[10] SeriesWorker(termIncrement=0.0025);
    
    master.outSeriesWorkers -> seriesWorkers.inMaster;
    rateComputers.outSeriesWorker -> seriesWorkers.inRateComputer;
    seriesWorkers.outRateComputer -> rateComputers.inSeriesWorker;
    seriesWorkers.outMaster -> master.inSeriesWorkers;
    
}