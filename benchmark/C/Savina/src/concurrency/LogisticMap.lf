/**
 * Copyright (C) 2020 TU Dresden
 * 
 * @author Christian Menard
 * @author Hannes Klein
 * @author Matt Chorlian
 */

target C {
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads}")
      else:
          cog.outl("threads: 0")
    ]]] */
    threads: 0
    /// [[[end]]]
};

reactor RateComputer(bank_index: size_t(0), startRate: double(3.46), rateIncrement: double(0.0025)) {
    
    state currentRate: double;
    
    input reset: bool;
    input compute: double;
    output rate: double;
    
    reaction(reset) {=
        self->currentRate = self->startRate + (self->bank_index * self->rateIncrement);
    =}
    
    reaction(compute) -> rate {=
        double term = compute->value;
        double result = self->currentRate * term * (1 - term);
        SET(rate, result);
    =}
}

reactor SeriesWorker(bank_index: size_t(0), termIncrement: double(0.0025)) {
    
    state curTerm: double;
    
    input reset: bool;
    input nextTerm: bool;
    input getTerm: bool;
    output term: double;
    output computeRate: double;
    input rate: double;

    reaction (reset) {=
        //reset local state
        self->curTerm = self->bank_index * self->termIncrement;   
    =}
    
    reaction(nextTerm) -> computeRate {=
        SET(computeRate, self->curTerm);
    =}
    
    reaction(getTerm) -> term {=
        SET(term, self->curTerm);
    =}
    
    reaction(rate) {=
        self->curTerm = rate->value;
    =}
}


reactor Manager(numSeries: size_t(10), numTerms: size_t(25000)) {
 
    state currentIteration: size_t(0);
    
    input start: bool;
    output finished: bool;

    output nextTerm: bool;
    output getTerm: bool;
    input[numSeries] term: double;
    
    logical action next;
    
    reaction(start, next) -> getTerm, nextTerm, next {=
        if(self->currentIteration == self->numTerms) {
            SET(getTerm, true);
            return;
        }

        SET(nextTerm, true);
        self->currentIteration++;
        schedule(next, 0);
    =}
    
    reaction(term) -> finished {=
        double terms_sum = 0.0;
        for (size_t i = 0; i < self->numSeries; ++i) {
            terms_sum += term[i]->value;
        }
        SET(finished, true);

        // reset local state
        self->currentIteration = 0;
    =}
}

/* [[[cog
    cog.outl(f"main reactor (numTerms: size_t({numTerms}), startRate: double({startRate}), numSeries: size_t({numSeries}))")
]]] */
main reactor (numTerms: size_t(25000), startRate: double(3.46), numSeries: size_t(10))
/// [[[end]]]

{
    
    manager = new Manager(numSeries=numSeries, numTerms=numTerms);
    
    reaction(startup) {=
        
    =}
    
    rateComputers = new[numSeries] RateComputer(startRate=startRate, rateIncrement=0.0025);
    seriesWorkers = new[numSeries] SeriesWorker(termIncrement=0.0025);
    
    //(runner.start)+ -> manager.start, rateComputers.reset, seriesWorkers.reset;
    //manager.finished -> runner.finished;
    
    (manager.nextTerm)+ -> seriesWorkers.nextTerm;
    (manager.getTerm)+ -> seriesWorkers.getTerm;
    seriesWorkers.term -> manager.term;
    
    seriesWorkers.computeRate -> rateComputers.compute;
    rateComputers.rate -> seriesWorkers.rate; 
}