/**
 * Copyright (C) 2020 TU Dresden and UC Berkeley
 *
 * Upon startup, the LinkedList actor initializes a
 * link list with random elements. Upon startup the 
 * Worker actors would send either a `read` or `write`
 * request to the LinkList, which respond by sending
 * a `result` signal. When Worker receive this signal,
 * if they've hit their target requests amount will 
 * send a `finish` message otherwise will continue 
 * to query the LinkList.
 *
 * @author Thee Ho
 * @author Matt Chorlian
 */


target C {
    /* [[[cog
      if (threaded_runtime=="True"):
          cog.outl(f"threads: {threads}")
      else:
          cog.outl("threads: 0")
    ]]] */
    threads: 0
    /// [[[end]]]
};


reactor DictionaryImpl(num_workers:int(20)){
    preamble {=
		struct node{
		    struct node * next; 
		    int key; 
		    int val; 
		};
		
		#define HASHSIZE 1001
		static struct node *table[HASHSIZE]; 
		
		unsigned hash(int i){
		    return (i*2654435761 % 4294967296) % HASHSIZE;
		}
		
		/* lookup: look for s in hashtab */
		struct node * lookup(int key){
		    struct node *curr = table[hash(key)];
		    while(curr != NULL){
		        if (curr->key == key){
		          return curr;
		          }
		        curr = curr->next;  
		      }
		    return NULL;
		}
		
		bool insert(int key, int val){
		    struct node *curr;
		    unsigned hashval;
		    if ((curr = lookup(key)) == NULL) { /* not found */
		        curr = (struct node *) malloc(sizeof(*curr));
		        curr->key = key;
		        hashval = hash(key);
		        curr->next = table[hashval];
		        table[hashval] = curr;
		    } 
		    curr->val = val;
		    return true;
		}
		
        void printlist() {
   			for (int i=0; i<HASHSIZE;i++){
				struct node *current = table[i];
    			while (current != NULL) {
        			printf("Key %d: %d \n", current->key, current->val);
        			current = current->next;
    			}
    		}
		}
    =}
    
    input[num_workers] read:int;
    input[num_workers] write:int;
    input start:bool;
    
  
    output[num_workers] result:bool;
    
    reaction(start){=
        // initialize linked list with random elements
        for (int i = 0; i < 10; i ++){
            insert(rand()%1000,rand()%100);
        }
    =}
    reaction(write)->result{=
    	for (int i = 0; i < self->num_workers; i++){
            if(write[i]->is_present){
                insert(write[i]->value,rand()%100);
         //       printf("Dictionary content after insert: \n");
         //      printlist();
                SET(result[i],true);
            }
        }
	=}
	reaction(read)->result{=
		for (int i = 0; i < self->num_workers; i++){
            if(read[i]->is_present){
                struct node * res = lookup(read[i]->value);
          		int found = -1;
          		if (res != NULL){
                    found = res->val;
                }
           //     printf("Result of looking up %d: %d \n",read[i]->value, found);
                SET(result[i],true);
            }
        }
    =}
}

reactor Worker(instance:int(0), num_requests:int(10), write_percentage:int(10)){
    input start:bool;
    input result:bool;
    
    state requests_sent:int;
    logical action request;
    
    output read:int;
    output write:int;
    output finish:bool;
    
    reaction(start)->request{=
        self->requests_sent = 0;
        schedule(request,0);
    =}
    reaction(request)->read, write{=
        int coin = rand()%100;
 		int val = rand()%1000;
 		if (coin <= self->write_percentage){
            SET(write,val);
          //  printf("Worker %d sent write request for %d \n", self->instance, val);
        }else{
            SET(read,val);
          //  printf("Worker %d sent read request for %d \n", self->instance, val);
        }
        self->requests_sent++;
	=}
	
	reaction(result)->request,finish{=
        if (self->requests_sent>=self->num_requests){
            SET(finish,true);
        }else{
            schedule(request,0);
        }
    =}
}

/* [[[cog
  	  cog.outl(f'main reactor(numWorkers:int({numWorkers}),numMessagesPerWorker:int({numMessagesPerWorker}),writePercentage:int({writePercentage}))')
	]]] */
    main reactor(numWorkers:int(20),numMessagesPerWorker:int(8000),writePercentage:int(10))
	// [[[end]]]
{

    dictionary = new DictionaryImpl(num_workers=numWorkers);
	workers = new[numWorkers] Worker(num_requests=numMessagesPerWorker,write_percentage=writePercentage);
	
	workers.read->dictionary.read;
	workers.write->dictionary.write;
	dictionary.result->workers.result;
	
	reaction(startup)->dictionary.start, workers.start{=
        SET(dictionary.start,true);
        for (int i = 0; i < self->numWorkers; i++){
        	SET(workers[i].start,true);
        }
    =}
}   