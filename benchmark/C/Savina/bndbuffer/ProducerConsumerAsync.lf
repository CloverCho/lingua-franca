/*
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * @author Hannes Klein
 * @author Marten Lohstroh
 * @author Soroush Bateni
 */
 
target C {
    flags: "-lm",
    keepalive: true,
    files: ../include/PseudoRandom.h,
    coordination: centralized
};

preamble {=
    #include <stdlib.h>
    #include <stddef.h>
    #include <math.h>
    #include "PseudoRandom.h"
    
    typedef struct int_fifo_t {
        size_t head;
        size_t tail;
        size_t max_size;
        bool is_full;
        int* arr;
    } int_fifo_t;
    
    /**
     * Report whether the given queue is empty.
     */
    bool int_fifo_is_empty(int_fifo_t* queue) {
        if (queue->head == queue->tail && !queue->is_full) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Report how many elements are in the queue.
     */
    size_t int_fifo_size(int_fifo_t* queue) {
        if (int_fifo_is_empty(queue)) {
            return 0;
        } else if (queue->is_full) {
            return queue->max_size;
        } else if (queue->tail > queue->head) {
            return queue->tail - queue->head;
        } else {
            return queue->max_size - (queue->head - queue->tail);
        }
    }
        
    /**
     * Clear the given queue by resetting its head and tail pointer.
     */    
    void int_fifo_clear(int_fifo_t* queue) {
        queue->head = 0;
        queue->tail = 0;
        queue->is_full = false;
    }
    
    /**
     * Create a new bounded FIFO queue.
     */
    int_fifo_t* int_fifo_create(size_t capacity) {
        int_fifo_t* queue = malloc(sizeof(int_fifo_t));
        queue->arr = malloc(capacity * sizeof(int));
        queue->max_size = capacity;
        int_fifo_clear(queue);
        return queue;
    }
    
    /**
     * Assign the given pointer to the first element in the queue.
     * Return true if the assignment was successful, false otherwise.
     */
    bool int_fifo_pop(int_fifo_t* queue, int* data) {
        if (int_fifo_is_empty(queue)) {
            //printf("Buffer is empty.\n");
            return false;
        } else {
            *data = queue->arr[queue->head];
            //printf("Popping: %d\n", *data);
            queue->head = (queue->head + 1) % queue->max_size;
            queue->is_full = false;
        	return true;
        }
    }
    
    /**
     * Add a new entry to the queue.
     */
    bool int_fifo_push(int_fifo_t* queue, int elem) {
        if (queue->is_full) {
        	//printf("Buffer is full.\n");
			return false;        	
        } else {
            //printf("Pushing: %d\n", elem);
            queue->arr[queue->tail] = elem;
            queue->tail = (queue->tail + 1) % queue->max_size;
            if (queue->head == queue->tail) {
            	queue->is_full = true;
            }
        	return true;
        }
    }
    
	typedef struct double_fifo_t {
        size_t head;
        size_t tail;
        size_t max_size;
        bool is_full;
        double* arr;
    } double_fifo_t;
    
    /**
     * Report whether the given queue is empty.
     */
    bool double_fifo_is_empty(double_fifo_t* queue) {
        if (queue->head == queue->tail && !queue->is_full) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Report how many elements are in the queue.
     */
    size_t double_fifo_size(double_fifo_t* queue) {
        if (double_fifo_is_empty(queue)) {
            return 0;
        } else if (queue->is_full) {
            return queue->max_size;
        } else if (queue->tail > queue->head) {
            return queue->tail - queue->head;
        } else {
            return queue->max_size - (queue->head - queue->tail);
        }
    }
        
    /**
     * Clear the given queue by resetting its head and tail pointer.
     */    
    void double_fifo_clear(double_fifo_t* queue) {
        queue->head = 0;
        queue->tail = 0;
        queue->is_full = false;
    }
    
    /**
     * Create a new bounded FIFO queue.
     */
    double_fifo_t* double_fifo_create(size_t capacity) {
        double_fifo_t* queue = malloc(sizeof(double_fifo_t));
        queue->arr = malloc(capacity * sizeof(double));
        queue->max_size = capacity;
        double_fifo_clear(queue);
        return queue;
    }
    
    /**
     * Assign the given pointer to the first element in the queue.
     * Return true if the assignment was successful, false otherwise.
     */
    bool double_fifo_pop(double_fifo_t* queue, double* data) {
        if (double_fifo_is_empty(queue)) {
            printf("Buffer is empty.\n");
            return false;
        } else {
            *data = queue->arr[queue->head];
            queue->head = (queue->head + 1) % queue->max_size;
            queue->is_full = false;
        	return true;
        }
    }
    
    /**
     * Add a new entry to the queue.
     */
    bool double_fifo_push(double_fifo_t* queue, int elem) {
        if (queue->is_full) {
        	printf("Buffer is full.\n");
			return false;        	
        } else {
            queue->arr[queue->tail] = elem;
            queue->tail = (queue->tail + 1) % queue->max_size;
            if (queue->head == queue->tail) {
            	queue->is_full = true;
            }
        	return true;
        }
    }
    
    
    static double processItem(const double curTerm, const int cost) {
		double res = curTerm;
        struct PseudoRandom random;
        initPseudoRandom(&random, cost);
        if(cost > 0) {
        	for(int i = 0; i < cost; i++) {
            	for(int j = 0; j < 100; j++) {
                	res += log(abs(nextDouble(random)) + 0.01);
				}
			}
		} else {
			res += log(abs(nextDouble(random)) + 0.01);
		}
        return res;
	}
	
	void printBenchmarkInfo(char* benchmarkId) {
            printf("Benchmark: %s\n", benchmarkId);
        }
        
        void printSystemInfo() {
            
            printf("System information\n"); 
            printf("O/S Name: ");
            
            #ifdef _WIN32
            printf("Windows 32-bit");
            #elif _WIN64
            printf("Windows 64-bit");
            #elif __APPLE__ || __MACH__
            printf("Mac OSX");
            #elif __linux__
            printf("Linux");
            #elif __FreeBSD__
            printf("FreeBSD");
            #elif __unix || __unix__
            printf("Unix");
            #else
            printf("Other");
            #endif
            
            printf("\n");
        }
	
=}

reactor Manager(bufferSize:size_t(50), numProducers:size_t(40), numConsumers:size_t(40)) {
    
    state adjustedBufferSize:int(0);
    state availableProducers:int_fifo_t*;
    state availableConsumers:int_fifo_t*;
    state pendingData:double_fifo_t*;
    state numTerminatedProducers:int(0);
    
    input[numProducers] producerData:double;
    output[numProducers] produceNext:bool;
    input[numConsumers] consumerDone:bool;
    input[numProducers] producerDone:bool; 
    output[numConsumers] consumerData:double;
    
    logical action requestData;
    
    /**
     * Populate the "available" FIFO queues and schedule
     * the produce action.
     */
    reaction(startup) -> requestData {=
        printf("Manager started up.\n");
        self->adjustedBufferSize = self->bufferSize - self->numProducers;
        self->availableProducers = int_fifo_create(self->numProducers);
        self->availableConsumers = int_fifo_create(self->numConsumers);
        self->pendingData = double_fifo_create(self->bufferSize);
        
        for (int i = 0; i < self->numConsumers; i++) {
			int_fifo_push(self->availableConsumers, i);
        }
        for (int i = 0; i < self->numProducers; i++) {
			int_fifo_push(self->availableProducers, i);
        }
        schedule(requestData, 0);
    =}

	/**
	 * Tell producers to start producing provided that there is enough
	 * space in the pending data FIFO.
	 */
    reaction(requestData) -> produceNext {=
        printf("Manager requesting more data.\n");
        while(double_fifo_size(self->pendingData) < self->adjustedBufferSize) {            
            if (int_fifo_is_empty(self->availableProducers)) {
                printf("All producers are now busy.\n");
                break;
            }
            int idx;
            int_fifo_pop(self->availableProducers, &idx);
            printf("Asking producer %d to start.\n", idx);
            SET(produceNext[idx], true);
        }
    =}
    
    /**
     * Respond to new data coming in.
     */
    reaction(producerData) -> consumerData, requestData {=
		// Stick all incoming data in a buffer.
		for (int i = 0; i < producerData_width; i++) {
            if (producerData[i]->is_present) {
                double_fifo_push(self->pendingData, producerData[i]->value);
				int_fifo_push(self->availableProducers, i);
            }
		}
		// Find a consumer for all pending data.
		int idx;
		double data;
		while (!double_fifo_is_empty(self->pendingData)) {
            if (int_fifo_pop(self->availableConsumers, &idx)) {
            	double_fifo_pop(self->pendingData, &data);
            	SET(consumerData[idx], data);  
            } else {
                break;
            }
        }
        // Ask the producers to produce more.
        schedule(requestData, 0);
    =}
    
    /**
     * Register producers that are done. 
     */
    reaction(producerDone) {=
        for (int i = 0; i < producerDone_width; i++) {
			if (producerDone[i]->is_present) {
				self->numTerminatedProducers += 1;
			}
		}
	=}
    
    
    
//    reaction(consume) -> outConsumers, outProducers {=
//        printf("consume reaction is not invoked.\n");
//        
//        if(self->numTerminatedProducers == self->numProducers &&
//            size(self->availableConsumers) == self->numConsumers) {
//            return;
//        }
//        
//        for (int i = 0; i < size(self->availableConsumers); i++) {
//            if (is_empty(self->pendingData)) {
//                break;
//            }
//            message_t* msg;
//            msg = pop(self->pendingData); // FIXME: wrong data type
//            printf("Popped %f.\n", msg->data);
//            int* idx;
//            idx = pop(self->availableConsumers);
//            SET(outConsumers[*idx], *msg);
//            free(idx);
//            free(msg);
//            if (!is_empty(self->availableProducers)) {
//                int* idx;
//                idx = pop(self->availableProducers);
//                printf("Popped %d.\n", *idx);
//                message_t msg = {ProduceDataMsg, *idx + 1.0};
//                SET(outProducers[*idx], msg);
//                printf("outProducers[%d] = %f.\n", *idx, outProducers[*idx]->value.data);
//                free(idx);
//            }
//        }
//    =}
    
//    reaction(inStart) -> produce {=
//        printf("inStart reaction is invoked.\n");
//        
//        // reset local state
//        clear(self->availableProducers);
//        clear(self->availableConsumers);
//        clear(self->pendingData);
//        self->numTerminatedProducers = 0;
//        
//        // start execution
//       
//    =}
//    
//    reaction(inConsumers) -> consume {=
//        printf("inConsumers reaction is not invoked.\n");
//        for (int i = 0; i < inConsumers_width; i++) {
//            if (inConsumers[i]->is_present) {
//                if(inConsumers[i]->value.type == ConsumerAvailableMsg) {
//					int* inConsumer = (int*)malloc(sizeof(int)); // FIXME: this should be freed
//					*inConsumer = i;
//                    push(self->availableConsumers, inConsumer);
//                }
//            }
//        }
//        schedule(consume, 0);
//    =}
//    
//    reaction(inProducers) -> produce, consume, outFinished {=
//        printf("inProducers reaction is not invoked.\n");
//        for(int i = 0; i < inProducers_width; i++) {
//            if(inProducers[i]->is_present) {
//                if (inProducers[i]->value.type == DataItemMsg) {
//                    push(self->pendingData, &inProducers[i]->value); // FIXME: Not the right data type
//					int* producer = (int*)malloc(sizeof(int)); // FIXME: this should be freed
//					*producer = i;                    
//                    push(self->availableProducers, producer);
//                    schedule(consume, 0);
//                    schedule(produce, 0);
//                } else if(inProducers[i]->value.type == ProducerExitMsg) {
//                    self->numTerminatedProducers += 1;
//                    if(self->numTerminatedProducers == self->numProducers &&
//                        size(self->availableConsumers) == self->numConsumers) {
//                        SET(outFinished, true);
//                        return;
//                    }
//                }
//            }
//        }
//    =}
}

reactor Producer(numItemsToProduce:int(1000), prodCost:int(25)) {
        
    state prodItem:double(0.0);
    state itemsProduced:int(0);
    
    input next:bool;
    output done:bool;
    output data:double;
    
    reaction(next) -> data, done {=
		printf("Producer creating data.\n");
		if (self->itemsProduced == self->numItemsToProduce) {
        	SET(done, true);
        } else {
            SET(data, processItem(self->prodItem, self->prodCost));
            self->itemsProduced += 1;
        }
    =}
}

reactor Consumer(numItemsToConsume:int(1000), consCost:int(25)) {
    
    state consItem:double(0.0);
    state itemsConsumed:int(0);
    input data:double;
    output done:bool;
    
    reaction(data) -> done {=
        printf("One consumer got new data.\n");
        self->consItem = processItem(self->consItem + data->value, self->consCost);
        self->itemsConsumed += 1;
        if (self->itemsConsumed == self->numItemsToConsume) {
			printf("One consumer finished...\n");
			SET(done, true);
        }
    =}
    
    }

//main reactor Test {
//	state p:double_fifo_t*;
//	state q:int_fifo_t*;
//	reaction(startup) {=
//    	self->q = int_fifo_create(4);
//    	int_fifo_push(self->q, 1);
//		int_fifo_push(self->q, 2);
//		int_fifo_push(self->q, 3);
//		int_fifo_push(self->q, 4);
//		while(!int_fifo_is_empty(self->q)) {
//				int ptr;
//				int_fifo_pop(self->q, &ptr);
//				printf("value: %d\n", ptr);
//				printf("size: %d\n", int_fifo_size(self->q));
//        }
//        
//        self->p = double_fifo_create(4);
//    	double_fifo_push(self->p, 1.0);
//		double_fifo_push(self->p, 2.0);
//		double_fifo_push(self->p, 3.0);
//		double_fifo_push(self->p, 4.0);
//		while(!double_fifo_is_empty(self->p)) {
//				double ptr;
//				double_fifo_pop(self->p, &ptr);
//				printf("value: %f\n", ptr);
//				printf("size: %d\n", double_fifo_size(self->p));
//        }
//    =} 
//
//}
main reactor ProdConsAsync(bufferSize:int(50), prodCost:int(25), consCost:int(25), numItemsPerProducer:int(1000)) {
    
    reaction(startup) {=
        printBenchmarkInfo("ProdConsBenchmark");
        // printArgs("numIterations", self->numIterations, "bufferSize", self->bufferSize, "prodCost", self->prodCost, "consCost", self>consCost, "numItemsPerProducer", self->numItemsPerProducer, "numProducers", 40, "numConsumers", 40);
        printf("bufferSize: %d.\n", self->bufferSize);
        printf("prodCost: %d.\n", self->prodCost);
        printf("consCost: %d.\n", self->consCost);
        printf("numItemsPerProducer: %d.\n", self->numItemsPerProducer);
        printf("numProducers: %d.\n", 40);
        printf("numConsumers: %d.\n", 40);
		
        printSystemInfo();
    =}
    manager = new Manager(bufferSize=bufferSize, numProducers=40, numConsumers=40);
    producers = new[40] Producer(numItemsToProduce=numItemsPerProducer, prodCost=prodCost);
    consumers = new[40] Consumer(numItemsToConsume=numItemsPerProducer, consCost=consCost);
    
    // FIXME: We should use physical connections along the data path.
    // These are not supported yet. We could use banks of reactors that schedule a phys. action.
    
    manager.produceNext -> producers.next;
    manager.consumerData -> consumers.data;
    producers.data -> manager.producerData;
    producers.done -> manager.producerDone;
    consumers.done -> manager.consumerDone;
    
    
}
