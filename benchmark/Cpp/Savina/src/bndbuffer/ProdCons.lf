/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */
 
 /**
 * Concurrency benchmark from the Savina benchmark suite, intended
 * to measure message passing overhead and switching between
 * actors.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * To open the causality loop in the ring of reactors one
 * reactor uses a logical action for message passing.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "../IncludeHeaders.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


public preamble {=
    enum MsgType {
      DataItemMsg,
      ProduceDataMsg,
      ProducerExitMsg,
      ConsumerAvailableMsg,
      ConsumerExitMsg
    };
    
    struct Message {
      MsgType type;
      double data;
    };
    
    double processItem(const double curTerm, const size_t cost);
=}

private preamble {=
    #include <cmath>
    #include "PseudoRandom.hh"
    
    double processItem(const double curTerm, const size_t cost) {
        double res = curTerm;
        
        PseudoRandom random(cost);
        if(cost > 0) {
            for(size_t i{0}; i < cost; i++) {
                for(size_t j{0}; j < 100; j++) {
                    res += log(abs(random.nextDouble()) + 0.01);
                }
            }
        } else {
            res += log(abs(random.nextDouble()) + 0.01);
        }
        
        return res;
    }
=}

reactor ManagerReactor(bufferSize: size_t{50}, numProducers: size_t{40}, numConsumers: size_t{40}) {
    
    state adjustedBufferSize: size_t{{=bufferSize-numProducers=}};
    state availableProducers: std::vector<int>;
    state availableConsumers: std::vector<int>;
    state pendingData: {=std::vector<reactor::ImmutableValuePtr<Message>>=};
    state numTerminatedProducers: size_t{0};
    
    input inStart: void;
    output outFinished: void;
    
    logical action consume: void;
    logical action produce: void;
    
    input[numProducers] inProducers: Message;
    output[numProducers] outProducers: Message;
    input[numConsumers] inConsumers: Message;
    output[numConsumers] outConsumers: Message;
    
    reaction(startup) {=
        // init local state
        availableProducers.reserve(numProducers);
        availableConsumers.reserve(numConsumers);
        pendingData.reserve(bufferSize);
        
    =}
    
    reaction(produce) -> outProducers {=
        while(pendingData.size() < adjustedBufferSize) {
            if(availableProducers.empty()) {
                return;
            }
            
            outProducers[availableProducers[0]].set(Message{ProduceDataMsg, 0.0});
            availableProducers.erase(begin(availableProducers));
        }
    =}
    
    reaction(consume) -> outConsumers, outProducers {=
        if(numTerminatedProducers == numProducers &&
            availableConsumers.size() == numConsumers) {
            return;
        }
        
        for(size_t i{0}; i < availableConsumers.size(); i++) {
            if(pendingData.empty()) {
                break;
            }
            
            outConsumers[availableConsumers[0]].set(pendingData[0]);
            availableConsumers.erase(begin(availableConsumers));
            pendingData.erase(begin(pendingData));
            if(!availableProducers.empty()) {
                outProducers[availableProducers[0]].set(Message{ProduceDataMsg, 0.0});
                availableProducers.erase(begin(availableProducers));
            }
        }
    =}
    
    reaction(inStart) -> produce {=
        // reset local state
        availableProducers.clear();
        availableConsumers.clear();
        pendingData.clear();
        numTerminatedProducers = 0;
        
        // start execution
        for(size_t i{0}; i < numProducers; i++) {
            availableProducers.push_back(i);
        }
        for(size_t i{0}; i < numConsumers; i++) {
            availableConsumers.push_back(i);
        }
        produce.schedule();
    =}
    
    reaction(inConsumers) -> consume {=
        for(size_t i{0}; i < inConsumers.size(); i++) {
            if(inConsumers[i].is_present()) {
                if(inConsumers[i].get()->type == ConsumerAvailableMsg) {
                    availableConsumers.push_back(i);
                }
            }
        }
        consume.schedule();
    =}
    
    reaction(inProducers) -> produce, consume, outFinished {=
        for(size_t i{0}; i < inProducers.size(); i++) {
            if(inProducers[i].is_present()) {
                if(inProducers[i].get()->type == DataItemMsg) {
                    
                    pendingData.push_back(inProducers[i].get());
                    availableProducers.push_back(i);
                    consume.schedule();
                    produce.schedule();
                    
                } else if(inProducers[i].get()->type == ProducerExitMsg) {
                    
                    numTerminatedProducers += 1;
                    
                    if(numTerminatedProducers == numProducers &&
                        availableConsumers.size() == numConsumers) {
                        outFinished.set();
                        return;
                    }
                }
            }
        }
    =}
}

reactor ProducerReactor(numItemsToProduce: size_t{1000}, prodCost: size_t{25}) {

    state prodItem: double{0.0};
    state itemsProduced: size_t{0};
    
    input inManager: Message;
    output outManager: Message;
    
    reaction(inManager) -> outManager {=
        
        if(inManager.get()->type == ProduceDataMsg) {
            if(itemsProduced == numItemsToProduce) {
                outManager.set(Message{ProducerExitMsg, 0.0});
                
                // reset local state
                prodItem = 0.0;
                itemsProduced = 0;
                return;
            }
            prodItem = processItem(prodItem, prodCost);
            outManager.set(Message{DataItemMsg, prodItem});
            itemsProduced += 1;
        }
    =}
}

reactor ConsumerReactor(consCost: size_t{25}) {
    
    state consItem: double{0.0};
    
    input inManager: Message;
    output outManager: Message;
    
    reaction(inManager) -> outManager {=
        
        if(inManager.get()->type == DataItemMsg) {
            double dataToConsume =  inManager.get()->data;
            consItem = processItem(consItem + dataToConsume, consCost);
            outManager.set(Message{ConsumerAvailableMsg, 0.0});
        } else if(inManager.get()->type == ConsumerExitMsg) {
            // reset local state
            consItem = 0.0;
        }
    =}
}

main reactor (
    numIterations: size_t{12},
    bufferSize: size_t{50},
    prodCost: size_t{25},
    consCost: size_t{25},
    numItemsPerProducer: size_t{1000},
    numConsumers: size_t{40},
    numProducers: size_t{40}
) {
    manager = new ManagerReactor(bufferSize=bufferSize, numProducers=numProducers, numConsumers=numConsumers);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> manager.inStart;
    manager.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("ProdConsBenchmark");
        printArgs("numIterations", numIterations, "bufferSize", bufferSize, "prodCost", prodCost,
                  "consCost", consCost, "numItemsPerProducer", numItemsPerProducer, 
                  "numProducers", numProducers, "numConsumers", numConsumers);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    producers = new[numProducers] ProducerReactor(numItemsToProduce=numItemsPerProducer, prodCost=prodCost);
    consumers = new[numConsumers] ConsumerReactor(consCost=consCost);
    
    manager.outProducers -> producers.inManager;
    producers.outManager -> manager.inProducers;
    
    manager.outConsumers -> consumers.inManager;
    consumers.outManager -> manager.inConsumers;
}