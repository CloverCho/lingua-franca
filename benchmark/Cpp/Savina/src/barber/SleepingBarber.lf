/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This implementation is close to the Savina Akka implementation
 * in terms of the work that is done in each actor/reactor and
 * that for each message sent in Savina there is a message send
 * in this implementation. But this implementation does not
 * show the basic idea of the problem in that the waiting
 * room is basically never because the customers arrival is
 * in sync with the barber cutting the hair of customers.
 * 
 * There are some interesting different possibilities to implement the
 * benchmark more based on the original idea behind it instead
 * of the Savina implementation. For example by using threads that
 * trigger events in physical time and handling missed
 * deadlines if the waiting room is full. But these would lack
 * comparability with the Savina benchmark even more.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "../IncludeHeaders.cmake",
    logging: "info"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


public preamble {=
    enum MsgType {
      ResetMsg,
      StartMsg,
      EnterMsg,
      NextMsg,
      ExitMsg,
      FullMsg,
      WaitMsg,
      ReturnedMsg,
      DoneMsg
    };
    
    struct Message {
    
      MsgType type;
      size_t id;
    
      Message(MsgType _type):
        type(_type) {}
    
      Message(MsgType _type, size_t _id):
        type(_type), id(_id) {}
    };
=}

reactor CustomerFactory(numHaircuts:size_t(2000), averageProductionRate:size_t(1000)) {
    /*
     * In the original Akka implementation, the CustomerFactory would create customers as needed.
     * This dynamic creation of customers, however, requires mutations. Instead, we here create
     * all customers statically and the CustomerFactory is only in charge of controlling the customers. 
     */
    
    public preamble {=
        #include "PseudoRandom.hh"
        #include <list>
    =}
    
    private preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state numHairCutsSoFar: size_t(0);
    state numAttempts: size_t(0); // idGenerator in Savina
    state nextCustomerToSendFirstIdx: size_t(0);
    state customersToReturn: std::list<size_t>;
    state random: PseudoRandom;
    
    input inStart:void;
    output outFinished:void;
    
    output outRoom: Message;
    output outBarber: Message; // only needed to reset between iterations
    
    input[numHaircuts] customerDone: void;
    input[numHaircuts] customerReturned: void;
    
    logical action sendCustomersFirstVisit:void;
    logical action sendCustomersToReturn:void;
    logical action exit:void;
    
    reaction(inStart) -> outRoom, outBarber, sendCustomersFirstVisit {=
        
        // reset local state
        numHairCutsSoFar = 0;
        numAttempts = 0;
        nextCustomerToSendFirstIdx = 0;
        customersToReturn.clear();
        random = PseudoRandom();
        
        // send signals to reset
        outBarber.set(Message{ResetMsg});
        outRoom.set(Message{ResetMsg});
        
        // start execution
        sendCustomersFirstVisit.schedule();
    =}
    
    reaction(sendCustomersFirstVisit) -> outRoom, sendCustomersFirstVisit, sendCustomersToReturn {=
        
        if(nextCustomerToSendFirstIdx == numHaircuts) {
            sendCustomersToReturn.schedule();
            return;
        }
        
        numAttempts += 1;
        outRoom.set(Message{EnterMsg, nextCustomerToSendFirstIdx});
        nextCustomerToSendFirstIdx += 1;
        sendCustomersFirstVisit.schedule();
        busyWait(random.nextInt(averageProductionRate) + 10);
    =}
    
    reaction(sendCustomersToReturn) -> outRoom, sendCustomersToReturn {=
        
        if(customersToReturn.empty()) {
            // wait for finish
            return;
        }
        
        numAttempts += 1;
        outRoom.set(Message{EnterMsg, customersToReturn.front()});
        customersToReturn.pop_front();
        sendCustomersToReturn.schedule();
    =}
    
    reaction(exit) -> outRoom, outBarber, outFinished {=
        reactor::log::Info() << "Hair cuts given: " << numHairCutsSoFar << "; Total attempts: " << numAttempts;
        outRoom.set(Message{ExitMsg});
        outBarber.set(Message{ExitMsg});
        outFinished.set();
    =}
    
    reaction(customerReturned) -> sendCustomersToReturn {=
        for(size_t i = 0; i < customerReturned.size(); i++) {
            if(customerReturned[i].is_present()) {
                reactor::log::Info() << "Customer " << i << " returned";
                customersToReturn.push_back(i);
            }
        }
        sendCustomersToReturn.schedule();
    =}
    
    reaction (customerDone) -> exit {=
        for(size_t i = 0; i < customerDone.size(); i++) {
            if(customerDone[i].is_present()) {
                reactor::log::Info() << "Customer " << i << " is done";
                numHairCutsSoFar += 1;
                if(numHairCutsSoFar == numHaircuts) {
                    exit.schedule();
                }
            }
        }
    =}
    
    private preamble {=
        
        static int busyWait(const int limit) {
            int test = 0;
            
            for(int k = 0; k < limit; ++k) {
                rand();
                ++test;
            }
            
            return test;
        }
    =}
}

reactor CustomerReactor(bank_index:size_t(0)) {
    
    output done: void;
    output returned: void;
    input inRoom: Message;
    input inBarber: Message;
    
    reaction(inRoom) -> returned {=
        if(inRoom.get()->type == FullMsg) {
            returned.set();
        } else if(inRoom.get()->type == WaitMsg) {
            // do nothing, just sit in the waiting room
        }
    =}
    
    reaction(inBarber) -> done {=
        if(inBarber.get()->type == StartMsg) {
            // do nothing, the barber is barbering me now.
        } else if(inBarber.get()->type == DoneMsg) {
            done.set();
            // this reactor is finished and could be destroyed
        }
    =}
}

reactor BarberReactor(averageHaircutRate:size_t(1000), numHaircuts:size_t(2000)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
        #include "reactor-cpp/logging.hh"
    =}
    
    state currentCustomerIdx: size_t(-1);
    state random: PseudoRandom;
    
    input inRoom: Message;
    input inController: Message;
    output[numHaircuts] outCustomers: Message;
    output outRoom: Message;
    
    logical action cutHair:void;
    
    reaction(inController) {=
        if(inController.get()->type == ResetMsg) {
            // reset local state
            currentCustomerIdx = -1;
            random = PseudoRandom();
        }  else if(inController.get()->type == ExitMsg) {
            // do nothing
        }
    =}
    
    reaction(cutHair) -> outRoom, outCustomers {=
        reactor::log::Info() << "Cutting hair of customer " << currentCustomerIdx;
        busyWait(random.nextInt(averageHaircutRate) + 10); // doing work inline is overall faster in this benchmark
        outCustomers[currentCustomerIdx].set(Message{DoneMsg});
        currentCustomerIdx = -1;
        outRoom.set(Message{NextMsg});
    =}
    
    reaction(inRoom) -> outCustomers, cutHair {=
        if(inRoom.get()->type == EnterMsg) {
            currentCustomerIdx = inRoom.get()->id;
            reactor::log::Info() << "Barber is serving customer " << currentCustomerIdx;
            outCustomers[currentCustomerIdx].set(Message{StartMsg});
            cutHair.schedule();
        } else if(inRoom.get()->type == WaitMsg) {
            // do nothing and to to sleep
        }
    =}
    
    private preamble{=
        static int busyWait(const int limit) {
            int test = 0;
            
            for(int k = 0; k < limit; ++k) {
                rand();
                ++test;
            }
            
            return test;
        }
    =}
}

reactor WaitingRoomReactor(capacity:size_t(1000), numCustomers:size_t(2000)) {
    
    public preamble {=
        #include "reactor-cpp/logging.hh"
        #include <queue>
    =}
    
    state waitingCustomers: std::queue<size_t>;
    state barberAsleep:bool(true);
    
    output[numCustomers] outCustomers: Message;
    input inBarber: Message;
    output outBarber: Message;
    input inController: Message;
    
    logical action wakeBarber: Message;
    
    reaction(inBarber, wakeBarber) -> outBarber {=
        
        if((wakeBarber.is_present() && wakeBarber.get()->type == NextMsg) ||
            (inBarber.is_present() && inBarber.get()->type == NextMsg)) {
            
            if(!waitingCustomers.empty()) {
                size_t customerIdx = waitingCustomers.front();
                reactor::log::Info() << "Room is sending customer " << customerIdx << " to the barber.";
                waitingCustomers.pop();
                outBarber.set(Message{EnterMsg, customerIdx});
            } else {
                outBarber.set(Message{WaitMsg});
                barberAsleep = true;
            }
        }
    =}
    
    reaction(inController) -> outCustomers, wakeBarber {=
        
        if(inController.get()->type == EnterMsg) {
            
            size_t customerIdx = inController.get()->id;
            reactor::log::Info() << "Customer " << customerIdx << " trying to enter.";
            
            if(waitingCustomers.size() == capacity) {
                outCustomers[customerIdx].set(Message{FullMsg});
            } else {
                
                waitingCustomers.push(customerIdx);
                if(barberAsleep) {
                    barberAsleep = false;
                    wakeBarber.schedule(Message{NextMsg, customerIdx});
                } else {
                    outCustomers[customerIdx].set(Message{WaitMsg});
                }
            }
            
        } else if(inController.get()->type == ResetMsg) {
            
            // reset local state
            waitingCustomers = std::queue<size_t>();
            barberAsleep = true;
            
        } else if(inController.get()->type == ExitMsg) {
            
            // do nothing, controller sends exit msg to barber directly
        }
    =}
}

main reactor (numIterations:size_t(12), waitingRoomSize:size_t(1000), averageProductionRate:size_t(1000), averageHaircutRate:size_t(1000), numHaircuts:size_t(2000)) {
    

    factory = new CustomerFactory(numHaircuts=numHaircuts, averageProductionRate=averageProductionRate);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> factory.inStart;
    factory.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("SleepingBarberReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "waitingRoomSize", waitingRoomSize, "averageProductionRate", averageProductionRate, "averageHaircutRate", averageHaircutRate, "numHaircuts", numHaircuts);
        printSystemInfo();
        runner.inStart.set();
    =}

    room = new WaitingRoomReactor(capacity=waitingRoomSize, numCustomers=numHaircuts);
    customers = new[numHaircuts] CustomerReactor();
    barber = new BarberReactor(averageHaircutRate=averageHaircutRate);
    
    factory.outRoom -> room.inController;
    factory.outBarber -> barber.inController;
    
    room.outCustomers -> customers.inRoom;
    room.outBarber -> barber.inRoom;
    
    barber.outCustomers -> customers.inBarber;
    barber.outRoom -> room.inBarber;
    
    customers.done -> factory.customerDone;
    customers.returned -> factory.customerReturned;
}