/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "FilterBank.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    #include "FilterBankCommon.hh"
    
    using CoefficientMatrix = std::vector<std::vector<double>>;
=}

reactor ProducerReactor(numChannels: size_t{8}, numSimulations: size_t{34816}, numColumns: size_t{16384}) {
        
    state numMessagesSent: size_t{0};
    
    input inStart:void;
    output outFinished:void;
    input inInitializeStart:void;
    output outInitializeFinished:void;
    
    input inSource: Message;
    output outSource: Message;
    
    logical action sendToSource: Message;
    logical action start: Message;
    
    reaction(inInitializeStart) -> outInitializeFinished {=
        outInitializeFinished.set();
    =}
    
    reaction(inStart) -> sendToSource {=
        // reset local state
        numMessagesSent = 0;
        
        // start execution
        sendToSource.schedule(Message{BootMsg});
        numMessagesSent += 1;
    =}
    
    reaction(sendToSource) -> outSource {=
        outSource.set(sendToSource.get());
    =}
    
    reaction(inSource) -> sendToSource {=
        if(inSource.get()->type == NextMsg) {            
            if(numMessagesSent >= numSimulations) {
                sendToSource.schedule(Message{ExitMsg}); //TODO directly sending possible?
            } else {
                sendToSource.schedule(Message{BootMsg});
                numMessagesSent += 1;
            }
        }
    =}
}

reactor SourceReactor {
    
    state maxValue: size_t{1000};
    state current: size_t{0};
    
    input inProducer: Message;
    output outProducer: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    reaction(inProducer) -> outSuccessorValue, outSuccessorControl, outProducer {=
        if(inProducer.get()->type == BootMsg) {
            outSuccessorValue.set(current);
            current = (current + 1) % maxValue;
            outProducer.set(Message{NextMsg});
        } else if(inProducer.get()->type == ExitMsg) {
            outSuccessorControl.set(inProducer.get());
            
            // reset local state
            current = 0;
        }
    =}
}

reactor BranchesReactor(numChannels: size_t{8}, numColumns: size_t{16384}) {
    
    output[numChannels] outBanksValue: double;
    output[numChannels] outBanksControl: Message;
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    
    reaction(inPredecessorValue) -> outBanksValue {=
        for(size_t i{0}; i < numChannels; i++) {
            outBanksValue[i].set(inPredecessorValue.get());
        }
    =}
    
    reaction(inPredecessorControl) -> outBanksControl {=
        if(inPredecessorControl.get()->type == ExitMsg) {
            for(size_t i{0}; i < numChannels; i++) {
                outBanksControl[i].set(inPredecessorControl.get());
            }
        }
    =}
}

reactor BankReactor(bank_index: size_t{0}, numColumns: size_t{16384}, numChannels: size_t{8}) {    
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    input setF: CoefficientMatrix;
    input setH: CoefficientMatrix;
    
    delay0 = new DelayReactor(
        sourceId={=std::to_string(bank_index) + ".1"=},
        delayLength={=numColumns - 1=}
    );
    fir0 = new FirFilterReactor(
        bank_index=bank_index,
        sourceId={=std::to_string(bank_index) + ".1"=},
        peekLength=numColumns
    );
    sample = new SampleFilterReactor(sampleRate=numColumns);
    delay1 = new DelayReactor(
        sourceId={=std::to_string(bank_index) + ".2"=},
        delayLength={=numColumns - 1=}
    );
    fir1 = new FirFilterReactor(
        bank_index=bank_index,
        sourceId={=std::to_string(bank_index) + ".2"=},
        peekLength=numColumns
    );
    tagged = new TaggedForwardReactor();
    
    inPredecessorControl -> delay0.inPredecessorControl;
    inPredecessorValue -> delay0.inPredecessorValue;
    
    delay0.outSuccessorControl -> fir0.inPredecessorControl;
    delay0.outSuccessorValue -> fir0.inPredecessorValue;
    fir0.outSuccessorControl -> sample.inPredecessorControl;
    fir0.outSuccessorValue -> sample.inPredecessorValue;
    sample.outSuccessorControl -> delay1.inPredecessorControl;
    sample.outSuccessorValue -> delay1.inPredecessorValue;
    delay1.outSuccessorControl -> fir1.inPredecessorControl;
    delay1.outSuccessorValue -> fir1.inPredecessorValue;
    fir1.outSuccessorControl -> tagged.inPredecessorControl;
    fir1.outSuccessorValue -> tagged.inPredecessorValue;
    
    tagged.outSuccessorControl -> outSuccessorControl;
    tagged.outSuccessorValue -> outSuccessorValue;
    
    setH -> fir0.setCoefficients;
    setF -> fir1.setCoefficients;
}

reactor DelayReactor(sourceId: std::string{"no source id"}, delayLength: size_t{16383}) {
    
    state myState: std::vector<double>;
    state placeHolder: size_t{0};
    
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message ;
    
    reaction(startup) {=
        // one time init
        myState = std::vector<double>(delayLength, 0.0);
        placeHolder = 0;
    =}
    
    reaction(inPredecessorValue) -> outSuccessorValue {=
        double result = *inPredecessorValue.get();
        outSuccessorValue.set(myState[placeHolder]);
        myState[placeHolder] = result;
        placeHolder = (placeHolder + 1) % delayLength;
    =}
    
    reaction(inPredecessorControl) -> outSuccessorControl {=
        outSuccessorControl.set(inPredecessorControl.get());
        
        // reset local state
        myState = std::vector<double>(delayLength, 0.0);
        placeHolder = 0;
    =}
}

reactor FirFilterReactor(
    bank_index:size_t{0},
    sourceId: std::string{"no source id"},
    peekLength: size_t{16384}) {
    
    state data: std::vector<double>;
    state dataIndex: size_t{0};
    state dataFull: bool{false};
    state coefficients: {=reactor::ImmutableValuePtr<CoefficientMatrix>=}{{=nullptr=}}
    
    input setCoefficients: CoefficientMatrix
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    reaction(startup) {=
        // reset local state
        data = std::vector<double>(peekLength, 0.0);
        dataIndex = 0;
        dataFull = false;
    =}
    
    reaction (setCoefficients) {=
        coefficients = setCoefficients.get();
    =}
    
    reaction(inPredecessorValue) -> outSuccessorValue {=
        double result = *inPredecessorValue.get();
        data[dataIndex] = result;
        dataIndex += 1;
        
        if(dataIndex == peekLength) {
            dataFull = true;
            dataIndex = 0;
        }
        
        if(dataFull) {
            double sum{0.0};
            size_t i{0};
            while(i < peekLength) {
                sum += data[i] * (*coefficients)[bank_index][peekLength - i - 1];
                i += 1;
            }
            outSuccessorValue.set(sum);
        }
    =}
    
    reaction(inPredecessorControl) -> outSuccessorControl {=
        outSuccessorControl.set(inPredecessorControl.get());
        
        // reset local state
        data = std::vector<double>(peekLength, 0.0);
        dataIndex = 0;
        dataFull = false;
    =}
}

reactor SampleFilterReactor(sampleRate: size_t{16384}) {
    
    state ZERO_RESULT:double(0.0);
    state samplesReceived: size_t{0};
    
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    reaction(startup) {=
        // reset local state
        samplesReceived = 0;
    =}
    
    reaction(inPredecessorValue) -> outSuccessorValue {=
        if(samplesReceived == 0) {
            outSuccessorValue.set(inPredecessorValue.get());
        } else {
            outSuccessorValue.set(ZERO_RESULT);
        }
        samplesReceived = (samplesReceived + 1) % sampleRate;
    =}
    
    reaction(inPredecessorControl) -> outSuccessorControl {=
        outSuccessorControl.set(inPredecessorControl.get());
        
        // reset local state
        samplesReceived = 0;
    =}
}

//FIXME this reactor does nothing in the reactor model. Because messages are tagged by the input
// port they arrive through.
reactor TaggedForwardReactor { 
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    reaction(inPredecessorValue) -> outSuccessorValue {=
        double result = *inPredecessorValue.get();
        outSuccessorValue.set(result);
    =}
    
    reaction(inPredecessorControl) -> outSuccessorControl {=
        outSuccessorControl.set(inPredecessorControl.get());
    =}
}

reactor IntegratorReactor(numChannels: size_t{8}) {
    
    state data: std::vector<std::map<int,double>>;
    state exitsReceived: size_t{0};
    
    input[numChannels] inPredecessorsValue: double ;
    input[numChannels] inPredecessorsControl: Message;
    output outSuccessorCollection: std::vector<double>;
    output outSuccessorControl: Message;
    
    reaction(startup) {=
        // reset local state
        data = std::vector<std::map<int,double>>();
        exitsReceived = 0;
    =}
    
    reaction(inPredecessorsValue) -> outSuccessorCollection {=
        for(size_t i{0}; i < inPredecessorsValue.size(); ++i) {
            if(inPredecessorsValue[i].is_present()) {
                size_t sourceId{i};
                double result{*inPredecessorsValue[i].get()};
                size_t dataSize{data.size()};
                bool processed{false};
                
                for (size_t j{0}; j < dataSize; j++) {
                    std::map<int, double>& loopMap = data[j];
                    if(loopMap.find(sourceId) == end(loopMap)) {
                        loopMap.emplace(sourceId, result);
                        processed = true;
                        break;
                    }
                }
                
                if(!processed) {
                    data.emplace_back();
                    data.back().emplace(sourceId, result);
                }
                
                auto& firstMap = data[0];
                if(firstMap.size() == numChannels) {
                    auto collection = reactor::make_mutable_value<std::vector<double>>();
                    collection->reserve(firstMap.size());
                    for(auto& val: firstMap) {
                        collection->push_back(val.second);
                    }
                    outSuccessorCollection.set(reactor::ImmutableValuePtr<std::vector<double>>(std::move(collection)));
                    data.erase(begin(data));
                }
            }
        }
    =}
    
    reaction(inPredecessorsControl) -> outSuccessorControl {=
        for(size_t i{0}; i < inPredecessorsControl.size(); ++i) {
            if(inPredecessorsControl[i].is_present()) {
                exitsReceived += 1;
            }
        }
        if(exitsReceived == numChannels) {
            outSuccessorControl.set(Message{ExitMsg});
            // reset local state
            data = std::vector<std::map<int,double>>();
            exitsReceived = 0;
        }
    =}
}

reactor CombineReactor {
    
    input inPredecessorCollection: std::vector<double>;
    input inPredecessorControl: Message;
    output outSuccessorValue: double;
    output outSuccessorControl: Message;
    
    reaction(inPredecessorCollection) -> outSuccessorValue {=
        double sum{0};
        const std::vector<double>& result = *inPredecessorCollection.get();
        for(const auto loopValue: result) {
            sum += loopValue;
        }
        outSuccessorValue.set(sum);
    =}
    
    reaction(inPredecessorControl) -> outSuccessorControl {=
        outSuccessorControl.set(inPredecessorControl.get());
        
        // reset local state
    =}
}

reactor SinkReactor(printRate: size_t{100}) {
    
    state count: size_t{0};
    
    output outFinished: void;
    input inPredecessorValue: double;
    input inPredecessorControl: Message;
    
    reaction(inPredecessorValue) {=
        double result = *inPredecessorValue.get();
        
        if(count == 0) {
            reactor::log::Info() << "SinkActor: result = " << result;
        }
        
        count = (count + 1) % printRate;
    =}
    
    reaction(inPredecessorControl) -> outFinished {=
        outFinished.set();
        // reset local state
    =}
}

main reactor (numIterations: size_t{12}, numSimulations: size_t{34816}, numColumns: size_t{16384}, numChannels: size_t{8}) {
    
    producer = new ProducerReactor(numSimulations=numSimulations, numChannels=numChannels, numColumns=numColumns);
    runner = new BenchmarkRunner(numIterations=numIterations, useInit=true);
    sink = new SinkReactor(printRate=100);
    
    runner.outInitializeStart -> producer.inInitializeStart;
    producer.outInitializeFinished -> runner.inInitializeFinish;
    
    runner.outIterationStart -> producer.inStart;
    sink.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart, banks.setF, banks.setH {=
        // initialize the coefficients of all FIR filters
    	auto mH = reactor::make_mutable_value<CoefficientMatrix>(numChannels, std::vector<double>(numColumns, 0.0));
        auto mF = reactor::make_mutable_value<CoefficientMatrix>(numChannels, std::vector<double>(numColumns, 0.0));

        for(size_t j{0}; j < numChannels; ++j) {
            for(size_t i{0}; i < numChannels; ++i) {
                (*mH)[j][i] = (1.0 * i * numChannels) + (1.0 * j * numChannels) + j + i + j + 1;
                (*mF)[j][i] = (1.0 * i * j) + (1.0 * j * j) + j + i;
            }
        }
        
        // convert to immutable pointers before sending. This ensures that all recipients can receive a pointer
        // to the same matrix and no copying is needed
        reactor::ImmutableValuePtr<CoefficientMatrix> H{std::move(mH)};
        reactor::ImmutableValuePtr<CoefficientMatrix> F{std::move(mF)}; 
        
        for (auto& b: banks) {
            b.setH.set(H);
            b.setF.set(F);
        }
        
        printBenchmarkInfo("FilterBankBenchmark");
        printArgs("numIterations", numIterations, "numSimulations", numSimulations, "numColumns", numColumns, "numChannels", numChannels);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    combine = new CombineReactor();
    source = new SourceReactor();
    
    integrator = new IntegratorReactor(numChannels=numChannels);
    branches = new BranchesReactor(numChannels=numChannels, numColumns=numColumns);
    banks = new[8] BankReactor(numColumns=numColumns, numChannels=numChannels);
    
    producer.outSource -> source.inProducer;
    source.outProducer -> producer.inSource;
    source.outSuccessorControl -> branches.inPredecessorControl;
    source.outSuccessorValue -> branches.inPredecessorValue;
    branches.outBanksControl -> banks.inPredecessorControl;
    branches.outBanksValue -> banks.inPredecessorValue;
    banks.outSuccessorControl -> integrator.inPredecessorsControl;
    banks.outSuccessorValue -> integrator.inPredecessorsValue;
    integrator.outSuccessorControl -> combine.inPredecessorControl;
    integrator.outSuccessorCollection -> combine.inPredecessorCollection;
    combine.outSuccessorControl -> sink.inPredecessorControl;
    combine.outSuccessorValue -> sink.inPredecessorValue;
}
