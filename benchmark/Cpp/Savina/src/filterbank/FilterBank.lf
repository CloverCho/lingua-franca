/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */

// This benchmark does not contain the Branches and TaggedForward reactors as they are redundant in LF.
// Their functionality is simply implemented by port connections in LF. 
// Also the integrator reactor became superfluous. In the Akka implementation, its whole purpose is to realign
// messages received from the different banks. Using actors, these messages could arrive in any order and
// we need to synchronize between the channels in order to combine results from each channel into a single vector.
// However, this is not needed in LF where all the outputs from the banks/channels are synchronous.

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "FilterBank.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    #include "FilterBankCommon.hh"
    
    using CoefficientMatrix = std::vector<std::vector<double>>;
=}

reactor ProducerReactor(numChannels: size_t{8}, numSimulations: size_t{34816}, numColumns: size_t{16384}) {
        
    state numMessagesSent: size_t{0};
    
    input start: void;
    output next: void;
    output finished: void
    
    logical action sendNext: void;
    
    reaction(start) -> sendNext {=
        // reset local state
        numMessagesSent = 0;
        
        // start execution
        sendNext.schedule();
    =}
    
    reaction (sendNext) -> sendNext, next, finished {=
        if (numMessagesSent < numSimulations) {
            next.set();
            numMessagesSent++;
            sendNext.schedule();
        } else {
            finished.set();
        }
    =}
}

reactor SourceReactor {
    
    state maxValue: size_t{1000};
    state current: size_t{0};
    
    input next: void;
    output value: double;

    input inFinished: void;
    output outFinished: void;
    
    reaction (next) -> value {=
        value.set(current);
        current = (current + 1) % maxValue;
    =}
    
    reaction (inFinished) -> outFinished {=
        outFinished.set();
        // reset local state
        current = 0;
    =}
}

reactor BankReactor(bank_index: size_t{0}, numColumns: size_t{16384}, numChannels: size_t{8}) {    
    input inValue: double;
    input inFinished: void;
    output outValue: double;
    output outFinished: void;
    
    input setF: CoefficientMatrix;
    input setH: CoefficientMatrix;
    
    delay0 = new DelayReactor(delayLength={=numColumns - 1=});
    fir0 = new FirFilterReactor(bank_index=bank_index, peekLength=numColumns);
    sample = new SampleFilterReactor(sampleRate=numColumns);
    delay1 = new DelayReactor(delayLength={=numColumns - 1=});
    fir1 = new FirFilterReactor(bank_index=bank_index, peekLength=numColumns);
    
    inFinished, delay0.outFinished, fir0.outFinished, sample.outFinished, delay1.outFinished, fir1.outFinished -> 
        delay0.inFinished, fir0.inFinished, sample.inFinished, delay1.inFinished, fir1.inFinished, outFinished;
        
    inValue, delay0.outValue, fir0.outValue, sample.outValue, delay1.outValue, fir1.outValue -> 
        delay0.inValue, fir0.inValue, sample.inValue, delay1.inValue, fir1.inValue, outValue;   
    
    setH -> fir0.setCoefficients;
    setF -> fir1.setCoefficients;
}

reactor DelayReactor(delayLength: size_t{16383}) {
    state myState: std::vector<double>;
    state placeHolder: size_t{0};
    
    input inValue: double;
    input inFinished: void;
    output outValue: double;
    output outFinished: void;
    
    reaction(startup) {=
        // one time init
        myState = std::vector<double>(delayLength, 0.0);
        placeHolder = 0;
    =}
    
    reaction(inValue) -> outValue {=
        double result = *inValue.get();
        outValue.set(myState[placeHolder]);
        myState[placeHolder] = result;
        placeHolder = (placeHolder + 1) % delayLength;
    =}
    
    reaction(inFinished) -> outFinished {=
        outFinished.set();
        
        // reset local state
        myState = std::vector<double>(delayLength, 0.0);
        placeHolder = 0;
    =}
}

reactor FirFilterReactor(bank_index:size_t{0}, peekLength: size_t{16384}) {
    state data: std::vector<double>;
    state dataIndex: size_t{0};
    state dataFull: bool{false};
    state coefficients: {=reactor::ImmutableValuePtr<CoefficientMatrix>=}{{=nullptr=}}
    
    input setCoefficients: CoefficientMatrix
    input inValue: double;
    input inFinished: void;
    output outValue: double;
    output outFinished: void;
    
    reaction(startup) {=
        // reset local state
        data = std::vector<double>(peekLength, 0.0);
        dataIndex = 0;
        dataFull = false;
    =}
    
    reaction (setCoefficients) {=
        coefficients = setCoefficients.get();
    =}
    
    reaction(inValue) -> outValue {=
        data[dataIndex] = *inValue.get();
        dataIndex++;
        
        if(dataIndex == peekLength) {
            dataFull = true;
            dataIndex = 0;
        }
        
        if(dataFull) {
            double sum{0.0};
            for (size_t i{0}; i < peekLength; i++) {
                sum += data[i] * (*coefficients)[bank_index][peekLength - i - 1];
            }
            outValue.set(sum);
        }
    =}
    
    reaction(inFinished) -> outFinished {=
        outFinished.set();
        
        // reset local state
        data = std::vector<double>(peekLength, 0.0);
        dataIndex = 0;
        dataFull = false;
    =}
}

reactor SampleFilterReactor(sampleRate: size_t{16384}) {
    state samplesReceived: size_t{0};
    
    input inValue: double;
    input inFinished: void;
    output outValue: double;
    output outFinished: void;
    
    reaction(inValue) -> outValue {=
        if(samplesReceived == 0) {
            outValue.set(inValue.get());
        } else {
            outValue.set(0.0);
        }
        samplesReceived = (samplesReceived + 1) % sampleRate;
    =}
    
    reaction(inFinished) -> outFinished {=
        outFinished.set();
        
        // reset local state
        samplesReceived = 0;
    =}
}

reactor CombineReactor(numChannels: size_t{8}) {
    
    input[numChannels] inValues: double;
    input[numChannels] inFinished: void;
    output outValue: double;
    output outFinished: void;
    
    state numFinished: size_t{0};
    
    reaction(inValues) -> outValue {=
        double sum{0};
        for(const auto& x: inValues) {
            sum += *x.get();
        }
        outValue.set(sum);
    =}
    
    reaction(inFinished) -> outFinished {=
        for(const auto& port: inFinished) {
            if(port.is_present()) {
                numFinished++;
            }
        }
        if(numFinished == numChannels) {
            outFinished.set();
            // reset local state
            numFinished = 0;
        }
    =}
}

reactor SinkReactor(printRate: size_t{100}) {
    
    state count: size_t{0};
    
    input inValue: double;
    input inFinished: void;
    output outFinished: void;
    
    reaction(inValue) {=
        double result = *inValue.get();
        
        if(count % printRate == 0) {
            reactor::log::Info() << "SinkActor: result = " << result;
        }
        count++;
    =}
    
    reaction(inFinished) -> outFinished {=
        outFinished.set();
        // reset local state
        count = 0;
    =}
}

main reactor (numIterations: size_t{12}, numSimulations: size_t{34816}, numColumns: size_t{16384}, numChannels: size_t{8}) {
    
    reaction(startup) -> runner.inStart, banks.setF, banks.setH {=
        // initialize the coefficients of all FIR filters
    	auto mH = reactor::make_mutable_value<CoefficientMatrix>(numChannels, std::vector<double>(numColumns, 0.0));
        auto mF = reactor::make_mutable_value<CoefficientMatrix>(numChannels, std::vector<double>(numColumns, 0.0));

        for(size_t j{0}; j < numChannels; ++j) {
            for(size_t i{0}; i < numColumns; ++i) {
                (*mH)[j][i] = (1.0 * i * numColumns) + (1.0 * j * numChannels) + j + i + j + 1;
                (*mF)[j][i] = (1.0 * i * j) + (1.0 * j * j) + j + i;
            }
        }
        
        // convert to immutable pointers before sending. This ensures that all recipients can receive a pointer
        // to the same matrix and no copying is needed
        reactor::ImmutableValuePtr<CoefficientMatrix> H{std::move(mH)};
        reactor::ImmutableValuePtr<CoefficientMatrix> F{std::move(mF)}; 
        
        for (auto& b: banks) {
            b.setH.set(H);
            b.setF.set(F);
        }
        
        printBenchmarkInfo("FilterBankBenchmark");
        printArgs("numIterations", numIterations, "numSimulations", numSimulations, "numColumns", numColumns, "numChannels", numChannels);
        printSystemInfo();
        runner.inStart.set();
    =}

    runner = new BenchmarkRunner(numIterations=numIterations);    
    producer = new ProducerReactor(numSimulations=numSimulations, numChannels=numChannels, numColumns=numColumns);
    source = new SourceReactor();
    banks = new[numChannels] BankReactor(numColumns=numColumns, numChannels=numChannels);
    combine = new CombineReactor(numChannels=numChannels);
    sink = new SinkReactor(printRate=100);
    
    runner.outIterationStart -> producer.start;
    
    producer.next -> source.next;
    producer.finished -> source.inFinished;
    
    (source.value)+ -> banks.inValue;
    (source.outFinished)+ -> banks.inFinished;
   
    banks.outValue -> combine.inValues;
    banks.outFinished -> combine.inFinished
  
    combine.outValue -> sink.inValue;
    combine.outFinished -> sink.inFinished;
    
    sink.outFinished -> runner.inIterationFinish;
}
