/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    enum MsgType {
      ResetMsg,
      ComputeMsg,
      ResultMsg,
      NextTermMsg,
      GetTermMsg
    };
    
    struct Message {
    
      MsgType type;
      double term;
    };
=}

reactor RateComputer(bank_index: size_t{0}, startRate: double{3.46}, rateIncrement: double{0.0025}) {
    
    state rate: double;
    
    input inSeriesWorker: Message;
    output outSeriesWorker: Message;
    
    reaction(startup) {=
        rate = startRate + (bank_index * rateIncrement);
    =}
    
    reaction(inSeriesWorker) -> outSeriesWorker {=
        if(inSeriesWorker.get()->type == ComputeMsg) {
            double result = computeNextTerm(inSeriesWorker.get()->term, rate);
            outSeriesWorker.set(Message{ResultMsg, result});
        }
    =}
    
    private preamble {=
        static double computeNextTerm(const double curTerm, const double rate) {
            return rate * curTerm * (1 - curTerm);
        }
    =}
}

reactor SeriesWorker(bank_index: size_t{0}, termIncrement: double{0.0025}) {
    
    state curTerm: std::vector<double>;
    
    input inMaster: Message;
    output outMaster: Message;
    output outRateComputer: Message;
    input inRateComputer: Message;
    
    reaction(inMaster) -> outRateComputer, outMaster {=
        if(inMaster.get()->type == ResetMsg) {
            //reset local state
            curTerm = std::vector<double>{ bank_index * termIncrement };
        } else if(inMaster.get()->type == NextTermMsg) {
            outRateComputer.set(Message{ComputeMsg, curTerm[0]});
        } else if(inMaster.get()->type == GetTermMsg) {
            outMaster.set(Message{ResultMsg, curTerm[0]});
        }
    =}
    
    reaction(inRateComputer) {=
        if(inRateComputer.get()->type == ResultMsg) {
            curTerm[0] = inRateComputer.get()->term;
        }
    =}
}


reactor Master(numSeries: size_t(10), numTerms: size_t(25000)) {
    
    private preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state numWorkRequested: size_t{0};
    state numWorkReceived: size_t{0};
    state termsSum: double{0.0};
    state currentTerm: size_t{0};
    
    input inStart:void;
    output outFinished:void;

    output[numSeries] outSeriesWorkers: Message;
    input[numSeries] inSeriesWorkers: Message;
    
    logical action nextTerms:void;
    
    reaction(inStart) -> nextTerms, outSeriesWorkers {=
        
        //reset local state
        numWorkRequested = 0;
        numWorkReceived = 0;
        termsSum = 0.0;
        currentTerm = 0;
        
        nextTerms.schedule();
        auto msg = reactor::make_immutable_value<Message>(Message{ResetMsg, 0.0});
        for(size_t i{0}; i < outSeriesWorkers.size(); i++) {
            outSeriesWorkers[i].set(msg);
        }
        
    =}
    
    reaction(nextTerms) -> outSeriesWorkers, nextTerms {=
        
        if(currentTerm == numTerms) {
            auto msg = reactor::make_immutable_value<Message>(Message{GetTermMsg, 0.0});
            for(size_t i{0}; i < outSeriesWorkers.size(); ++i) {
                outSeriesWorkers[i].set(msg);
                numWorkRequested += 1;
            }
            return;
        }
        auto msg = reactor::make_immutable_value<Message>(Message{NextTermMsg, 0.0});
        for (size_t i{0}; i < outSeriesWorkers.size(); ++i) {
            outSeriesWorkers[i].set(msg);
        }
        currentTerm += 1;
        nextTerms.schedule();
        
    =}
    
    reaction(inSeriesWorkers) -> outFinished {=
        
        for (size_t i{0}; i < inSeriesWorkers.size(); ++i) {
            if(inSeriesWorkers[i].is_present()) {
                if(inSeriesWorkers[i].get()->type == ResultMsg) {
                    
                    termsSum += inSeriesWorkers[i].get()->term;
                    numWorkReceived += 1;
                    
                    if(numWorkRequested == numWorkReceived) {
                        
                        reactor::log::Info() << "Terms sum: " << termsSum;
                        outFinished.set();
                    }
                }
            }
        }
    =}
}


main reactor (numIterations: size_t{12}, numTerms: size_t{25000}, startRate: double{3.46}, numSeries: size_t{10}) {
    
    master = new Master(numSeries=numSeries, numTerms=numTerms);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("LogisticMapReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numTerms", numTerms, "startRate", startRate, "numSeries", numSeries);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    rateComputers = new[numSeries] RateComputer(startRate=startRate, rateIncrement=0.0025);
    seriesWorkers = new[numSeries] SeriesWorker(termIncrement=0.0025);
    
    master.outSeriesWorkers -> seriesWorkers.inMaster;
    rateComputers.outSeriesWorker -> seriesWorkers.inRateComputer;
    seriesWorkers.outRateComputer -> rateComputers.inSeriesWorker;
    seriesWorkers.outMaster -> master.inSeriesWorkers;
    
}
