/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This version manually connects the reactors.
 * 
 * @author Hannes Klein
 */

/* [[[cog
# This file is a code generator using the python module cog:
# See https://nedbatchelder.com/code/cog/
#
# All instructions for code  generation are in-lined in comments
# like this one. With that you can use this file as a normal source file
# but also to generate code.
# 
# To change the generated code in-line within this file run:
# $ python -m cog -r this-file.lf
# To generate a new file from this file stripping the generator code in the process run:
# $ python -m cog -d -o output-file.lf this-file.lf
#
# Use the command line option -D to specify generator parameters, for example:
# $ python -m cog -r -D parameter=100 this-file.lf
#
# Generator parameters used in this file:
# -D numWorkers=20
]]] */
// [[[end]]]

/* [[[cog
  # force existence, type and default values of generator parameters
  if 'numWorkers' in globals():
    numWorkers = int(numWorkers)
  else:
    globals()['numWorkers'] = 20
  
  # output the current value of the generator parameters used in the last generation run
  cog.outl(f'// Generated file with the following parameters:')
  cog.outl(f'// numWorkers = {numWorkers}')
]]] */
// Generated file with the following parameters:
// numWorkers = 20
// [[[end]]]

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "NQueens.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";
  
public preamble {=
    #include "NQueensCommon.hh"
    #include <bitset>
    #include <list>
=}

reactor Master(numWorkers: size_t{20}, priorities: size_t{10}, solutionsLimit: size_t{1500000}, size: size_t{12}) {
    
    state resultCounter: size_t{0};
    state messageCounter: size_t{0};
    state numWorkersTerminated: size_t{0};
    state numWorkSent: size_t{0};
    state numWorkCompleted: size_t{0};
    /* [[[cog
      cog.outl(f'state workersWorking:{{=std::bitset<{numWorkers}>=}};')
    ]]] */
    state workersWorking: {=std::bitset<20>=};
    // [[[end]]]
    state workList: std::list<WorkMessage>;
    state problemSolved:bool(false);
    
    input inStart:void;
    output outFinished:void;
    input inCleanupIterationStart:void;
    output outCleanupIterationFinished:void;
    
    /* [[[cog
      cog.outl(f'output[{numWorkers}] outWorkersWork:{{=WorkMessage=}};')
      cog.outl(f'input[{numWorkers}] inWorkersWork:{{=std::list<WorkMessage>=}};')
      cog.outl(f'output[{numWorkers}] outWorkers:{{=Message=}};')
      cog.outl(f'input[{numWorkers}] inWorkers:{{=Message=}};')
    ]]] */
    output[20] outWorkersWork: WorkMessage;
    input[20] inWorkersWork: std::list<WorkMessage>;
    output[20] outWorkers: Message;
    input[20] inWorkers: Message;
    // [[[end]]]
    
    logical action sendWork: void;
    logical action shutdownWorkers: void;
    
    reaction(inCleanupIterationStart) -> outCleanupIterationFinished {=
        size_t expSolution{SOLUTIONS[size-1]};
        size_t actSolution{resultCounter};
        bool valid = actSolution >= solutionsLimit && actSolution <= expSolution;
        reactor::log::Info() << std::boolalpha << "Result valid = " << valid << std::noboolalpha;
        reactor::log::Info() << "resultCounter: " << resultCounter;
        reactor::log::Info() << "expSolution: " << expSolution;
        outCleanupIterationFinished.set();
    =}
    
    reaction(inStart) -> sendWork {=
        // reset local state
        resultCounter = 0l;
        messageCounter = 0;
        numWorkersTerminated = 0;
        numWorkSent = 0;
        numWorkCompleted = 0;
        workersWorking.reset();
        workList.clear();
        problemSolved = false;
        
        // start execution
        workList.emplace_back(priorities, std::vector<size_t>(), 0);
        sendWork.schedule();
    =}
    
    reaction(sendWork) -> outWorkersWork, shutdownWorkers {=
        if(problemSolved) 
            return;
        if(workList.empty()) {
            // Assuming that no worker is working in parallel.
            // Shutdown because with no work left,
            // there is no shortest path to be found.
            problemSolved = true;
            shutdownWorkers.schedule();
            return;
        }
        
        while(!workList.empty() && !workersWorking.all()) {
            numWorkSent += 1;
            size_t workerIndex{0};
            while(workersWorking[workerIndex]) ++workerIndex;
            workersWorking[workerIndex] = true;
            outWorkersWork[workerIndex].set(workList.front());
            workList.pop_front();
            reactor::log::Debug() << "Giving work to worker " << workerIndex;
        }
    =}
    
    reaction(shutdownWorkers) -> outWorkers {=
        // Assuming that it is safe to shut down the workers
        auto msg = reactor::make_immutable_value<Message>(Message{StopMsg, 0});
        for(size_t i{0}; i < outWorkers.size(); i++) {
            outWorkers[i].set(msg);
        }
    =}
    
    reaction(inWorkersWork) {=
        for(size_t i{0}; i < inWorkersWork.size(); i++) {
            if(inWorkersWork[i].is_present()) {
                workList.insert( end(workList), begin(*(inWorkersWork[i].get())), end(*(inWorkersWork[i].get())) );
            }
        }
        // Do not schedule work here.
        // Trigger work only after confirmation ReceivedMsg.
        // We assume that ReceivedMsg arrives after this reaction is executed.
    =}
    
    reaction(inWorkers) -> outFinished, sendWork, shutdownWorkers {=
        for(size_t i{0}; i < inWorkers.size(); i++) {
            if(inWorkers[i].is_present()) {
                if(inWorkers[i].get()->type == ResultMsg) {
                    resultCounter += inWorkers[i].get()->numResults;
                    reactor::log::Debug() << "Results found. Total numResults = " << resultCounter;
                    if(resultCounter >= solutionsLimit) {
                        reactor::log::Debug() << " Solutions limit reached. Shutdown." << resultCounter;
                        problemSolved = true;
                        shutdownWorkers.schedule();
                    }
                    // Do not schedule new work here.
                } else if(inWorkers[i].get()->type == DoneMsg) {
                    numWorkCompleted += 1;
                    workersWorking[i] = false;
                    sendWork.schedule();
                } else if(inWorkers[i].get()->type == StopMsg) {
                    // Confirmation that worker shut down.
                    numWorkersTerminated += 1;
                    if(numWorkersTerminated == numWorkers) {
                        outFinished.set();
                    }
                }
            }
        }
    =}
}

reactor Worker(bank_index: size_t{0}, size: size_t{12}, threshold: size_t{4}) {
    
    state workQueue: std::unique_ptr<std::list<WorkMessage>>; // linked list
    
    input inWork: WorkMessage; // work from the master
    output outWork: std::list<WorkMessage>; // work back to the master to distribute
    input inMaster: Message; // control messages from the master
    output outMaster: Message; // control messages to the master
    
    logical action sendResultMsg: size_t;
    logical action sendDoneMsg: void;
    logical action returnWorkToMaster: void; // execution threshold exceeded, return new work
    logical action sendStop: void;
    
    reaction(sendStop) -> outMaster {=
        outMaster.set(Message{StopMsg, 0});
    =}
    
    reaction(sendDoneMsg) -> outMaster {=
        outMaster.set(Message{DoneMsg, 0});
    =}
    
    reaction(sendResultMsg) -> outMaster, sendDoneMsg {=
        outMaster.set(Message{ResultMsg, *sendResultMsg.get()});
        sendDoneMsg.schedule();
    =}
    
    reaction(returnWorkToMaster) -> outWork, sendDoneMsg {=
        outWork.set(*(workQueue.release()));
        sendDoneMsg.schedule();
    =}
    
    reaction(inWork) -> sendResultMsg, returnWorkToMaster {=
        workQueue = std::make_unique<std::list<WorkMessage>>();
        WorkMessage workMessage = *(inWork.get());
        std::vector<size_t> a = workMessage.data;
        size_t depth = inWork.get()->depth;
        
        if(size == depth) {
            //TODO what situation triggers this?
            sendResultMsg.schedule(1);
            return;
        }
        
        if(depth >= threshold) {
            // Search for solutions.
            size_t numSolutions = nqueensKernelSeq(a, depth, size);
            sendResultMsg.schedule(numSolutions);
            return;
        }
            
        // Generate new work
        size_t newPriority = workMessage.priority - 1;
        size_t newDepth = depth + 1;
        size_t i{0};
        while(i < size) {
            std::vector<size_t> b(newDepth, 0);
            b.insert(begin(b), begin(a), begin(a) + depth);
            b[depth] = i;
            
            if(boardValid(newDepth, b)) {
                workQueue->emplace_back(newPriority, b, newDepth);
            }
            i += 1;
        }
        returnWorkToMaster.schedule();
    =}
    
    reaction(inMaster) -> sendStop {=
        if(inMaster.get()->type == StopMsg) {
            sendStop.schedule();
        }
    =}
}

main reactor (numIterations: size_t{12}, size: size_t{12}, threshold: size_t{4}, solutionsLimit: size_t{1500000}, priorities: size_t{10}) {
    
    /* [[[cog
      cog.outl(f'master = new Master(numWorkers={numWorkers}, priorities=priorities, solutionsLimit=solutionsLimit, size=size);')
    ]]] */
    master = new Master(numWorkers=20, priorities=priorities, solutionsLimit=solutionsLimit, size=size);
    // [[[end]]]
    runner = new BenchmarkRunner(numIterations=numIterations, useCleanupIteration=true);
    
    runner.outCleanupIterationStart -> master.inCleanupIterationStart;
    master.outCleanupIterationFinished -> runner.inCleanupIterationFinish;
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        
        // initializations of global variables that are not states in a reactor
        // those variables are global to be used in the helper functions
        /* [[[cog
          cog.outl(f'NUM_WORKERS = {numWorkers};')
        ]]] */
        NUM_WORKERS = 20;
        // [[[end]]]
        SIZE = size;
        THRESHOLD = threshold;
        PRIORITIES = priorities;
        SOLUTIONS_LIMIT = solutionsLimit;
        
        printBenchmarkInfo("NQueensKSolutionsBenchmark");
        /* [[[cog
          cog.outl(f'printArgs("numIterations", numIterations, "size", size, "threshold", threshold, "solutionsLimit", solutionsLimit, "priorities", priorities, "numWorkers", {numWorkers});')
        ]]] */
        printArgs("numIterations", numIterations, "size", size, "threshold", threshold, "solutionsLimit", solutionsLimit, "priorities", priorities, "numWorkers", 20);
        /// [[[end]]]
        printSystemInfo();
        runner.inStart.set();
    =}
    
    /* [[[cog
      cog.outl(f'workers = new[{numWorkers}] Worker(size=size, threshold=threshold);')
    ]]] */
    workers = new[20] Worker(size=size, threshold=threshold);
    // [[[end]]]
    
    master.outWorkers -> workers.inMaster;
    master.outWorkersWork -> workers.inWork;
    workers.outMaster -> master.inWorkers;
    workers.outWork -> master.inWorkersWork;
    
}
