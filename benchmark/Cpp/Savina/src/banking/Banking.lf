/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * Based on the version BankingAkkaManualStashActorBenchmark.scala
 * from the Savina suite.
 * 
 * @author Hannes Klein
 * @author Christian Menard
 */

target Cpp {
    cmake-include: "../IncludeHeaders.cmake",
    build-type : RelWithDebInfo,
    logging : WARN
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    #include <deque>
    #include <reactor-cpp/logging.hh>
        
    struct CreditMessage {
      size_t recipient;
      double amount;  
    };
    
    using MessageQueue = std::deque<CreditMessage>;
=}

reactor Teller(numAccounts:size_t(1000), numBankings:size_t(50000)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
    =}
    
    state randomGen: PseudoRandom;
    state messageQueues: std::vector<MessageQueue>(numAccounts);
    
    input start:void;
    output finished:void;
    
    output[numAccounts] reset: void;
    output[numAccounts] credit: CreditMessage;
    
    logical action next: void;
    
    method generateWork() {=
        for (size_t i{0}; i < numBankings; i++) {
            // src is lower than dest id to ensure there is never a deadlock
            // Note: this comment stems from the original Akka implementation and 
            // is actually not needed in LF, since cycle free programs cannot deadlock
            size_t src_account = randomGen.nextInt((numAccounts / 10) * 8);
            size_t loop_id = randomGen.nextInt(numAccounts - src_account);
            if(loop_id == 0) {
                loop_id += 1;
            }
            size_t dest_account = src_account + loop_id;
            
            double amount = randomGen.nextDouble() * 1000;
            
            reactor::log::Info() << "Send " << amount << " from " << src_account << " to " << dest_account;
            messageQueues[src_account].push_back(CreditMessage{dest_account, amount});
        }
    =}
    
    reaction(start) -> reset, next {=
        reactor::log::Info() << "Teller: Start a new iteration";
        
        // reset local state
        randomGen = PseudoRandom(123456);

        // reset all accounts
        for (auto& r : reset)
        	r.set();

		generateWork();
                
        // start execution
        next.schedule();
    =}
    
    reaction(next) -> next, credit, finished {=
        reactor::log::Info() << "Teller: Sending a new round of credit messages";
        bool work_found{false};
        for (size_t i{0}; i < numAccounts; i++) {
            auto& queue = messageQueues[i];
			if (!queue.empty()) {
                work_found = true;
                const auto& message = queue.front();  
                credit[message.recipient].set(message);
                queue.pop_front();
            }
        }
        
        if (work_found) {
            next.schedule();
        } else {
            reactor::log::Info() << "Teller: Finished iteration";
            finished.set();
        }
	=}
}

reactor Account(bank_index:size_t(0), numAccounts:size_t(1000), initialBalance:double(0.0)) {
    state balance: double{0.0};
    
	input reset: void; 
    input inCredit: CreditMessage;
   
   	input[numAccounts] inDebit: double; 
    output[numAccounts] outDebit: double;
       
    reaction (reset) {=
        balance = initialBalance;
    =}
    
    reaction (inCredit) -> outDebit {=
        auto message = inCredit.get();
        // reduce the balance
        balance -= message->amount;
        // and sent the recipient a debit message
        outDebit[message->recipient].set(message->amount);
        reactor::log::Info() << "Account " << bank_index << " credits " << message->amount 
                             << " to " << message->recipient;
    =}
    
    reaction (inDebit) {=
        for (auto& port : inDebit) {
            if (port.is_present()) {
                double amount = *port.get();
				// increase the balance
        		balance += amount;
        		reactor::log::Info() << "Account " << bank_index << " received " << amount;                
            }
        }
    =}
}

// FIXME default value of numAccounts should be 1000
main reactor (numIterations:size_t(12), numTransactions:size_t(50000), numAccounts:size_t(20)) {
    
    teller = new Teller(numAccounts=numAccounts, numBankings=numTransactions);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> teller.start;
    teller.finished -> runner.inIterationFinish;
    
    accounts = new[numAccounts] Account(numAccounts=numAccounts, initialBalance={=std::numeric_limits<double>::max() / (numAccounts * numTransactions)=});
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("BankingReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numTransactions", numTransactions, "numAccounts", numAccounts, "initialBalance", std::numeric_limits<double>::max() / (numAccounts * numTransactions));
        printSystemInfo();
        runner.inStart.set();
    =}
    
    teller.credit -> accounts.inCredit;
    teller.reset -> accounts.reset;
    accounts.outDebit -x-> accounts.inDebit;
}