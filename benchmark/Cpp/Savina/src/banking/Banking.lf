/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * Based on the version BankingAkkaManualStashActorBenchmark.scala
 * from the Savina suite.
 * 
 * @author Hannes Klein
 * @author Christian Menard
 */

target Cpp {
    cmake-include: "../IncludeHeaders.cmake",
    build-type : RelWithDebInfo
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    enum MsgType {
      StartMsg,
      StopMsg,
      ReplyMsg,
      DebitMsg,
      CreditMsg
    };
    
    struct Message {
      MsgType type;
      double amount;
      int recipient;
    
      Message(MsgType _type, double _amount, int _recipient):
        type(_type), amount(_amount), recipient(_recipient) {}
    
      Message() {}
    
      Message(MsgType _type):
        type(_type) {}
    };
=}

reactor Teller(numAccounts:size_t(1000), numBankings:size_t(50000)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
    =}
    
    state numCompletedBankings:int;
    state randomGen: PseudoRandom;
    state numWorkGenerated:int(0);
    state nextGeneratedWorkMsg:{=reactor::ImmutableValuePtr<Message>=};
    state nextGeneratedWorkSrcAccountId:int;
    
    input inStart:void;
    output outFinished:void;
    
    output[numAccounts] outAccount: Message;
    input[numAccounts] inAccount: Message;
    
    logical action generateWork:void;
    
    reaction(inStart) -> generateWork {=
        // reset local state
        numCompletedBankings = 0;
        randomGen = PseudoRandom(123456);
        numWorkGenerated = 0;
        nextGeneratedWorkMsg = reactor::ImmutableValuePtr<Message>();
        nextGeneratedWorkSrcAccountId = -1;
        
        // start execution
        generateWork.schedule();
    =}
    
    reaction(generateWork) -> generateWork, outAccount {=
        
        if(numWorkGenerated >= numBankings) {
            return;
        }
        
        std::set<int> accountsWorkGeneratedFor;
        
        if(nextGeneratedWorkMsg != nullptr) {
            outAccount[nextGeneratedWorkSrcAccountId].set(nextGeneratedWorkMsg);
            accountsWorkGeneratedFor.insert(nextGeneratedWorkSrcAccountId);
            numWorkGenerated += 1;
        }
        
        // Generate work for accounts until no more work to
        // generate or work is genrated for an account that
        // already has work.
        while(numWorkGenerated < numBankings) {
            // src is lower than dest id to ensure there is never a deadlock
            int srcAccountId = randomGen.nextInt((outAccount.size() / 10) * 8);
            nextGeneratedWorkSrcAccountId = srcAccountId;
            int loopId = randomGen.nextInt(outAccount.size() - srcAccountId);
            if(loopId == 0) {
                loopId += 1;
            }
            int destAccountId = srcAccountId + loopId;
            
            double amount = abs(randomGen.nextDouble()) * 1000;
            
            auto ret = accountsWorkGeneratedFor.insert(srcAccountId);
            nextGeneratedWorkMsg = reactor::make_immutable_value<Message>(CreditMsg, amount, destAccountId);
            if(ret.second) {
                outAccount[srcAccountId].set(nextGeneratedWorkMsg);
                numWorkGenerated += 1;
            } else {
                break;
            }
        }
        
        generateWork.schedule();
    =}
    
    reaction(inAccount) -> outFinished, outAccount {=
        for(int i = 0; i < inAccount.size(); ++i) {
            if(inAccount[i].is_present()) {
                if(inAccount[i].get()->type == ReplyMsg) {
                    
                    numCompletedBankings += 1;
                    if(numCompletedBankings == numBankings) {
                        for(int i = 0; i < outAccount.size(); ++i) {
                            outAccount[i].set(Message{StopMsg});
                        }
                        outFinished.set();
                    }
                }
            }
        }
    =}
}


/** 
 * Intra-reactor-bank communication between Account reactors is prone
 * to deadlocks if two send each other CreditMsg at the same point
 * in logical time. This is prevented in the Teller-reactor that
 * generates DebitMsg according to an ordering.
 */
reactor Account(bank_index:size_t(0), numAccounts:size_t(1000), initialBalance:double(0.0)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
        #include <list>
        #include "reactor-cpp/logging.hh"
    =}
    
    state numCompletedBankings:int(0);
    state randomGen:PseudoRandom(123456);
    state balance:double(initialBalance);
    state stashedMessages:{=std::list<reactor::ImmutableValuePtr<Message>>=};
    state inReplyMode:bool(false);

    input inTeller: Message;
    output outTeller: Message;
    
    output[numAccounts] outAccount: Message;
    input[numAccounts] inAccount: Message;
    
    logical action handleMessage:void;
       
    reaction(handleMessage) -> handleMessage, outTeller, outAccount {=
        if(stashedMessages.empty()) {
            return;
        }
        
        if(inReplyMode) {            
            auto reply = std::find_if(std::begin(stashedMessages), std::end(stashedMessages),
                [](reactor::ImmutableValuePtr<Message>& msg) { return (msg->type == ReplyMsg); }
            );
            if(reply == std::end(stashedMessages)) {
                // reply not received yet
            } else {
                // reply received
                inReplyMode = false;
                stashedMessages.erase(reply);
                outTeller.set(Message{ReplyMsg});
            }
            
        } else { // inReplyMode == false
            
            if(stashedMessages.front()->type == DebitMsg) {
                
                balance += stashedMessages.front()->amount;
                outAccount[stashedMessages.front()->recipient].set(Message{ReplyMsg});
                stashedMessages.pop_front();
                
            } else if(stashedMessages.front()->type == CreditMsg) {
                
                balance -= stashedMessages.front()->amount;
                int destAccount = stashedMessages.front()->recipient;
                outAccount[destAccount].set(Message{DebitMsg, stashedMessages.front()->amount, bank_index});
                inReplyMode = true;
                stashedMessages.pop_front();
                
            } else if(stashedMessages.front()->type == StopMsg) {
                
                stashedMessages.pop_front();
                if(!stashedMessages.empty()) {
                    reactor::log::Info() << "Stop message received, but message queue not empty in account " << bank_index;
                }
                // reset local state
                numCompletedBankings = 0;
                randomGen = PseudoRandom(123456);
                balance = initialBalance;
                stashedMessages = std::list<reactor::ImmutableValuePtr<Message>>();
                inReplyMode = false;
                return; // don't schedule
            }
        }
        
        handleMessage.schedule();
    =}
    
    reaction(inAccount) -> handleMessage {=
        for(int i = 0; i < inAccount.size(); ++i) {
            if(inAccount[i].is_present()) {
                stashedMessages.push_back(inAccount[i].get());
            }
        }
        handleMessage.schedule();
    =}
    
    reaction(inTeller) -> handleMessage {=
        stashedMessages.push_back(inTeller.get());
        handleMessage.schedule();
    =}
}

// FIXME default value of numAccounts should be 1000
main reactor (numIterations:size_t(12), numTransactions:size_t(50000), numAccounts:size_t(20)) {
    
    teller = new Teller(numAccounts=numAccounts, numBankings=numTransactions);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> teller.inStart;
    teller.outFinished -> runner.inIterationFinish;
    
    accounts = new[numAccounts] Account(numAccounts=numAccounts, initialBalance={=std::numeric_limits<double>::max() / (numAccounts * numTransactions)=});
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("BankingReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numTransactions", numTransactions, "numAccounts", numAccounts, "initialBalance", std::numeric_limits<double>::max() / (numAccounts * numTransactions));
        printSystemInfo();
        runner.inStart.set();
    =}
    
    teller.outAccount -> accounts.inTeller;
    accounts.outTeller -> teller.inAccount;
  
  	accounts.outAccount -x-> accounts.inAccount;
}