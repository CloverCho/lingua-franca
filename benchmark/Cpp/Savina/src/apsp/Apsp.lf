/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 * @author Christian Menard
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "../IncludeHeaders.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


public preamble {=
    using MatrixOfLong = std::vector<std::vector<long>>;
    
    struct ApspResultMessage {
      size_t k;
      size_t myBlockId;
      reactor::ImmutableValuePtr<MatrixOfLong> initData;
    };
=}

reactor ApspFloydWarshallBlock(
    bank_index: size_t{0},
    row_index: size_t{0},
    graphSize: size_t{300},
    blockSize: size_t{50},
    dimension: size_t{6},
    verbose: bool{false})
{
    state neighborDataPerIteration: {=std::map<int, reactor::ImmutableValuePtr<MatrixOfLong>>=};
    state numNeighbors: {=const size_t=}{{=2 * (dimension - 1)=}};
    state rowOffset: {=const size_t=}{{=row_index * blockSize=}}; // row offset of the block of this reactor
    state colOffset: {=const size_t=}{{=bank_index * blockSize=}}; // column offset of the block of this reactor
    state currentIterData: {=reactor::ImmutableValuePtr<MatrixOfLong>=}{{=nullptr=}};
    state k: size_t{0}; // iteration counter
    state reportedFinish: bool {false};

    // Extract the data block that is relevant for this instance from the given matrix 
    const method extractDataFromMatrix(
        srcData: {=const reactor::ImmutableValuePtr<MatrixOfLong>&=}
    ): {=reactor::ImmutableValuePtr<MatrixOfLong>=} {=
        auto localData = reactor::make_mutable_value<MatrixOfLong>(std::vector(blockSize, std::vector<long>(blockSize, 0)));
        
        size_t globalStartRow = row_index * blockSize;
        size_t globalStartCol = bank_index * blockSize;
        
        // FIXME memcpy should be much faster here, but on the other hand this is only done during initialization
        for(size_t i = 0; i < blockSize; i++) {
            for(size_t j = 0; j < blockSize; j++) {
                (*localData)[i][j] = (*srcData)[i + globalStartRow][j + globalStartCol];
            }
        }
        return reactor::ImmutableValuePtr<MatrixOfLong>(std::move(localData));
    =}
    
    // retrieve the element at the given position from the known data
    const method elementAt(row: size_t, col: size_t): long {=
        
        size_t destRow = row / blockSize;
        size_t destCol = col / blockSize;
        size_t destBlockId = (destRow * dimension) + destCol;
        
        if (verbose) {
            std::cout << "elementAt(" << col << "," << row << ")\n";
            std::cout << "dest: (" << destCol << ", " << destRow << "), blockId: " << destBlockId << "\n";
        }

        size_t localRow = row % blockSize;
        size_t localCol = col % blockSize;
        
        if(destRow == row_index && destCol == bank_index) {
            return (*currentIterData)[localRow][localCol];
        } else {
            const reactor::ImmutableValuePtr<MatrixOfLong>& blockData = neighborDataPerIteration.at(destBlockId);
            return (*blockData)[localRow][localCol];
        }
	=}

	input matrix: MatrixOfLong;

    input[dimension] fromRow: ApspResultMessage;
    input[dimension] fromCol: ApspResultMessage;

    output toNeighbors: ApspResultMessage;    
    output finished: void;
    
    logical action notifyNeighbors;
    
    reaction(matrix) -> notifyNeighbors {=
        currentIterData = std::move(extractDataFromMatrix(matrix.get()));
        
        // reset local state
        neighborDataPerIteration.clear();
        k = 0;
        reportedFinish = false;
        
        // start execution
        notifyNeighbors.schedule();
    =}
    
    reaction(notifyNeighbors) -> toNeighbors {=
        //notify all neighbors
        auto resultMessage = reactor::make_immutable_value<ApspResultMessage>(
            ApspResultMessage{k, row_index * dimension + bank_index, currentIterData}
        );
        toNeighbors.set(resultMessage);
    =}
    
    reaction(fromRow, fromCol) -> notifyNeighbors, finished {=
        
        // do nothing if complete
        if(k == graphSize) {
            if(doPrint && !printed && bank_index == 0 && row_index == 0) {
                // debugging and result checking
                print(*currentIterData);
                printed = 1;
            }
            return;
        }
        
        // collect all input messages
        bool haveAllData = false;
        for(auto& port : fromRow) {
            if(port.is_present()) {
                haveAllData |= storeIterationData(port.get(), neighborDataPerIteration, dimension);
            }
        }
        for(auto& port : fromCol) {
            if(port.is_present()) {
                haveAllData |= storeIterationData(port.get(), neighborDataPerIteration, dimension);
            }
        }
        
        if(!haveAllData) return;
        
        // perform computation
        reactor::MutableValuePtr<MatrixOfLong> nextIterData =
          reactor::make_mutable_value<MatrixOfLong>(blockSize, std::vector<long>(blockSize, 0));
        
        for(size_t i = 0; i < blockSize; i++) {
            for(size_t j = 0; j < blockSize; j++) {
                int gi = rowOffset + i;
                int gj = colOffset + j;
                
                long newIterData = elementAt(gi, k) + elementAt(k, gj);
                (*nextIterData)[i][j] = std::min((*currentIterData)[i][j], newIterData);
            }
        }
        
        // FIXME This should work without the explicit conversion t
        currentIterData = reactor::ImmutableValuePtr<MatrixOfLong>(std::move(nextIterData));
        neighborDataPerIteration.clear();
        notifyNeighbors.schedule();
        
        k++;
        
        if(k == graphSize) {
            finished.set();
        }
    =}
    
    // FIXME: This should be methods!
    private preamble {=
        
        // invisible local state for debugging
        static int printed = 0;
        static int doPrint = 1;
        
        //helper functions
        
        bool storeIterationData(const reactor::ImmutableValuePtr<ApspResultMessage>& inData,
          std::map<int, reactor::ImmutableValuePtr<MatrixOfLong>>& neighborDataPerIteration,
          size_t numNeighbors) {
          neighborDataPerIteration.insert(
                std::pair<int, reactor::ImmutableValuePtr<MatrixOfLong>>(inData->myBlockId, inData->initData));
            return neighborDataPerIteration.size() == numNeighbors;
        }
        
        void print(const MatrixOfLong& array) {
            for(auto vec: array) {
                for(auto lon: vec) {
                    std::cout << lon << " ";
                }
                std::cout << std::endl;
            }
        }
    =}
}


reactor ApspRow(
    blockSize: size_t{50},
    numNodes: size_t{300},
    dimension: size_t{6},
    verbose: bool{false}) {
        
    input matrix: MatrixOfLong;
    output[dimension] finished: void;

    input[{=dimension*dimension=}] fromCol: ApspResultMessage;
    output[dimension] toCol: ApspResultMessage;
        
    blocks = new[dimension] ApspFloydWarshallBlock(
        blockSize=blockSize,
        graphSize=numNodes,
        dimension=dimension,
        verbose=verbose
    );
    
    // connect all blocks within the row
    (blocks.toNeighbors)+ -> blocks.fromRow;
    
    // block output to all column neighbours
    blocks.toNeighbors -> toCol;
    // block input from all column neighbours
    (fromCol)+ -x-> blocks.fromCol;
    
    // broadcast the incoming matrix to all blocks
    (matrix)+ -> blocks.matrix;
    // collect and forward finished signals from all blocks
    blocks.finished -> finished;
}

reactor ApspMatrix(
    blockSize: size_t{50},
    numNodes: size_t{300},
    dimension: size_t{6},
    verbose: bool{false})
{
	input matrix: MatrixOfLong;
	output[{=dimension*dimension=}] finished: void;
	
	rows = new[dimension] ApspRow(blockSize=blockSize, numNodes=numNodes, dimension=dimension, verbose=verbose);
	
	// broadcast the incoming matrix to all rows
    (matrix)+ -> rows.matrix;
    // collect and forward finished signals from all blocks
    rows.finished -> finished;
    
    (rows.toCol)+ -> rows.fromCol;
}

main reactor (
    numIterations: size_t{12},
    maxEdgeWeight: size_t{100},
    blockSize: size_t{50},
    numNodes: size_t{300},
    verbose: bool{false}) {
	
	state graphData: {=reactor::ImmutableValuePtr<MatrixOfLong>=};
    state numBlocksFinished: size_t{0};
	
	runner = new BenchmarkRunner(numIterations=numIterations, useInit=true, useCleanupIteration=true);
	matrix = new ApspMatrix(
        blockSize=blockSize,
        numNodes=numNodes,
        dimension={=numNodes / blockSize=},
        verbose=verbose
    );
	  
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("ApspBenchmark");
        printArgs("numIterations", numIterations, "maxEdgeWeight", maxEdgeWeight, "numNodes", numNodes, "blockSize", blockSize);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    reaction(runner.outInitializeStart) -> runner.inInitializeFinish {=
        // initialization of graph is not measured
        graphData = reactor::ImmutableValuePtr<MatrixOfLong>(generateGraph(numNodes, maxEdgeWeight));
        runner.inInitializeFinish.set();
    =}
    
    reaction(runner.outCleanupIterationStart) -> runner.inCleanupIterationFinish {=
        //TODO check if result is correct
        
        // initialization of the graph for the next iteration
        graphData = reactor::ImmutableValuePtr<MatrixOfLong>(generateGraph(numNodes, maxEdgeWeight));
        runner.inCleanupIterationFinish.set();
    =}

	// FIXME This should not produce an unused variable warning
    reaction(runner.outIterationStart) -> matrix.matrix {=
        // reset local state
        numBlocksFinished = 0;

        // start execution
        matrix.matrix.set(graphData);
	=}

	reaction (matrix.finished) -> runner.inIterationFinish {=
        for (auto& f : matrix.finished) {
            if (f.is_present()) {
                numBlocksFinished++;
            }
        }
        size_t dimension = numNodes / blockSize;
        if (numBlocksFinished == dimension*dimension) {
            runner.inIterationFinish.set();
        }
    =}

    private preamble {=  
        #include "PseudoRandom.hh"
        
        reactor::MutableValuePtr<MatrixOfLong> generateGraph(int N, int W) {
            PseudoRandom random(N);
            reactor::MutableValuePtr<MatrixOfLong> localData =
                reactor::make_mutable_value<MatrixOfLong>(std::vector(N, std::vector<long>(N, 0)));
            //MatrixOfLong localData(N, std::vector<long>(N, 0));
            
            for(int i = 0; i < N; i++) {
                for(int j = i+1; j < N; j++) {
                    int r = random.nextInt(W)+1;
                    (*localData)[i][j] = r;
                    (*localData)[j][i] = r;
                }
            }
            
            return localData;
        }
    =}
}