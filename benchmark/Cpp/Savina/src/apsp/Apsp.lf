/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This version manually connects the reactors.
 * 
 * @author Hannes Klein
 * @author Christian Menard
 */

/* [[[cog
# This file is a code generator using the python module cog:
# See https://nedbatchelder.com/code/cog/
#
# All instructions for code  generation are in-lined in comments
# like this one. With that you can use this file as a normal source file
# but also to generate code.
# 
# To change the generated code in-line within this file run:
# $ python -m cog -r this-file.lf
# To generate a new file from this file stripping the generator code in the process run:
# $ python -m cog -d -o output-file.lf this-file.lf
#
# Use the command line option -D to specify generator parameters, for example:
# $ python -m cog -r -D parameter=100 this-file.lf
#
# Generator parameters used in this file:
# -D blockSize=50
# -D numNodes=300
# 
]]] */
// [[[end]]]

/* [[[cog
  # force existence, type and default values of generator parameters
  if 'blockSize' in globals():
    blockSize = int(blockSize)
  else:
    globals()['blockSize'] = 50
  
  if 'numNodes' in globals():
    numNodes = int(numNodes)
  else:
    globals()['numNodes'] = 300
  
  if numNodes % blockSize != 0:
    cog.error(f'numNodes={numNodes} must be a multiple of blockSize={blockSize}')
  
  # define the following variables for convenience
  globals()['numBlocksInSingleDim'] = int(numNodes / blockSize);
  
  # output the current value of the generator parameters used in the last generation run
  cog.outl(f'// Generated file with the following parameters:')
  cog.outl(f'// blockSize = {blockSize}')
  cog.outl(f'// numNodes = {numNodes}')
]]] */
// Generated file with the following parameters:
// blockSize = 50
// numNodes = 300
// [[[end]]]

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "../IncludeHeaders.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


public preamble {=
    using MatrixOfLong = std::vector<std::vector<long>>;
    
    struct ApspResultMessage {
      int k;
      int myBlockId;
      reactor::ImmutableValuePtr<MatrixOfLong> initData;
    
      ApspResultMessage() {}
    
      ApspResultMessage(int _k, int _myBlockId, reactor::ImmutableValuePtr<MatrixOfLong> _initData):
        k(_k), myBlockId(_myBlockId), initData(_initData) {}
    };
=}

reactor ApspFloydWarshallBlock(bank_index:size_t{0}, graphSize:size_t{300}, blockSize:size_t{50}) {
    
    // initialized state
    state neighborDataPerIteration:{=std::map<int, reactor::ImmutableValuePtr<MatrixOfLong>>=};
    state numBlocksInSingleDim:int(-1);
    state numNeighbors:int(-1);
    state rowOffset:int(-1); // row offset of the block of this reactor
    state colOffset:int(-1); // column offset of the block of this reactor
    state currentIterData:{=reactor::ImmutableValuePtr<MatrixOfLong>=};
    state k:int(-1); // iteration counter
    state reportedFinish:{=bool=}(false);
    
    state inNeighborsRow:{=std::vector<reactor::Input<ApspResultMessage> *>=};
    state inNeighborsCol:{=std::vector<reactor::Input<ApspResultMessage> *>=};
    
    output outNeighborsBroadcast:{=ApspResultMessage=};
    
    /* [[[cog
      for i in range(numBlocksInSingleDim):
        cog.outl(f'input inNeighborRow{i}:{{=ApspResultMessage=}};')
      for i in range(numBlocksInSingleDim):
        cog.outl(f'input inNeighborCol{i}:{{=ApspResultMessage=}};')
    ]]] */
    input inNeighborRow0:{=ApspResultMessage=};
    input inNeighborRow1:{=ApspResultMessage=};
    input inNeighborRow2:{=ApspResultMessage=};
    input inNeighborRow3:{=ApspResultMessage=};
    input inNeighborRow4:{=ApspResultMessage=};
    input inNeighborRow5:{=ApspResultMessage=};
    input inNeighborCol0:{=ApspResultMessage=};
    input inNeighborCol1:{=ApspResultMessage=};
    input inNeighborCol2:{=ApspResultMessage=};
    input inNeighborCol3:{=ApspResultMessage=};
    input inNeighborCol4:{=ApspResultMessage=};
    input inNeighborCol5:{=ApspResultMessage=};
    // [[[end]]]
    
    input inInitializeMatrix:{=MatrixOfLong=};
    output outFinished:void;
    
    logical action notifyNeighbors;
    
    reaction(startup) {=
        
        // one time initializations
        numBlocksInSingleDim = graphSize / blockSize;
        numNeighbors = 2 * (numBlocksInSingleDim - 1);
        rowOffset = (myBlockId / numBlocksInSingleDim) * blockSize;
        colOffset = (myBlockId % numBlocksInSingleDim) * blockSize;
        
        // init collection of ports
        /* [[[cog
          cog.outl(f'inNeighborsRow = std::vector<reactor::Input<ApspResultMessage> *>({numBlocksInSingleDim});')
          cog.outl(f'inNeighborsCol = std::vector<reactor::Input<ApspResultMessage> *>({numBlocksInSingleDim});')
          for i in range(numBlocksInSingleDim):
            cog.outl(f'inNeighborsRow[{i}] = &inNeighborRow{i};')
            cog.outl(f'inNeighborsCol[{i}] = &inNeighborCol{i};')
        ]]] */
        inNeighborsRow = std::vector<reactor::Input<ApspResultMessage> *>(6);
        inNeighborsCol = std::vector<reactor::Input<ApspResultMessage> *>(6);
        inNeighborsRow[0] = &inNeighborRow0;
        inNeighborsCol[0] = &inNeighborCol0;
        inNeighborsRow[1] = &inNeighborRow1;
        inNeighborsCol[1] = &inNeighborCol1;
        inNeighborsRow[2] = &inNeighborRow2;
        inNeighborsCol[2] = &inNeighborCol2;
        inNeighborsRow[3] = &inNeighborRow3;
        inNeighborsCol[3] = &inNeighborCol3;
        inNeighborsRow[4] = &inNeighborRow4;
        inNeighborsCol[4] = &inNeighborCol4;
        inNeighborsRow[5] = &inNeighborRow5;
        inNeighborsCol[5] = &inNeighborCol5;
        // [[[end]]]
    =}
    
    reaction(inInitializeMatrix) -> notifyNeighbors {=
        
        currentIterData = reactor::ImmutableValuePtr<MatrixOfLong>(getBlock(inInitializeMatrix.get(), myBlockId, graphSize, blockSize));
        
        // reset local state
        neighborDataPerIteration.clear();
        k = -1;
        reportedFinish =false;
        
        // start execution
        notifyNeighbors.schedule();
    =}
    
    reaction(notifyNeighbors) -> outNeighborsBroadcast {=
        
        //notify all neighbors
        reactor::ImmutableValuePtr<ApspResultMessage> resultMessage =
          reactor::make_immutable_value<ApspResultMessage>(k, myBlockId, currentIterData);
        outNeighborsBroadcast.set(resultMessage);
    =}
    
    reaction(
        /* [[[cog
          for i in range(numBlocksInSingleDim):
            cog.outl(f'inNeighborRow{i},')
            cog.out(f'inNeighborCol{i}')
            if(i < numBlocksInSingleDim-1):
              cog.outl(',')
            else:
              cog.outl('')
        ]]] */
        inNeighborRow0,
        inNeighborCol0,
        inNeighborRow1,
        inNeighborCol1,
        inNeighborRow2,
        inNeighborCol2,
        inNeighborRow3,
        inNeighborCol3,
        inNeighborRow4,
        inNeighborCol4,
        inNeighborRow5,
        inNeighborCol5
        // [[[end]]]
      ) -> notifyNeighbors, outFinished {=
        
        // do nothing if complete
        if(k == graphSize - 1) {
            if(doPrint && !printed && myBlockId == 0) {
                // debugging and result checking
                // print(*currentIterData);
                printed = 1;
            }
            return;
        }
        
        // collect all input messages
        bool haveAllData = false;
        for(int i = 0; i < inNeighborsRow.size(); ++i) {
            if(inNeighborsRow[i]->is_present()) {
                haveAllData |= storeIterationData(inNeighborsRow[i]->get(), neighborDataPerIteration, numNeighbors);
            }
        }
        for(int i = 0; i < inNeighborsCol.size(); ++i) {
            if(inNeighborsCol[i]->is_present()) {
                haveAllData |= storeIterationData(inNeighborsCol[i]->get(), neighborDataPerIteration, numNeighbors);
            }
        }
        
        if(!haveAllData) return;
        
        k += 1;
        
        // perform computation
        reactor::MutableValuePtr<MatrixOfLong> nextIterData =
          reactor::make_mutable_value<MatrixOfLong>(blockSize, std::vector<long>(blockSize, 0));
        
        for(int i = 0; i < blockSize; i++) {
            for(int j = 0; j < blockSize; j++) {
                int gi = rowOffset + i;
                int gj = colOffset + j;
                
                long newIterData =
                    elementAt(gi, k, k - 1, currentIterData,
                        blockSize, numBlocksInSingleDim, myBlockId, neighborDataPerIteration) +
                    elementAt(k, gj, k - 1, currentIterData,
                        blockSize, numBlocksInSingleDim, myBlockId, neighborDataPerIteration);
                (*nextIterData)[i][j] = std::min((*currentIterData)[i][j], newIterData);
            }
        }
        
        currentIterData = reactor::ImmutableValuePtr(std::move(nextIterData));
        neighborDataPerIteration.clear();
        notifyNeighbors.schedule();
        
        if(k == graphSize - 1) {
            outFinished.set();
        }
    =}
    
    private preamble {=
        
        // invisible local state for debugging
        static int printed = 0;
        static int doPrint = 1;
        
        //helper functions
        
        reactor::MutableValuePtr<MatrixOfLong> getBlock(
            const reactor::ImmutableValuePtr<MatrixOfLong>& srcData, int myBlockId, int N, int B) {
            
            reactor::MutableValuePtr<MatrixOfLong> localData =
                reactor::make_mutable_value<MatrixOfLong>(std::vector(B, std::vector<long>(B, 0)));
            
            int numBlocksPerDim = N/B;
            int globalStartRow = (myBlockId / numBlocksPerDim) * B;
            int globalStartCol = (myBlockId % numBlocksPerDim) * B;
            
            for(int i = 0; i < B; i++) {
                for(int j = 0; j < B; j++) {
                    (*localData)[i][j] = (*srcData)[i + globalStartRow][j + globalStartCol];
                }
            }
            return localData;
        }
        
        bool storeIterationData(const reactor::ImmutableValuePtr<ApspResultMessage>& inData,
          std::map<int, reactor::ImmutableValuePtr<MatrixOfLong>>& neighborDataPerIteration,
          int numNeighbors) {
          neighborDataPerIteration.insert(
                std::pair<int, reactor::ImmutableValuePtr<MatrixOfLong>>(inData->myBlockId, inData->initData));
            return neighborDataPerIteration.size() == numNeighbors;
        }
        
        long elementAt(int row, int col, int srcIter, const reactor::ImmutableValuePtr<MatrixOfLong>& prevIterData,
            int blockSize, int numBlocksInSingleDim, int myBlockId,
            std::map<int, reactor::ImmutableValuePtr<MatrixOfLong>>& neighborDataPerIteration) {
            
            int destBlockId = ((row / blockSize) * numBlocksInSingleDim) + (col / blockSize);
            int localRow = row % blockSize;
            int localCol = col % blockSize;
            
            if(destBlockId == myBlockId) {
                return (*prevIterData)[localRow][localCol];
            } else {
                reactor::ImmutableValuePtr<MatrixOfLong>& blockData = neighborDataPerIteration.at(destBlockId);
                return (*blockData)[localRow][localCol];
            }
        }
        
        void print(const MatrixOfLong& array) {
            for(auto vec: array) {
                for(auto lon: vec) {
                    std::cout << lon << " ";
                }
                std::cout << std::endl;
            }
        }
    =}
}


reactor ApspRow(
    blockSize: size_t{50},
    numNodes: size_t{300},
    dimension: size_t{{=numNodes / blockSize=}}) {
        
    blocks = new[dimension] ApspFloydWarshallBlock(blockSize=blockSize, graphSize=numNodes);
}


reactor ApspMatrix(
    blockSize: size_t{50},
    numNodes: size_t{300},
    dimension: size_t(6)) {

	input matrix: MatrixOfLong;
	output finished: void;
	
	rows = new[dimension] ApspRow(blockSize=blockSize, numNodes=numNodes, dimension=dimension);
}


main reactor (
    numIterations: size_t{12},
    maxEdgeWeight: size_t{100},
    blockSize: size_t{50},
    numNodes: size_t{300},
    dimension: size_t{6}) {
    // FIXME dimension: size_t{{=numNodes / blockSize=}}) {
	
	state graphData: {=reactor::ImmutableValuePtr<MatrixOfLong>=};
    state numBlocksFinished: int{0};
	
	runner = new BenchmarkRunner(numIterations=numIterations, useInit=true, useCleanupIteration=true);
	matrix = new ApspMatrix(blockSize=blockSize, numNodes=numNodes, dimension=dimension);
    
    reaction(runner.outInitializeStart) -> runner.inInitializeFinish {=
        // initialization of graph is not measured
        graphData = reactor::ImmutableValuePtr<MatrixOfLong>(generateGraph(graphSize, maxEdgeWeight));
        inInitializeFinish.set();
    =}
    
    reaction(runner.outCleanupIterationStart) -> runner.inCleanupIterationFinish {=
        //TODO check if result is correct
        
        // initialization of the graph for the next iteration
        graphData = reactor::ImmutableValuePtr<MatrixOfLong>(generateGraph(graphSize, maxEdgeWeight));
        runner.inCleanupIterationFinished.set();
    =}

    reaction(runner.outIterationStart) -> matrix.matrix {=
        // reset local state
        numBlocksFinished = 0;

        // start execution
        matrix.matrix.set(graphData);
	=}

	matrix.finished -> runner.inIterationFinish;
    
    private preamble {=  
        #include "PseudoRandom.hh"
        
        reactor::MutableValuePtr<MatrixOfLong> generateGraph(int N, int W) {
            PseudoRandom random(N);
            reactor::MutableValuePtr<MatrixOfLong> localData =
                reactor::make_mutable_value<MatrixOfLong>(std::vector(N, std::vector<long>(N, 0)));
            //MatrixOfLong localData(N, std::vector<long>(N, 0));
            
            for(int i = 0; i < N; i++) {
                for(int j = i+1; j < N; j++) {
                    int r = random.nextInt(W)+1;
                    (*localData)[i][j] = r;
                    (*localData)[j][i] = r;
                }
            }
            
            return localData;
        }
    =}
}