/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This implementation is close to the Savina Akka implementation
 * in terms of the work that is done in each actor/reactor and
 * that for each message sent in Savina there is a message send
 * in this implementation. But this implementation does not
 * show the basic idea of the problem in that the waiting
 * room is basically never because the customers arrival is
 * in sync with the barber cutting the hair of customers.
 * 
 * There are some interesting different possibilities to implement the
 * benchmark more based on the original idea behind it instead
 * of the Savina implementation. For example by using threads that
 * trigger events in physical time and handling missed
 * deadlines if the waiting room is full. But these would lack
 * comparability with the Savina benchmark even more.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "SleepingBarber.cmake",
    keepalive: true,
    logging: "warn"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    #include <deque>
    
    #include "PseudoRandom.hh"
    #include "reactor-cpp/logging.hh"
    
    // function used for busy waiting in the benchmark
    size_t busyWait(size_t limit);
=}

private preamble {=
    size_t busyWait(size_t limit) {
        size_t test{0};
        for(size_t k{0}; k < limit; k++) {
            rand();
            test++;
        }
        return test;
    }
=}

reactor CustomerFactory(numCustomers:size_t(2000), averageProductionRate:size_t(1000)) {
    input start: void;
    output finished: void;
    
    output sendCustomer: size_t;
    input[numCustomers] customerDone: void;
    input[numCustomers] customerReturned: void;

    physical action createCustomer: size_t;
    physical action sendCustomerAgain: size_t
    
    state thread: std::thread;
    state doneCustomers: size_t{0};
    state attempts: size_t{0};

    method generateCustomers(createCustomer: {=reactor::PhysicalAction<size_t>&=}) {=
        PseudoRandom random{};
        for(size_t i{0}; i < numCustomers; i++) {
            createCustomer.schedule(i);
            busyWait(random.nextInt(averageProductionRate) + 10);
        }
    =}
    
    reaction(start) -> createCustomer {=
        // reset state
        doneCustomers = 0;
        attempts = 0;
        // start "creating" customers
        thread = std::thread([this, &createCustomer]() { generateCustomers(createCustomer); });
    =}
    
    reaction (createCustomer) -> sendCustomer {=
        size_t customer_id = *createCustomer.get();
        reactor::log::Info() << "Factory: Send customer " << customer_id << " to the waiting room";
        attempts++;
        sendCustomer.set(customer_id);
    =}
    
    reaction (sendCustomerAgain) -> sendCustomer {=
        size_t customer_id = *sendCustomerAgain.get();
        reactor::log::Info() << "Factory: Send customer " << customer_id << " again to the waiting room";
        attempts++;
        sendCustomer.set(customer_id);
    =}
    
    reaction (customerReturned) -> sendCustomerAgain {=
        for (size_t i{0}; i < numCustomers; i++) {
            if (customerReturned[i].is_present()) {
                // the customer returned because the waiting room is full
                // We send the customer again "immediately".
                // Due to the use of a physical action, this implements a small delay
                sendCustomerAgain.schedule(i);                
            }
        }
    =}
    
    reaction (customerDone) -> finished {=
        for (size_t i{0}; i < numCustomers; i++) {
            if (customerDone[i].is_present()) {
                doneCustomers++;
        	    if (doneCustomers == numCustomers) {
                    std::cout << "Hair cuts given: " << doneCustomers << "; Total attempts: " << attempts << "\n";
                    finished.set();
                    thread.join();
                }
        	}
        }
    =}
}

reactor WaitingRoom(capacity:size_t(1000), numCustomers:size_t(2000)) {
    input reset: void;
    
    input receiveCustomer: size_t;
    
    output[numCustomers] full: void;
    output[numCustomers] wait: void;
    
    input barberNext: void;
    output barberEnter: size_t;
    output barberWait: void;
    
    state queue: std::deque<size_t>{};
    state barberAsleep: bool{true};
    
    reaction(reset) {=
        barberAsleep = true;
    =}
    
    reaction (receiveCustomer) -> full, wait, barberEnter {=
         size_t customer_id = *receiveCustomer.get();
         reactor::log::Info() << "Room: Customer " << customer_id << " tries to enter";
         
         if (queue.size() == capacity) {
             full[customer_id].set();
         } else {
            if (barberAsleep) {
                barberAsleep = false;
                barberEnter.set(customer_id);
            } else {
                queue.push_back(customer_id);
                wait[customer_id].set();	
           	}
        }
    =}
    
    reaction (barberNext) -> barberEnter, barberWait {=
        if (queue.empty()) {
            barberAsleep = true;
            barberWait.set();
        } else {
            barberEnter.set(queue.front());
            queue.pop_front();
        }
    =}
}

reactor Customer(bank_index:size_t(0)) {
    input roomFull: void;
    input wait: void;
    input startCutting: void;
    input doneCutting: void; 

    output returned: void;
    output done: void;
    
    reaction (roomFull) -> returned {=
        reactor::log::Info() << "Customer " << bank_index << ": The waiting room is full. I am leaving.";
        returned.set();
    =}
    
    reaction (wait) {=
        reactor::log::Info() << "Customer " << bank_index << ": I will wait.";
    =}
    
    reaction (startCutting) {= 
        reactor::log::Info() << "Customer " << bank_index << ": I am now being served.";
    =}
    
    reaction (doneCutting) -> done {=
    	reactor::log::Info() << "Customer " << bank_index << ": I have been served.";
    	done.set();
	=}
}

reactor Barber(averageHaircutRate:size_t(1000), numCustomers:size_t(2000)) {
    input reset: void;
    input enter: size_t;
    input wait: void;
        
    output[numCustomers] startCutting: void;
    output[numCustomers] doneCutting: void;
    output next: void;
    
    physical action doCutting: size_t;
    
    state random: PseudoRandom;
    
    reaction (reset) {=
        random = PseudoRandom();
    =}
      
    reaction (doCutting) -> doneCutting, next{=
        size_t customer_id = *doCutting.get();
        reactor::log::Info() << "Barber: Processing customer " << customer_id;
        busyWait(random.nextInt(averageHaircutRate) + 10);
        doneCutting[customer_id].set();
        next.set();
    =}
    
    reaction (enter) -> startCutting, doCutting {=
        size_t customer_id = *enter.get();
        startCutting[customer_id].set();
        doCutting.schedule(customer_id);
    =}
    
    reaction (wait) {=
        reactor::log::Info() << "Barber: No customers. Going to sleep.";
    =}
}

main reactor (numIterations:size_t(12), waitingRoomSize:size_t(1000), averageProductionRate:size_t(1000), averageHaircutRate:size_t(1000), numHaircuts:size_t(2000)) {
    
    runner = new BenchmarkRunner(numIterations=numIterations);
    factory = new CustomerFactory(numCustomers=numHaircuts, averageProductionRate=averageProductionRate);
    room = new WaitingRoom(capacity=waitingRoomSize, numCustomers=numHaircuts);
    barber = new Barber(averageHaircutRate=averageHaircutRate, numCustomers=numHaircuts)
    customers = new[numHaircuts] Customer();
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("SleepingBarberReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "waitingRoomSize", waitingRoomSize, "averageProductionRate", averageProductionRate, "averageHaircutRate", averageHaircutRate, "numHaircuts", numHaircuts);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    (runner.outIterationStart)+ -> factory.start, barber.reset, room.reset;
    factory.finished -> runner.inIterationFinish;
    
    factory.sendCustomer -> room.receiveCustomer;
    room.full -> customers.roomFull;
    room.wait -> customers.wait;
    room.barberEnter -> barber.enter;
    room.barberWait -> barber.wait;
    barber.next -> room.barberNext;
    barber.startCutting -> customers.startCutting;
    barber.doneCutting -> customers.doneCutting;
    customers.done -> factory.customerDone;
    
    customers.returned -> factory.customerReturned;
}