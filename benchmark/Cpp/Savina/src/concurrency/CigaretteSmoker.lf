/*
 * Copyright (C) 2020 TU Dresden
 * 
 * This benchmark "solves" the Cigarette Smoker Problem similarly to the
 * original Savina implementation in Akka. However, it is important to note
 * first, that the Savina implementation does not actually model the resources
 * (paper, matches, tobacco) and thus does not provide a complete solution. It
 * only uses a pattern similar to a common solution of the Cigaratte Smokers
 * Problem. This solution uses an arbitrator that tells the smokers when they
 * can grab the resources and smoke. Since no resources are modelled in Savina,
 * the arbitrator actually just randomly selects a smoker and tells it to smoke.
 *
 * The process of smoking is implemented in the Savina suite by calling Java
 * `Math.random()` a few times in a loop. Converting this "workload" to another
 * language is non-trivial, as likely no similar function with the precise same
 * implementation exists. For the C++ port here, we use `rand()` from stdlib.
 * This is a significant restriction of this benchmark and limits the
 * comparability of results obtained from Akka and from LF C++.
 *
 * Since actors operate asynchronously, several smokers can actually smoke in
 * parallel. In theory, this allows for a fast execution, as the workload of
 * each smoker can be processed in parallel by many smokers. Achieving this in
 * LF, however, is non-trivial. In LF, all the communication is synchronous and
 * instantaneous. When the arbitrator tells a smoker to smoke, the smoker will
 * start smoking at the same tag and the execution will wait until this smoker
 * finished. Only then the runtime will forward logical time to the next tag and
 * the arbitrator will tell the next smoker to smoke. Obviously, there is no
 * parallelism in this solution.
 *
 * In an alternative solution (this was actually implemented earlier), each
 * smoker could have an additional thread and use this thread to process the
 * workload asynchronously. This requires explicit synchronization mechanisms and
 * getting the interaction between arbitrator, smoker and worker thread right
 * seems to be hard. However, apparently the workload is processed very rapidly
 * (it produces at most 1000 random numbers). Thus, the synchronisation overhead
 * required when using an additional worker thread outweighs the benefit of
 * parallel execution. The synchronous implementation where only one smoker
 * smokes at a time proved to be significantly faster. Still, finding a simple
 * and efficient solution that processes the smoker workload asynchronously would
 * be an interesting problem
 *
 * @author Christian Menard 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include : "../IncludeHeaders.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor ArbiterReactor(numRounds:size_t(1000), numSmokers:size_t(200)) {
    
    public preamble {=
        #include "PseudoRandom.hh"
        #include "reactor-cpp/logging.hh"
    =}
    
    state roundsSoFar: size_t(0);
    state random: PseudoRandom;
    
    input inStart:void;
    output outFinished:void;

    output[numSmokers] startSmoking: size_t;
    
    logical action chooseSmoker:void;
    logical action stop:void;
    
    reaction(inStart) -> chooseSmoker {=
        // reset local state
        roundsSoFar = 0;
        random = PseudoRandom(numRounds * numSmokers);
        
        // start excution
        chooseSmoker.schedule();
    =}
    
    reaction(chooseSmoker) -> startSmoking, chooseSmoker, stop {=
        // assume resources grabbed instantaneously and choose a random smoker to start smoking
        int newSmokerIndex = abs(random.nextInt()) % numSmokers;
        int busyWaitPeriod = random.nextInt(1000) + 10;
        startSmoking[newSmokerIndex].set(busyWaitPeriod);
        
        // no need to wait for feedback from the smoker, as it starts smoking (logically) instantaneously
        // We can immediately schedule the next round
        
        roundsSoFar++;
        reactor::log::Debug() << "roundsSoFar=" << roundsSoFar;
        if (roundsSoFar >= numRounds) {
            stop.schedule();
        } else {
            // trigger the next round
            chooseSmoker.schedule();
        }
    =}
    
    reaction(stop) -> outFinished {=
        outFinished.set();
    =}
}

reactor SmokerReactor {
     
    input startSmoking: size_t;
    
    reaction(startSmoking){=
        size_t limit = *(startSmoking.get());
        busyWait(limit);
    =}
    
    method busyWait(limit:size_t): size_t {=
        size_t test = 0;
            
        for(size_t k = 0; k < limit; k++) {
             // Math.random() is used as workload in the original savina benchmark suite
             // FIXME: What is equivalent in Cpp complexity-wise? maybe rand()??
            rand();
            test++;
        }
        return test;
    =}
}

main reactor (numIterations:size_t(12), numRounds:size_t(1000), numSmokers:size_t(200)) {
    
    arbiter = new ArbiterReactor(numRounds=numRounds, numSmokers=numSmokers);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.start -> arbiter.inStart;
    arbiter.outFinished -> runner.finished;
    
    reaction(startup) {=
        // based on the Savina implementation:
        srand(time(NULL));
        
        printBenchmarkInfo("CigaretteSmokerReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numRounds", numRounds, "numSmokers", numSmokers);
        printSystemInfo();
    =}
    
    smokers = new[numSmokers] SmokerReactor();
    
    arbiter.startSmoking -> smokers.startSmoking;
}
