/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "GuidedSearch.cmake",
    logging: "warn"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

public preamble {=
    #include "GuidedSearchCommon.hh"
    #include <deque>
    #include <list>
=}

reactor Master(numWorkers: size_t{20}, gridSize: size_t{30}, priorities: size_t{30}) {

    state grid: Grid(gridSize, priorities);
    state nodesToVisit: std::deque<GridNode*>;
    state pathWasFound: bool{false};
    
    input start: void;
    output finished: void;
    
    output[numWorkers] search: WorkMessage;
    input[numWorkers] pathFound: void;
    input[numWorkers] moreNodesToVisit: std::deque<GridNode*>;
    
    logical action next;
    
    reaction (start) -> next {=
        grid.initializeData(); // reset the grid
        nodesToVisit.clear();
        pathWasFound = false;
        
        // start execution, first visit the origin node
        nodesToVisit.push_back(grid.originNode());
        next.schedule();
    =}
    
    reaction (next) -> next, search {=
        // abort if path was found
        if (pathWasFound) {
            return;
        }

        // send nodes from the internal queue to all workers
        size_t workerIndex{0};        
        while(!nodesToVisit.empty() && workerIndex < numWorkers) {
            GridNode* startNode = nodesToVisit.front();
            nodesToVisit.pop_front();
            search[workerIndex].set(WorkMessage{startNode, grid.targetNode()});
            workerIndex++;
        }
        
         // continue with the next iteration
         next.schedule();
    =}
    
    reaction(pathFound) -> finished {=
        pathWasFound = true;
        bool valid = grid.validate();
        reactor::log::Info() << "Found a path through the grid";
        reactor::log::Info() << std::boolalpha << "Result valid: " << valid << std::noboolalpha;
        finished.set();
    =}
    
    reaction (moreNodesToVisit) {=
        // collect more nodes to visit from all workers and store them in the internal queue
        for (auto& port : moreNodesToVisit) {
            if (port.is_present()) {
                const auto& nodes = *port.get();
                if (!nodes.empty()) {
                	nodesToVisit.insert(nodesToVisit.end(), nodes.begin(), nodes.end());
               	}
            }
        }
    =}
}

reactor Worker(bank_index: size_t{0}, threshold: size_t{1024}) {
    
    input search: WorkMessage;
    output pathFound: void;
    output moreNodesToVisit: std::deque<GridNode*>;
    
    reaction(search) -> pathFound, moreNodesToVisit {=
        auto workMessage = search.get();
        GridNode* targetNode = workMessage->target;
        GridNode* currentNode = workMessage->node;

        reactor::log::Info() << "Worker " << bank_index << ": search path from "
                             << *currentNode << " to " << *targetNode;

        auto workQueue = reactor::make_mutable_value<std::deque<GridNode*>>();
        
        workQueue->push_back(currentNode);
        
        // start the search, but visit at most threshold nodes
        size_t nodesProcessed{0};
        while(!workQueue->empty() && nodesProcessed < threshold) {
            
            nodesProcessed++;
            busyWait();
            
            GridNode* loopNode = workQueue->front();
            workQueue->pop_front();
            size_t numNeighbors = loopNode->numNeighbors();
            
            for (size_t i{0}; i < numNeighbors; i++) {
                GridNode* loopNeighbor = loopNode->neighbor(i);
                bool success = loopNeighbor->setParent(loopNode);
                if(success) {
                    if(loopNeighbor == targetNode) {
                        pathFound.set();
                        return;
                    } else {
                        workQueue->push_back(loopNeighbor);
                    }
                }
            }
        }
        
        if(!workQueue->empty()) {
            moreNodesToVisit.set(std::move(workQueue));
        } 
        // Otherwise (if the queue is empty) we have hit a dead end
    =}

    method busyWait() {=
	    for (int i = 0; i < 100; i++) {
		    rand();
	    }
    =}
}


main reactor (numIterations: size_t{12}, threshold: size_t{1024}, gridSize: size_t{30}, priorities: size_t{30}, numWorkers: size_t{20}) {
    
    master = new Master(numWorkers=numWorkers, gridSize=gridSize, priorities=priorities);
    runner = new BenchmarkRunner(numIterations=numIterations);
    workers = new[numWorkers] Worker(threshold=threshold);
    
    reaction(startup) -> runner.inStart {=       
        printBenchmarkInfo("GuidedSearchBenchmark");
        printArgs("numIterations", numIterations, "threshold", threshold, "gridSize", gridSize, "priorities", priorities, "numWorkers", numWorkers);
        printSystemInfo();
        runner.inStart.set();
    =}

    runner.outIterationStart -> master.start;
    master.finished -> runner.inIterationFinish;
    
    master.search -> workers.search;
    workers.pathFound -> master.pathFound;
    workers.moreNodesToVisit -> master.moreNodesToVisit;
}