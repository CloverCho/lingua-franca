/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */

target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "GuidedSearch.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor Master(numWorkers: size_t{20}, gridSize: size_t{30}) {
    
    public preamble {=
        #include <list>
        #include "GuidedSearchCommon.hh"
        #include "GridNode.hh"
    =}
    
    state numWorkSent: size_t{0};
    state numWorkCompleted: size_t{0};
    state workersWorking: std::vector<bool>(numWorkers, false);
    state workList: std::list<WorkMessage>;
    state shortestPathIsFound:bool(false);
    
    input inStart:void;
    output outFinished:void;
    input inInitializeStart:void;
    output outInitializeFinished:void;
    input inCleanupIteration:void;
    output outCleanupIterationFinished:void;
    
    output[numWorkers] outWorkersWork: WorkMessage;
    input[numWorkers] inWorkersWork: std::list<WorkMessage>;
    output[numWorkers] outWorkers: Message;
    input[numWorkers] inWorkers: Message;
    
    logical action sendWork:void;
    
    reaction(inInitializeStart) -> outInitializeFinished {=
        initializeData();
        outInitializeFinished.set();
    =}
    
    reaction(inCleanupIteration) -> outCleanupIterationFinished {=
        bool valid = validate();
        reactor::log::Info() << std::boolalpha << "Result valid: " << valid << std::noboolalpha;
        initializeData(); // reset graph for next iteration
        outCleanupIterationFinished.set();
    =}
    
    reaction(inStart) -> sendWork {=
        // reset local state
        numWorkSent = 0;
        numWorkCompleted = 0;
        srand(100); // arbitrary seed
        workersWorking.clear();
        workersWorking.resize(numWorkers, false);
        workList = std::list<WorkMessage>();
        shortestPathIsFound = false;
        
        // start execution
        workList.emplace_back(originNode(), targetNode());
        sendWork.schedule();
    =}
    
    reaction(sendWork) -> outWorkersWork, outFinished {=
        if(shortestPathIsFound) return;
        if(workList.empty()) {
            // Shutdown because with no work left, there is no shortest path to be found.
            outFinished.set();
            return;
        }

        size_t workerIndex{0};        
        while(!workList.empty()) {
            numWorkSent += 1;

            while(workersWorking[workerIndex]) ++workerIndex;
            if (workerIndex < numWorkers) {
            	workersWorking[workerIndex] = true;
            	outWorkersWork[workerIndex].set(workList.front());
            	workList.pop_front();
            } else {
                break;
            }
        }
    =}
    
    reaction(inWorkersWork) {=
        for(size_t i{0}; i < inWorkersWork.size(); i++) {
            if(inWorkersWork[i].is_present()) {
                workList.insert(end(workList), begin(*(inWorkersWork[i].get())), end(*(inWorkersWork[i].get())) );
            }
        }
        // Do not schedule work here.
        // Trigger work only after confirmation ReceivedMsg.
        // We assume that ReceivedMsg arrives after this reaction is executed.
    =}
    
    reaction(inWorkers) -> outFinished, sendWork {=
        for(size_t i{0}; i < inWorkers.size(); i++) {
            if(inWorkers[i].is_present()) {
                if(inWorkers[i].get()->type == ReceivedMsg) {
                    numWorkCompleted += 1;
                    workersWorking[i] = false;
//                    if(numWorkCompleted == numWorkSent) {
//                        //stop because no path found
//                        int j = 0;
//                        auto msg = reactor::make_immutable_value<Message>(Message{StopMsg});
//                        while(j < numWorkers) {
//                            outWorkers[j].set(msg);
//                            j += 1;
//                        }
//                    } else {
                        sendWork.schedule();
//                    }
                    
                } else if(inWorkers[i].get()->type == DoneMsg) {
                    shortestPathIsFound = true;
                    outFinished.set();
                }
            }
        }
    =}
}


reactor Worker(bank_index: size_t{0}, priorities: size_t{30}) {
    
    public preamble {=
        #include <list>
        #include "GridNode.hh"
        #include "GuidedSearchCommon.hh"
    =}
    
    state workQueue: std::unique_ptr<std::list<GridNode*>>; // linked list
    state targetNode: GridNode*;
    
    input inWork: WorkMessage; // work from the master
    output outWork: std::list<WorkMessage>; // work back to the master to distribute
    input inMaster: Message; // control messages from the master
    output outMaster: Message; // control messages to the master
    
    logical action messageToMaster: Message;
    logical action sendStop:void;
    logical action confirmReceiving:void; // confirm receiving work
    logical action success:void; // found solution
    logical action returnWorkToMaster:void; // execution threshold exceeded, return new work
    
    reaction(messageToMaster) -> outMaster {=
        outMaster.set(messageToMaster.get());
    =}
    
    reaction(sendStop) -> messageToMaster {=
        messageToMaster.schedule(Message{StopMsg});
    =}
    
    reaction(confirmReceiving) -> messageToMaster {=
        messageToMaster.schedule(Message{ReceivedMsg});
    =}
    
    reaction(success) -> outMaster, confirmReceiving {=
        outMaster.set(Message{DoneMsg});
        confirmReceiving.schedule();
    =}
    
    reaction(returnWorkToMaster) -> outWork, confirmReceiving {=
        std::list<WorkMessage> newWork;
        while(!workQueue->empty()) {
            GridNode * loopNode = workQueue->front();
            workQueue->pop_front();
            newWork.emplace_back(loopNode, targetNode);
        }
        outWork.set(newWork);
        confirmReceiving.schedule();
    =}
    
    reaction(inWork) -> success,returnWorkToMaster,confirmReceiving {=
        // do the work inline instead of in an external thread
        reactor::log::Info() << "Worker " << bank_index << " received some work";
        
        WorkMessage workMessage = *(inWork.get());
        targetNode = workMessage.target;
        workQueue = std::make_unique<std::list<GridNode*>>();
        workQueue->push_front(workMessage.node);
        
        int nodesProcessed = 0;
        while(!workQueue->empty() && nodesProcessed < THRESHOLD) {
            
            nodesProcessed += 1;
            busyWait();
            
            GridNode * loopNode = workQueue->front();
            workQueue->pop_front();
            int numNeighbors = loopNode->numNeighbors();
            
            int i = 0;
            while(i < numNeighbors) {
                GridNode * loopNeighbor = loopNode->neighbor(i);
                bool res = loopNeighbor->setParent(loopNode);
                if(res) {
                    if(loopNeighbor == targetNode) {
                        success.schedule();
                        return;
                    } else {
                        workQueue->push_back(loopNeighbor);
                    }
                }
                i += 1;
            }
        }
        
        if(!workQueue->empty()) {
            returnWorkToMaster.schedule();
        } else {
            confirmReceiving.schedule(); // found only dead end
        }
    =}
    
    reaction(inMaster) -> sendStop {=
        
        if(inMaster.get()->type == StopMsg) {
            sendStop.schedule();
        }
    =}
}


main reactor (numIterations: size_t{12}, threshold: size_t{1024}, gridSize: size_t{30}, priorities: size_t{30}, numWorkers: size_t{20}) {
    
    private preamble {=
        #include "GuidedSearchCommon.hh"
    =}
    
    master = new Master(numWorkers=numWorkers, gridSize=gridSize);
    runner = new BenchmarkRunner(numIterations=numIterations, useInit=true, useCleanupIteration=true);
    
    runner.outInitializeStart -> master.inInitializeStart;
    master.outInitializeFinished -> runner.inInitializeFinish;
    
    runner.outCleanupIterationStart -> master.inCleanupIteration;
    master.outCleanupIterationFinished -> runner.inCleanupIterationFinish;
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=       
        // initializations of global variables that are not states in a reactor
        // those variables are global to be used in the helper functions
        PRIORITY_GRANULARITY = 8; // hard coded
        NUM_WORKERS = numWorkers;
        GRID_SIZE = gridSize;
        PRIORITIES = priorities;
        THRESHOLD = threshold;
        
        printBenchmarkInfo("GuidedSearchBenchmark");
        printArgs("numIterations", numIterations, "threshold", threshold, "gridSize", gridSize, "priorities", priorities, "numWorkers", numWorkers);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    workers = new[numWorkers] Worker();
    
    workers.outMaster -> master.inWorkers;
    workers.outWork -> master.inWorkersWork;
    master.outWorkers -> workers.inMaster;
    master.outWorkersWork -> workers.inWork;
}