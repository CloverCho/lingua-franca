/**
 * Code generator for a variable number of reactors
 * using the python module cog.
 * See https://nedbatchelder.com/code/cog/
 * 
 * Run 'cog -r -D numWorkers=20 this-file.lf'
 * with the desired number of reactors and the name of this file as arguments.
 * 
 * @author Hannes Klein
 */

/* [[[cog
  if 'numWorkers' in globals():
    numWorkers = int(numWorkers)
  else:
    globals()['numWorkers'] = 20
]]] */
// [[[end]]]

target Cpp {
    cmake-include: "SortedListReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor Master(numWorkers:int(20)) {
    
    state numWorkersTerminated:int(0);
    
    input inStart:void;
    output outFinished:void;
    
    /* [[[cog
      cog.outl(f'output[{numWorkers}] outWorkers:void;')
      cog.outl(f'input[{numWorkers}] inWorkers:void;')
    ]]] */
    output[22] outWorkers:void;
    input[22] inWorkers:void;
    // [[[end]]]
    output outSortedList:void;
    
    logical action startExecution:void;
    logical action finish:void;
    
    reaction(startExecution) -> outWorkers {=
        for(int i = 0; i < outWorkers.size(); ++i) {
            outWorkers[i].set();
        }
    =}
    
    reaction(finish) -> outFinished {=
        outFinished.set();
        outSortedList.set();
    =}
    
    reaction(inWorkers) -> finish {=
        
        for(int i = 0; i < inWorkers.size(); ++i) {
            if(inWorkers[i].is_present()) {
                numWorkersTerminated += 1;
                
                if(numWorkersTerminated == numWorkers) {
                    finish.schedule();
                }
            }
        }
    =}
    
    reaction(inStart) -> startExecution {=
        
        // init local state
        numWorkersTerminated = 0;
        
        // start execution
        startExecution.schedule();
    =}
}


reactor Worker(instance:int(0), numMessagesPerWorker:int(8000), writePercentage:int(10), sizePercentage:int(1)) {
    
    public preamble {=
        #include "include/PseudoRandom.hh"
        #include "SortedListCommon.hh"
    =}
    
    state messageCount:int(0);
    state random:{=PseudoRandom=};
    
    output outMaster:void;
    input inMaster:void;
    output outSortedList:{=Message=};
    input inSortedList:void;
    
    reaction(startup) {=
        // one time initialization
        random = PseudoRandom(instance + numMessagesPerWorker + writePercentage + sizePercentage);
    =}
    
    reaction(inMaster, inSortedList) -> outMaster, outSortedList {=
        
        messageCount += 1;
        if(messageCount <= numMessagesPerWorker) {
            int anInt = random.nextInt(100);
            
            if(anInt < sizePercentage) {
                outSortedList.set(Message{SizeMsg, -1});
            } else if(anInt < (sizePercentage + writePercentage)) {
                outSortedList.set(Message{WriteMsg, random.nextInt()});
            } else {
                outSortedList.set(Message{ContainsMsg, random.nextInt()});
            }
        } else {
            // reset local state
            messageCount = 0;
            random = PseudoRandom(instance + numMessagesPerWorker + writePercentage + sizePercentage);
            
            outMaster.set();
        }
    =}
}


reactor SortedList {
    
    public preamble {=
        #include "SortedListCommon.hh"
        #include "SortedLinkedList.hh"
        #include "reactor-cpp/logging.hh"
        #include <bitset>
    =}
    
    state dataList:{=SortedLinkedList<int>=};
    state workersToSend:{=std::bitset<20>=};
    
    input inMaster:void;
    /* [[[cog
      cog.outl(f'output[{numWorkers}] outWorkers:void;')
      cog.outl(f'input[{numWorkers}] inWorkers:{{=Message=}};')
    ]]] */
    output[22] outWorkers:void;
    input[22] inWorkers:{=Message=};
    // [[[end]]]
    
    logical action sendAnswers:void;
    
    reaction(inMaster) {=
        // check result
        reactor::log::Info() << "List Size = " << dataList.size();
        
        // reset local state
        dataList = SortedLinkedList<int>();
        workersToSend.reset();
    =}
    
    reaction(sendAnswers) -> outWorkers {=
        for(int i = 0; i < outWorkers.size(); ++i) {
            if(workersToSend[i]) {
                outWorkers[i].set();
                workersToSend[i] = false;
            }
        }
    =}
    
    reaction(inWorkers) -> sendAnswers {=
        
        sendAnswers.schedule();
        
        for(int i = 0; i < inWorkers.size(); ++i) {
            if(inWorkers[i].is_present()) {
                
                if(inWorkers[i].get()->type == WriteMsg) {
                    
                    int value = inWorkers[i].get()->value;
                    dataList.add(value);
                    workersToSend[i] = true;
                    
                } else if(inWorkers[i].get()->type == ContainsMsg) {
                    
                    int value = inWorkers[i].get()->value;
                    int result = dataList.contains(value) ? 1 : 0;
                    workersToSend[i] = true;
                    
                } else if(inWorkers[i].get()->type == SizeMsg) {
                    
                    int value = dataList.size();
                    workersToSend[i] = true;
                    
                }
            }
        }
    =}
}


main reactor SortedListBenchmark(numIterations:int(12), numMessagesPerWorker:int(8000), writePercentage:int(10), sizePercentage:int(1)) {
    
    /* [[[cog
      cog.outl(f'master = new Master(numWorkers={numWorkers});')
    ]]] */
    master = new Master(numWorkers=22);
    // [[[end]]]
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("SortedListReactorLFCppBenchmark");
        /* [[[cog
          cog.outl(f'printArgs("numIterations", numIterations, "numMessagesPerWorker", numMessagesPerWorker, "writePercentage", writePercentage, "sizePercentage", sizePercentage, "numWorkers", {numWorkers});')
        ]]] */
        printArgs("numIterations", numIterations, "numMessagesPerWorker", numMessagesPerWorker, "writePercentage", writePercentage, "sizePercentage", sizePercentage, "numWorkers", 22);
        /// [[[end]]]
        printSystemInfo();
        runner.inStart.set();
    =}
    
    /* [[[cog
      cog.outl(f'workers = new[{numWorkers}] Worker(numMessagesPerWorker=numMessagesPerWorker, writePercentage=writePercentage, sizePercentage=sizePercentage);')
    ]]] */
    workers = new[22] Worker(numMessagesPerWorker=numMessagesPerWorker, writePercentage=writePercentage, sizePercentage=sizePercentage);
    // [[[end]]]
    sortedList = new SortedList();
    
    master.outSortedList -> sortedList.inMaster;
    master.outWorkers -> workers.inMaster;
    sortedList.outWorkers -> workers.inSortedList;
    workers.outMaster -> master.inWorkers;
    workers.outSortedList -> sortedList.inWorkers;
    
}
