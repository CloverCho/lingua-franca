/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * Based on the version BankingAkkaManualStashActorBenchmark.scala
 * from the Savina suite.
 * 
 * @author Hannes Klein
 */



target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "Banking.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor Teller(numAccounts:int(1000), numBankings:int(50000)) {
    
    public preamble {=
        #include "BankingCommon.hh"
        #include "include/PseudoRandom.hh"
    =}
    
    state numCompletedBankings:int;
    state randomGen:{=PseudoRandom=};
    state numWorkGenerated:int(0);
    state nextGeneratedWorkMsg:{=reactor::ImmutableValuePtr<Message>=};
    state nextGeneratedWorkSrcAccountId:int;
    
    state inAccounts:{=std::vector<reactor::Input<Message> *>=};
    state outAccounts:{=std::vector<reactor::Output<Message> *>=};
    
    input inStart:void;
    output outFinished:void;
    
    output outAccount0:{=Message=};
    input inAccount0:{=Message=};
    output outAccount1:{=Message=};
    input inAccount1:{=Message=};
    output outAccount2:{=Message=};
    input inAccount2:{=Message=};
    output outAccount3:{=Message=};
    input inAccount3:{=Message=};
    output outAccount4:{=Message=};
    input inAccount4:{=Message=};
    output outAccount5:{=Message=};
    input inAccount5:{=Message=};
    output outAccount6:{=Message=};
    input inAccount6:{=Message=};
    output outAccount7:{=Message=};
    input inAccount7:{=Message=};
    output outAccount8:{=Message=};
    input inAccount8:{=Message=};
    output outAccount9:{=Message=};
    input inAccount9:{=Message=};
    
    logical action generateWork:void;
    
    reaction(startup) {=
        
        // one time initializations
        
        inAccounts = std::vector<reactor::Input<Message> *>(10);
        outAccounts = std::vector<reactor::Output<Message> *>(10);
        inAccounts[0] = &inAccount0;
        outAccounts[0] = &outAccount0;
        inAccounts[1] = &inAccount1;
        outAccounts[1] = &outAccount1;
        inAccounts[2] = &inAccount2;
        outAccounts[2] = &outAccount2;
        inAccounts[3] = &inAccount3;
        outAccounts[3] = &outAccount3;
        inAccounts[4] = &inAccount4;
        outAccounts[4] = &outAccount4;
        inAccounts[5] = &inAccount5;
        outAccounts[5] = &outAccount5;
        inAccounts[6] = &inAccount6;
        outAccounts[6] = &outAccount6;
        inAccounts[7] = &inAccount7;
        outAccounts[7] = &outAccount7;
        inAccounts[8] = &inAccount8;
        outAccounts[8] = &outAccount8;
        inAccounts[9] = &inAccount9;
        outAccounts[9] = &outAccount9;
    =}
    
    reaction(inStart) -> generateWork {=
        
        // reset local state
        numCompletedBankings = 0;
        randomGen = PseudoRandom(123456);
        numWorkGenerated = 0;
        nextGeneratedWorkMsg = reactor::ImmutableValuePtr<Message>();
        nextGeneratedWorkSrcAccountId = -1;
        
        // start execution
        generateWork.schedule();
    =}
    
    reaction(generateWork) ->
      generateWork,
      outAccount0,
      outAccount1,
      outAccount2,
      outAccount3,
      outAccount4,
      outAccount5,
      outAccount6,
      outAccount7,
      outAccount8,
      outAccount9
    {=
        
        if(numWorkGenerated >= numBankings) {
            return;
        }
        
        std::set<int> accountsWorkGeneratedFor;
        
        if(nextGeneratedWorkMsg != nullptr) {
            outAccounts[nextGeneratedWorkSrcAccountId]->set(nextGeneratedWorkMsg);
            accountsWorkGeneratedFor.insert(nextGeneratedWorkSrcAccountId);
            numWorkGenerated += 1;
        }
        
        // Generate work for accounts until no more work to
        // generate or work is genrated for an account that
        // already has work.
        while(numWorkGenerated < numBankings) {
            // src is lower than dest id to ensure there is never a deadlock
            int srcAccountId = randomGen.nextInt((outAccounts.size() / 10) * 8);
            nextGeneratedWorkSrcAccountId = srcAccountId;
            int loopId = randomGen.nextInt(outAccounts.size() - srcAccountId);
            if(loopId == 0) {
                loopId += 1;
            }
            int destAccountId = srcAccountId + loopId;
            
            double amount = abs(randomGen.nextDouble()) * 1000;
            
            auto ret = accountsWorkGeneratedFor.insert(srcAccountId);
            nextGeneratedWorkMsg = reactor::make_immutable_value<Message>(CreditMsg, amount, destAccountId);
            if(ret.second) {
                outAccounts[srcAccountId]->set(nextGeneratedWorkMsg);
                numWorkGenerated += 1;
            } else {
                break;
            }
        }
        
        generateWork.schedule();
    =}
    
    reaction(
        inAccount0,
        inAccount1,
        inAccount2,
        inAccount3,
        inAccount4,
        inAccount5,
        inAccount6,
        inAccount7,
        inAccount8,
        inAccount9
    ) -> 
      outFinished,
      outAccount0,
      outAccount1,
      outAccount2,
      outAccount3,
      outAccount4,
      outAccount5,
      outAccount6,
      outAccount7,
      outAccount8,
      outAccount9
    {=
        
        for(int i = 0; i < inAccounts.size(); ++i) {
            if(inAccounts[i]->is_present()) {
                if(inAccounts[i]->get()->type == ReplyMsg) {
                    
                    numCompletedBankings += 1;
                    if(numCompletedBankings == numBankings) {
                        for(int i = 0; i < outAccounts.size(); ++i) {
                            outAccounts[i]->set(Message{StopMsg});
                        }
                        outFinished.set();
                    }
                }
            }
        }
    =}
}


/** 
 * Intra-reactor-bank communication between Account reactors is prone
 * to deadlocks if two send each other CreditMsg at the same point
 * in logical time. This is prevented in the Teller-reactor that
 * generates DebitMsg according to an ordering.
 */
reactor Account(id:int(-1), initialBalance:double(0.0)) {
    
    public preamble {=
        #include "BankingCommon.hh"
        #include "include/PseudoRandom.hh"
        #include <list>
        #include "reactor-cpp/logging.hh"
    =}
    
    state numCompletedBankings:int(0);
    state randomGen:{=PseudoRandom=};
    state balance:double(initialBalance);
    state stashedMessages:{=std::list<reactor::ImmutableValuePtr<Message>>=};
    state inReplyMode:bool(false);
    
    state inAccounts:{=std::vector<reactor::Input<Message> *>=};
    state outAccounts:{=std::vector<reactor::Output<Message> *>=};
    
    input inTeller:{=Message=};
    output outTeller:{=Message=};
    
    output outAccount0:{=Message=};
    input inAccount0:{=Message=};
    output outAccount1:{=Message=};
    input inAccount1:{=Message=};
    output outAccount2:{=Message=};
    input inAccount2:{=Message=};
    output outAccount3:{=Message=};
    input inAccount3:{=Message=};
    output outAccount4:{=Message=};
    input inAccount4:{=Message=};
    output outAccount5:{=Message=};
    input inAccount5:{=Message=};
    output outAccount6:{=Message=};
    input inAccount6:{=Message=};
    output outAccount7:{=Message=};
    input inAccount7:{=Message=};
    output outAccount8:{=Message=};
    input inAccount8:{=Message=};
    output outAccount9:{=Message=};
    input inAccount9:{=Message=};
    
    logical action handleMessage:void;
    
    reaction(startup) {=
        // one time init
        numCompletedBankings = 0;
        randomGen = PseudoRandom(123456);
        balance = initialBalance;
        stashedMessages = std::list<reactor::ImmutableValuePtr<Message>>();
        inReplyMode = false;
        
        inAccounts = std::vector<reactor::Input<Message> *>(10);
        outAccounts = std::vector<reactor::Output<Message> *>(10);
        inAccounts[0] = &inAccount0;
        outAccounts[0] = &outAccount0;
        inAccounts[1] = &inAccount1;
        outAccounts[1] = &outAccount1;
        inAccounts[2] = &inAccount2;
        outAccounts[2] = &outAccount2;
        inAccounts[3] = &inAccount3;
        outAccounts[3] = &outAccount3;
        inAccounts[4] = &inAccount4;
        outAccounts[4] = &outAccount4;
        inAccounts[5] = &inAccount5;
        outAccounts[5] = &outAccount5;
        inAccounts[6] = &inAccount6;
        outAccounts[6] = &outAccount6;
        inAccounts[7] = &inAccount7;
        outAccounts[7] = &outAccount7;
        inAccounts[8] = &inAccount8;
        outAccounts[8] = &outAccount8;
        inAccounts[9] = &inAccount9;
        outAccounts[9] = &outAccount9;
    =}
    
    reaction(handleMessage) ->
      outTeller,
      outAccount0,
      outAccount1,
      outAccount2,
      outAccount3,
      outAccount4,
      outAccount5,
      outAccount6,
      outAccount7,
      outAccount8,
      outAccount9
    {=
        
        if(stashedMessages.empty()) {
            return;
        }
        
        if(inReplyMode) {
            
            auto reply = std::find_if(std::begin(stashedMessages), std::end(stashedMessages),
                [](reactor::ImmutableValuePtr<Message>& msg) { return (msg->type == ReplyMsg); }
            );
            if(reply == std::end(stashedMessages)) {
                // reply not received yet
            } else {
                // reply received
                inReplyMode = false;
                stashedMessages.erase(reply);
                outTeller.set(Message{ReplyMsg});
            }
            
        } else { // inReplyMode == false
            
            if(stashedMessages.front()->type == DebitMsg) {
                
                balance += stashedMessages.front()->amount;
                outAccounts[stashedMessages.front()->recipient]->set(Message{ReplyMsg});
                stashedMessages.pop_front();
                
            } else if(stashedMessages.front()->type == CreditMsg) {
                
                balance -= stashedMessages.front()->amount;
                int destAccount = stashedMessages.front()->recipient;
                outAccounts[destAccount]->set(Message{DebitMsg, stashedMessages.front()->amount, id});
                inReplyMode = true;
                stashedMessages.pop_front();
                
            } else if(stashedMessages.front()->type == StopMsg) {
                
                stashedMessages.pop_front();
                if(!stashedMessages.empty()) {
                    reactor::log::Info() << "Stop message received, but message queue not empty in account " << id;
                }
                // reset local state
                numCompletedBankings = 0;
                randomGen = PseudoRandom(123456);
                balance = initialBalance;
                stashedMessages = std::list<reactor::ImmutableValuePtr<Message>>();
                inReplyMode = false;
                return; // don't schedule
            }
        }
        
        handleMessage.schedule();
    =}
    
    reaction(
        inAccount0,
        inAccount1,
        inAccount2,
        inAccount3,
        inAccount4,
        inAccount5,
        inAccount6,
        inAccount7,
        inAccount8,
        inAccount9
    ) -> handleMessage {=
        
        for(int i = 0; i < inAccounts.size(); ++i) {
            if(inAccounts[i]->is_present()) {
                stashedMessages.push_back(inAccounts[i]->get());
            }
        }
        handleMessage.schedule();
    =}
    
    reaction(inTeller) -> handleMessage {=
        stashedMessages.push_back(inTeller.get());
        handleMessage.schedule();
    =}
}


main reactor BankingBenchmark(numIterations:int(12), numTransactions:int(50000)) {
    
    teller = new Teller(numAccounts=10, numBankings=numTransactions);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> teller.inStart;
    teller.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("BankingReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numTransactions", numTransactions, "numAccounts", 10);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    account0 = new Account(id=0, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account1 = new Account(id=1, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account2 = new Account(id=2, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account3 = new Account(id=3, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account4 = new Account(id=4, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account5 = new Account(id=5, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account6 = new Account(id=6, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account7 = new Account(id=7, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account8 = new Account(id=8, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    account9 = new Account(id=9, initialBalance={=std::numeric_limits<double>::max() / (10 * numTransactions)=});
    
    // connect teller with accounts
    teller.outAccount0 -> account0.inTeller;
    account0.outTeller -> teller.inAccount0;
    teller.outAccount1 -> account1.inTeller;
    account1.outTeller -> teller.inAccount1;
    teller.outAccount2 -> account2.inTeller;
    account2.outTeller -> teller.inAccount2;
    teller.outAccount3 -> account3.inTeller;
    account3.outTeller -> teller.inAccount3;
    teller.outAccount4 -> account4.inTeller;
    account4.outTeller -> teller.inAccount4;
    teller.outAccount5 -> account5.inTeller;
    account5.outTeller -> teller.inAccount5;
    teller.outAccount6 -> account6.inTeller;
    account6.outTeller -> teller.inAccount6;
    teller.outAccount7 -> account7.inTeller;
    account7.outTeller -> teller.inAccount7;
    teller.outAccount8 -> account8.inTeller;
    account8.outTeller -> teller.inAccount8;
    teller.outAccount9 -> account9.inTeller;
    account9.outTeller -> teller.inAccount9;
    
    // connect accounts as a clique
    account0.outAccount0 -> account0.inAccount0;
    account0.outAccount1 -> account1.inAccount0;
    account0.outAccount2 -> account2.inAccount0;
    account0.outAccount3 -> account3.inAccount0;
    account0.outAccount4 -> account4.inAccount0;
    account0.outAccount5 -> account5.inAccount0;
    account0.outAccount6 -> account6.inAccount0;
    account0.outAccount7 -> account7.inAccount0;
    account0.outAccount8 -> account8.inAccount0;
    account0.outAccount9 -> account9.inAccount0;

    account1.outAccount0 -> account0.inAccount1;
    account1.outAccount1 -> account1.inAccount1;
    account1.outAccount2 -> account2.inAccount1;
    account1.outAccount3 -> account3.inAccount1;
    account1.outAccount4 -> account4.inAccount1;
    account1.outAccount5 -> account5.inAccount1;
    account1.outAccount6 -> account6.inAccount1;
    account1.outAccount7 -> account7.inAccount1;
    account1.outAccount8 -> account8.inAccount1;
    account1.outAccount9 -> account9.inAccount1;

    account2.outAccount0 -> account0.inAccount2;
    account2.outAccount1 -> account1.inAccount2;
    account2.outAccount2 -> account2.inAccount2;
    account2.outAccount3 -> account3.inAccount2;
    account2.outAccount4 -> account4.inAccount2;
    account2.outAccount5 -> account5.inAccount2;
    account2.outAccount6 -> account6.inAccount2;
    account2.outAccount7 -> account7.inAccount2;
    account2.outAccount8 -> account8.inAccount2;
    account2.outAccount9 -> account9.inAccount2;

    account3.outAccount0 -> account0.inAccount3;
    account3.outAccount1 -> account1.inAccount3;
    account3.outAccount2 -> account2.inAccount3;
    account3.outAccount3 -> account3.inAccount3;
    account3.outAccount4 -> account4.inAccount3;
    account3.outAccount5 -> account5.inAccount3;
    account3.outAccount6 -> account6.inAccount3;
    account3.outAccount7 -> account7.inAccount3;
    account3.outAccount8 -> account8.inAccount3;
    account3.outAccount9 -> account9.inAccount3;

    account4.outAccount0 -> account0.inAccount4;
    account4.outAccount1 -> account1.inAccount4;
    account4.outAccount2 -> account2.inAccount4;
    account4.outAccount3 -> account3.inAccount4;
    account4.outAccount4 -> account4.inAccount4;
    account4.outAccount5 -> account5.inAccount4;
    account4.outAccount6 -> account6.inAccount4;
    account4.outAccount7 -> account7.inAccount4;
    account4.outAccount8 -> account8.inAccount4;
    account4.outAccount9 -> account9.inAccount4;

    account5.outAccount0 -> account0.inAccount5;
    account5.outAccount1 -> account1.inAccount5;
    account5.outAccount2 -> account2.inAccount5;
    account5.outAccount3 -> account3.inAccount5;
    account5.outAccount4 -> account4.inAccount5;
    account5.outAccount5 -> account5.inAccount5;
    account5.outAccount6 -> account6.inAccount5;
    account5.outAccount7 -> account7.inAccount5;
    account5.outAccount8 -> account8.inAccount5;
    account5.outAccount9 -> account9.inAccount5;

    account6.outAccount0 -> account0.inAccount6;
    account6.outAccount1 -> account1.inAccount6;
    account6.outAccount2 -> account2.inAccount6;
    account6.outAccount3 -> account3.inAccount6;
    account6.outAccount4 -> account4.inAccount6;
    account6.outAccount5 -> account5.inAccount6;
    account6.outAccount6 -> account6.inAccount6;
    account6.outAccount7 -> account7.inAccount6;
    account6.outAccount8 -> account8.inAccount6;
    account6.outAccount9 -> account9.inAccount6;

    account7.outAccount0 -> account0.inAccount7;
    account7.outAccount1 -> account1.inAccount7;
    account7.outAccount2 -> account2.inAccount7;
    account7.outAccount3 -> account3.inAccount7;
    account7.outAccount4 -> account4.inAccount7;
    account7.outAccount5 -> account5.inAccount7;
    account7.outAccount6 -> account6.inAccount7;
    account7.outAccount7 -> account7.inAccount7;
    account7.outAccount8 -> account8.inAccount7;
    account7.outAccount9 -> account9.inAccount7;

    account8.outAccount0 -> account0.inAccount8;
    account8.outAccount1 -> account1.inAccount8;
    account8.outAccount2 -> account2.inAccount8;
    account8.outAccount3 -> account3.inAccount8;
    account8.outAccount4 -> account4.inAccount8;
    account8.outAccount5 -> account5.inAccount8;
    account8.outAccount6 -> account6.inAccount8;
    account8.outAccount7 -> account7.inAccount8;
    account8.outAccount8 -> account8.inAccount8;
    account8.outAccount9 -> account9.inAccount8;

    account9.outAccount0 -> account0.inAccount9;
    account9.outAccount1 -> account1.inAccount9;
    account9.outAccount2 -> account2.inAccount9;
    account9.outAccount3 -> account3.inAccount9;
    account9.outAccount4 -> account4.inAccount9;
    account9.outAccount5 -> account5.inAccount9;
    account9.outAccount6 -> account6.inAccount9;
    account9.outAccount7 -> account7.inAccount9;
    account9.outAccount8 -> account8.inAccount9;
    account9.outAccount9 -> account9.inAccount9;

}