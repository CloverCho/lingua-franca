/**
 * This variant of the benchmark moves the logical action
 * that is necessary to break the causality loop from the
 * dictionary reactor to the worker reactor.
 * This design is slower in general but might be closer
 * to the design used in practice for problems with a
 * similar structure.
 * 
 * @author Hannes Klein
 */

target Cpp {
    cmake-include: "DictionaryReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";
import Master from "DictionaryReactorCppBenchmark.lf";

reactor Dictionary(numWorkers:int(20), initialState:{=std::map<int,int>=}({=std::map<int,int>()=})) {
    
    public preamble {=
        #include "DictionaryCommon.hh"
    =}
    
    state dataMap:{=std::map<int,int>=}(initialState);
    
    //TODO parametrize with numWorkers
    output[20] outWorkers:{=Message=};
    input[20] inWorkers:{=Message=};
    input inMaster:void;
    
    reaction(inMaster) {=
        //reset local state
        dataMap = initialState;
    =}
    
    reaction(inWorkers) -> outWorkers {=
        
        //TODO The order in which messages are read is relevant.
        // It effectively assigns priorities to the workers.
        for(int i = 0; i < inWorkers.size(); i++) {
            reactor::ImmutableValuePtr<Message> msg = inWorkers[i].get();
            
            if(msg->type == WriteMsg) {
                dataMap.emplace(msg->key, msg->value);
                // Savina sends ResultMsg always, ignoring if adding (key,value)
                // to the map was successful.
                outWorkers[i].set(Message{ResultMsg, -1, msg->value});
            } else if(msg->type == ReadMsg) {
                int value = dataMap[msg->key];
                // Savina does not handle what happens if the key is not present.
                outWorkers[i].set(Message{ResultMsg, -1, value});
            }
        }
    =}
}

reactor Worker(instance:int(0), numMessagesPerWorker:int(10000), writePercentage:int(10)) {
    
    public preamble {=
        #include "DictionaryCommon.hh"
        #include <random>
    =}
    
    state messageCount:int(0);
    state id:int(instance);
    state random:{=std::minstd_rand=};
    
    input inMaster:{=Message=};
    output outMaster:{=Message=};
    
    input inDict:{=Message=};
    output outDict:{=Message=};
    
    // this logical action in the worker is a more "realistic" or practical relevant
    // design but creates contention.
    logical action sendNext:void;
    
    reaction(inMaster) -> sendNext {=
        
        if(inMaster.get()->type == DoWorkMsg) {
            //reset local state
            random.seed(id + numMessagesPerWorker + writePercentage);
            messageCount = 0;
            
            messageCount += 1; // as in original Savina implementation
            sendNext.schedule();
        }
    =}
    
    reaction(sendNext) -> outDict, outMaster {=
        
        if(messageCount <= numMessagesPerWorker) {
            int anInt = static_cast<int>(random()) % 100;
            if(anInt < writePercentage) {
                outDict.set(Message{WriteMsg, static_cast<int>(random()), static_cast<int>(random())});
            } else {
                outDict.set(Message{ReadMsg, static_cast<int>(random())});
            }
        } else {
            outMaster.set(Message{EndWorkMsg, -1, -1});
        }
    =}
    
    reaction(inDict) -> sendNext {=
        messageCount += 1;
        sendNext.schedule();
    =}
}

main reactor DictionaryBenchmark(numIterations:int(12), numMessagesPerWorker:int(10000), writePercentage:int(10)) {
    
    master = new Master(numWorkers=20);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("DictionaryPracReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numMessagesPerWorker", numMessagesPerWorker, "writePercentage", writePercentage);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    dict = new Dictionary(numWorkers=20);
    workers = new[20] Worker(numMessagesPerWorker=numMessagesPerWorker, writePercentage=writePercentage);
    
    dict.outWorkers -> workers.inDict;
    workers.outDict -> dict.inWorkers;
    workers.outMaster -> master.inWorkers;
    master.outWorkers -> workers.inMaster;
    master.outDictionary -> dict.inMaster;
    
}
