/**
 * Parallelism benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * @author Hannes Klein
 */



target Cpp {
    build-type : RelWithDebInfo,
    cmake-include: "Trapezoidal.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor Master(numWorkers:int(100), L:double(1.0), R:double(5.0), N:int(10000000)) {
    
    public preamble {=
        #include "TrapezoidalCommon.hh"
        #include "reactor-cpp/logging.hh"
    =}
    
    state numTermsReceived:int(0);
    state resultArea:double(0.0);
    
    input inStart:void;
    output outFinished:void;
    
    output[100] outWorkers:{=WorkMessage=};
    input[100] inWorkers:{=double=};
    
    logical action sendWorkMessages:void;
    
    reaction(inStart) -> sendWorkMessages {=
        
        // reset local state
        numTermsReceived = 0;
        resultArea = 0.0;
        
        // start execution
        sendWorkMessages.schedule();
    =}
    
    reaction(sendWorkMessages) -> outWorkers {=
        
        double workerRange = (R - L) / numWorkers;
        double precision = (R - L) / N;
        for(int i = 0; i < outWorkers.size(); ++i) {
            double wl = (workerRange * i) + L;
            double wr = wl + workerRange;
            
            outWorkers[i].set(WorkMessage{wl,wr,precision});
        }
    =}
    
    reaction(inWorkers) -> outFinished {=
        
        for(int i = 0; i < inWorkers.size(); ++i) {
            if(inWorkers[i].is_present()) {
                numTermsReceived += 1;
                resultArea += *inWorkers[i].get();
            }
        }
        
        if(numTermsReceived == numWorkers) {
            reactor::log::Info() << "Area: " << resultArea;
            outFinished.set();
        }
    =}
}


reactor Worker(instance:int(0)) {
    
    input inMaster:{=WorkMessage=};
    output outMaster:{=double=};
    
    public preamble {=
        #include <cmath>
        #include "TrapezoidalCommon.hh"
    =}
    
    reaction(inMaster) -> outMaster {=
        
        double r = inMaster.get()->r;
        double l = inMaster.get()->l;
        double h = inMaster.get()->h;
        int n = static_cast<int>( ((r - l) / h) );
        double accumArea = 0.0;
        
        int i = 0;
        while(i < n) {
            double lx = (i * h) + l;
            double rx = lx + h;
            
            double ly = fx(lx);
            double ry = fx(rx);
            
            double area = 0.5 * (ly + ry) * h;
            accumArea += area;
            
            i += 1;
        }
        
        outMaster.set(accumArea);
    =}
    
    private preamble {=
        
        // the function to integrate
        double fx(double x) {
            
            double a = sin(pow(x, 3.0) - 1);
            double b = x + 1;
            double c = a / b;
            double d = sqrt(1.0 + exp(sqrt(2 * x)));
            double r = c * d;
            return r;
        }
    =}
}


main reactor ProdConsBenchmark(numIterations:int(12), numPieces:int(10000000), leftEndPoint:double(1.0), rightEndPoint:double(5.0)) {
    
    master = new Master(numWorkers=100, L=leftEndPoint, R=rightEndPoint, N=numPieces);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> master.inStart;
    master.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("TrapezoidalBenchmark");
        printArgs("numIterations", numIterations, "numPieces", numPieces, "leftEndPoint", leftEndPoint, "rightEndPoint", rightEndPoint, "numWorkers", 100);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    workers = new[100] Worker();
    
    workers.outMaster -> master.inWorkers;
    master.outWorkers -> workers.inMaster;
}