/**
 * Micro-benchmark from the Savina benchmark suite. Intended
 * to measure the effects on shared resources (the mailbox of
 * the mall actor) while processing messages in the actor model.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * To break the causality loop the mall reactor contains a logical
 * action.
 * 
 * Informal results for 1,000,000 pings
 * on my PC with fast forward enabled:
 * Unthreaded: 3050 ms
 * Threaded: >1 min
 * 
 * For comparison some informal results for 1,000,000 pings
 * and 5 reactors
 * on the same PC with the Savina Akka implementation:
 * Threaded: 1580 ms
 * 
 * @author Hannes Klein
 */

target Cpp {
    cmake-include: "BigReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor SinkReactor(numWorkers:int(120)) {
    
    public preamble {=
        #include "BigCommon.hh"
    =}
    
    // number of exit messages received
    state numMessages:int(0);
    
    // collections for inputs for easier access
    state inputs:{=std::vector<reactor::Input<void>*>=};
    
    input inStart:void;
    output outFinished:void;
    
    //TODO parametrize
    input inBig0:void;
    input inBig1:void;
    input inBig2:void;
    input inBig3:void;
    input inBig4:void;
    
    // only one output needed to send start msg to all reactors
    output outBig:void;
    
    reaction(startup) {=
        
        // Initialize collection of ports for easier handling
        
        //TODO parametrize
        inputs.reserve(numWorkers);
        inputs.push_back(&inBig0);
        inputs.push_back(&inBig1);
        inputs.push_back(&inBig2);
        inputs.push_back(&inBig3);
        inputs.push_back(&inBig4);
        
    =}
    
    reaction(inStart) -> outBig {=
        // reset state
        numMessages = 0;
        
        outBig.set();
    =}
    
    reaction(
        inBig0,
        inBig1,
        inBig2,
        inBig3,
        inBig4
    ) -> outFinished {=
        
        // collect all exit messages
        for(int i = 0; i < inputs.size(); i++) {
            if(inputs[i]->is_present()) {
                numMessages += 1;
                if(numMessages == numWorkers) {
                    outFinished.set();
                    return;
                }
            }
        }
    =}
}

reactor BigReactor(id:int(-1), numMessages:int(20000), numWorkers:int(120)) {
    
    public preamble {=
        #include "BigCommon.hh"
        #include "PseudoRandom.hh"
    =}
    
    state numPings:int(0);
    state random:PseudoRandom;
    state pongsToSend:{=std::vector<int>=};
    state receivedPong:bool;
    state sendNextPingTo:int(-1);
    
    state inputs:{=std::vector<reactor::Input<MsgType>*>=};
    state outputs:{=std::vector<reactor::Output<MsgType>*>=};
    
    input inSink:void;
    output outSink:void;
    
    logical action send:void; //send both pings and pongs
    
    //TODO parametrize
    input inBig0:{=MsgType=};
    input inBig1:{=MsgType=};
    input inBig2:{=MsgType=};
    input inBig3:{=MsgType=};
    input inBig4:{=MsgType=};
    
    //TODO parametrize
    output outBig0:{=MsgType=};
    output outBig1:{=MsgType=};
    output outBig2:{=MsgType=};
    output outBig3:{=MsgType=};
    output outBig4:{=MsgType=};
    
    reaction(startup) {=
        
        // Initialize collection of ports for easier handling
        
        //TODO parametrize
        inputs.reserve(numWorkers);
        inputs.push_back(&inBig0);
        inputs.push_back(&inBig1);
        inputs.push_back(&inBig2);
        inputs.push_back(&inBig3);
        inputs.push_back(&inBig4);
        
        //TODO parametrize
        outputs.reserve(numWorkers);
        outputs.push_back(&outBig0);
        outputs.push_back(&outBig1);
        outputs.push_back(&outBig2);
        outputs.push_back(&outBig3);
        outputs.push_back(&outBig4);
    =}
    
    //TODO parametrize
    reaction(send) -> outSink,
      outBig0,
      outBig1,
      outBig2,
      outBig3,
      outBig4
    {=
        
        //send ping
        if(numPings < numMessages && receivedPong) {
            if(sendNextPingTo == -1) {
                sendNextPingTo = random.nextInt(inputs.size());
            }
            // We can only send a new ping message to reactor sendNextPingTo if
            // we do not already send a pong message to that exact same reactor. 
            if(find(pongsToSend.begin(), pongsToSend.end(), sendNextPingTo) ==  pongsToSend.end()) {
                // Send ping now.
                outputs[sendNextPingTo]->set(PingMsg);
                sendNextPingTo = -1;
                receivedPong = false;
                numPings += 1;
                if(numPings == numMessages) {
                    //send exit msg one time
                    outSink.set();
                }
            } else {
                // Send ping later
                send.schedule();
            }
        }
        
        // Send pongs.
        for(int i = 0; i < pongsToSend.size(); i++) {
            outputs[pongsToSend[i]]->set(PongMsg);
        }
        pongsToSend.clear();
    =}
    
    reaction(
        inBig0,
        inBig1,
        inBig2,
        inBig3,
        inBig4
    ) -> send {=
        
        // list incoming pings
        for(int i = 0; i < inputs.size(); i++) {
            if(inputs[i]->is_present()) {
                if(*(inputs[i]->get()) == PingMsg) {
                    pongsToSend.push_back(i);
                } else {
                    // message type == PongMsg
                    receivedPong = true;
                }
            }
        }
        
        send.schedule();
    =}
    
    reaction(inSink) -> send {=
        
        // reset local state
        numPings = 0;
        random = PseudoRandom(id);
        pongsToSend.clear();
        pongsToSend.reserve(numWorkers);
        receivedPong = true;
        sendNextPingTo = -1;
        
        // start execution
        send.schedule();
    =}
}

main reactor BigBenchmark(numIterations:int(12), numPingsPerReactor:int(20000)) {
    
    sink = new SinkReactor(numWorkers=5);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> sink.inStart;
    sink.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("BigReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numPingsPerReactor", numPingsPerReactor);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    big0 = new BigReactor(id=0, numMessages=numPingsPerReactor, numWorkers=5);
    big1 = new BigReactor(id=1, numMessages=numPingsPerReactor, numWorkers=5);
    big2 = new BigReactor(id=2, numMessages=numPingsPerReactor, numWorkers=5);
    big3 = new BigReactor(id=3, numMessages=numPingsPerReactor, numWorkers=5);
    big4 = new BigReactor(id=4, numMessages=numPingsPerReactor, numWorkers=5);
    
    sink.outBig -> big0.inSink;
    sink.outBig -> big1.inSink;
    sink.outBig -> big2.inSink;
    sink.outBig -> big3.inSink;
    sink.outBig -> big4.inSink;
    
    big0.outSink -> sink.inBig0;
    big1.outSink -> sink.inBig1;
    big2.outSink -> sink.inBig2;
    big3.outSink -> sink.inBig3;
    big4.outSink -> sink.inBig4;
    
    big0.outBig0 -> big0.inBig0;
    big0.outBig1 -> big1.inBig0;
    big0.outBig2 -> big2.inBig0;
    big0.outBig3 -> big3.inBig0;
    big0.outBig4 -> big4.inBig0;
    
    big1.outBig0 -> big0.inBig1;
    big1.outBig1 -> big1.inBig1;
    big1.outBig2 -> big2.inBig1;
    big1.outBig3 -> big3.inBig1;
    big1.outBig4 -> big4.inBig1;
    
    big2.outBig0 -> big0.inBig2;
    big2.outBig1 -> big1.inBig2;
    big2.outBig2 -> big2.inBig2;
    big2.outBig3 -> big3.inBig2;
    big2.outBig4 -> big4.inBig2;
    
    big3.outBig0 -> big0.inBig3;
    big3.outBig1 -> big1.inBig3;
    big3.outBig2 -> big2.inBig3;
    big3.outBig3 -> big3.inBig3;
    big3.outBig4 -> big4.inBig3;
    
    big4.outBig0 -> big0.inBig4;
    big4.outBig1 -> big1.inBig4;
    big4.outBig2 -> big2.inBig4;
    big4.outBig3 -> big3.inBig4;
    big4.outBig4 -> big4.inBig4;
}
