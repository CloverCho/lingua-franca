/**
 * Code generator for a variable number of reactors
 * using the python module cog.
 * See https://nedbatchelder.com/code/cog/
 * 
 * Run 'cog -r -D numReactors=6 this-file.lf'
 * with the desired number of reactors and the name of this file as arguments.
 * 
 * @author Hannes Klein
 */

 /* [[[cog
  if 'numReactors' in globals():
    numReactors = int(numReactors)
  else:
    globals()['numReactors'] = 120
]]] */
// [[[end]]]

target Cpp {
    cmake-include: "BigReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor SinkReactor(numWorkers:int(120)) {
    
    public preamble {=
        #include "BigCommon.hh"
    =}
    
    // number of exit messages received
    state numMessages:int(0);
    
    // collections for inputs for easier access
    state inputs:{=std::vector<reactor::Input<void>*>=};
    
    input inStart:void;
    output outFinished:void;
    
    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'input inBig{str(i)}:void;')
    ]]] */
    input inBig0:void;
    input inBig1:void;
    input inBig2:void;
    input inBig3:void;
    input inBig4:void;
    // [[[end]]]
    
    // only one output needed to send start msg to all reactors
    output outBig:void;
    
    reaction(startup) {=
        
        // Initialize collection of ports for easier handling
        
        inputs.reserve(numWorkers);
        /* [[[cog
          for i in range(numReactors):
            cog.outl(f'inputs.push_back(&inBig{i});')
        ]]] */
        inputs.push_back(&inBig0);
        inputs.push_back(&inBig1);
        inputs.push_back(&inBig2);
        inputs.push_back(&inBig3);
        inputs.push_back(&inBig4);
        // [[[end]]]
        
    =}
    
    reaction(inStart) -> outBig {=
        // reset state
        numMessages = 0;
        
        outBig.set();
    =}
    
    reaction(
        /* [[[cog
          for i in range(numReactors):
            cog.out(f'inBig{i}')
            if i < numReactors-1:
              cog.outl(',')
            else:
              cog.outl('')
        ]]] */
        inBig0,
        inBig1,
        inBig2,
        inBig3,
        inBig4
        // [[[end]]]
    ) -> outFinished {=
        
        // collect all exit messages
        for(int i = 0; i < inputs.size(); i++) {
            if(inputs[i]->is_present()) {
                numMessages += 1;
                if(numMessages == numWorkers) {
                    outFinished.set();
                    return;
                }
            }
        }
    =}
}

reactor BigReactor(id:int(-1), numMessages:int(20000), numWorkers:int(120)) {
    
    public preamble {=
        #include "BigCommon.hh"
        #include "PseudoRandom.hh"
    =}
    
    state numPings:int(0);
    state random:PseudoRandom;
    state pongsToSend:{=std::vector<int>=};
    state receivedPong:bool;
    state sendNextPingTo:int(-1);
    
    state inputs:{=std::vector<reactor::Input<MsgType>*>=};
    state outputs:{=std::vector<reactor::Output<MsgType>*>=};
    
    input inSink:void;
    output outSink:void;
    
    logical action send:void; //send both pings and pongs
    
    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'input inBig{str(i)}:{{=MsgType=}};')
    ]]] */
    input inBig0:{=MsgType=};
    input inBig1:{=MsgType=};
    input inBig2:{=MsgType=};
    input inBig3:{=MsgType=};
    input inBig4:{=MsgType=};
    // [[[end]]]

    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'output outBig{i}:{{=MsgType=}};')
    ]]] */
    output outBig0:{=MsgType=};
    output outBig1:{=MsgType=};
    output outBig2:{=MsgType=};
    output outBig3:{=MsgType=};
    output outBig4:{=MsgType=};
    // [[[end]]]
    
    reaction(startup) {=
        
        // Initialize collection of ports for easier handling
        
        inputs.reserve(numWorkers);
        /* [[[cog
          for i in range(numReactors):
            cog.outl(f'inputs.push_back(&inBig{i});')
        ]]] */
        inputs.push_back(&inBig0);
        inputs.push_back(&inBig1);
        inputs.push_back(&inBig2);
        inputs.push_back(&inBig3);
        inputs.push_back(&inBig4);
        // [[[end]]]

        outputs.reserve(numWorkers);
        /* [[[cog
          for i in range(numReactors):
            cog.outl(f'outputs.push_back(&outBig{i});')
        ]]] */
        outputs.push_back(&outBig0);
        outputs.push_back(&outBig1);
        outputs.push_back(&outBig2);
        outputs.push_back(&outBig3);
        outputs.push_back(&outBig4);
        // [[[end]]]
    =}
    
    reaction(send) -> outSink,
      /* [[[cog
        for i in range(numReactors):
          cog.out(f'outBig{i}')
          if i < numReactors-1:
            cog.outl(',')
          else:
            cog.outl('')
      ]]] */
      outBig0,
      outBig1,
      outBig2,
      outBig3,
      outBig4
      // [[[end]]]
    {=
        
        //send ping
        if(numPings < numMessages && receivedPong) {
            if(sendNextPingTo == -1) {
                sendNextPingTo = random.nextInt(inputs.size());
            }
            // We can only send a new ping message to reactor sendNextPingTo if
            // we do not already send a pong message to that exact same reactor. 
            if(find(pongsToSend.begin(), pongsToSend.end(), sendNextPingTo) ==  pongsToSend.end()) {
                // Send ping now.
                outputs[sendNextPingTo]->set(PingMsg);
                sendNextPingTo = -1;
                receivedPong = false;
                numPings += 1;
                if(numPings == numMessages) {
                    //send exit msg one time
                    outSink.set();
                }
            } else {
                // Send ping later
                send.schedule();
            }
        }
        
        // Send pongs.
        for(int i = 0; i < pongsToSend.size(); i++) {
            outputs[pongsToSend[i]]->set(PongMsg);
        }
        pongsToSend.clear();
    =}
    
    reaction(
        /* [[[cog
          for i in range(numReactors):
            cog.out(f'inBig{i}')
            if i < numReactors-1:
              cog.outl(',')
            else:
              cog.outl('')
        ]]] */
        inBig0,
        inBig1,
        inBig2,
        inBig3,
        inBig4
        // [[[end]]]
    ) -> send {=
        
        // list incoming pings
        for(int i = 0; i < inputs.size(); i++) {
            if(inputs[i]->is_present()) {
                if(*(inputs[i]->get()) == PingMsg) {
                    pongsToSend.push_back(i);
                } else {
                    // message type == PongMsg
                    receivedPong = true;
                }
            }
        }
        
        send.schedule();
    =}
    
    reaction(inSink) -> send {=
        
        // reset local state
        numPings = 0;
        random = PseudoRandom(id);
        pongsToSend.clear();
        pongsToSend.reserve(numWorkers);
        receivedPong = true;
        sendNextPingTo = -1;
        
        // start execution
        send.schedule();
    =}
}

main reactor BigBenchmark(numIterations:int(12), numPingsPerReactor:int(20000)) {
    
    /* [[[cog
      cog.outl(f'sink = new SinkReactor(numWorkers={numReactors});')
    ]]] */
    sink = new SinkReactor(numWorkers=5);
    // [[[end]]]
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> sink.inStart;
    sink.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("BigReactorLFCppBenchmark");
        /* [[[cog
          cog.outl(f'printArgs("numIterations", numIterations, "numPingsPerReactor", numPingsPerReactor, "numReactors", {numReactors});')
        ]]] */
        printArgs("numIterations", numIterations, "numPingsPerReactor", numPingsPerReactor, "numReactors", 5);
        // [[[end]]]
        printSystemInfo();
        runner.inStart.set();
    =}
    
    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'big{i} = new BigReactor(id={i}, numMessages=numPingsPerReactor, numWorkers={numReactors});')
    ]]] */
    big0 = new BigReactor(id=0, numMessages=numPingsPerReactor, numWorkers=5);
    big1 = new BigReactor(id=1, numMessages=numPingsPerReactor, numWorkers=5);
    big2 = new BigReactor(id=2, numMessages=numPingsPerReactor, numWorkers=5);
    big3 = new BigReactor(id=3, numMessages=numPingsPerReactor, numWorkers=5);
    big4 = new BigReactor(id=4, numMessages=numPingsPerReactor, numWorkers=5);
    // [[[end]]]
    
    // connect sink

    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'sink.outBig -> big{i}.inSink;')
    ]]] */
    sink.outBig -> big0.inSink;
    sink.outBig -> big1.inSink;
    sink.outBig -> big2.inSink;
    sink.outBig -> big3.inSink;
    sink.outBig -> big4.inSink;
    // [[[end]]]
    
    /* [[[cog
      for i in range(numReactors):
        cog.outl(f'big{i}.outSink -> sink.inBig{i};')
    ]]] */
    big0.outSink -> sink.inBig0;
    big1.outSink -> sink.inBig1;
    big2.outSink -> sink.inBig2;
    big3.outSink -> sink.inBig3;
    big4.outSink -> sink.inBig4;
    // [[[end]]]
    
    /* [[[cog
      for i in range(numReactors):
        for j in range(numReactors):
          cog.outl(f'big{i}.outBig{j} -> big{j}.inBig{i};')
        cog.outl('')
    ]]] */
    big0.outBig0 -> big0.inBig0;
    big0.outBig1 -> big1.inBig0;
    big0.outBig2 -> big2.inBig0;
    big0.outBig3 -> big3.inBig0;
    big0.outBig4 -> big4.inBig0;

    big1.outBig0 -> big0.inBig1;
    big1.outBig1 -> big1.inBig1;
    big1.outBig2 -> big2.inBig1;
    big1.outBig3 -> big3.inBig1;
    big1.outBig4 -> big4.inBig1;

    big2.outBig0 -> big0.inBig2;
    big2.outBig1 -> big1.inBig2;
    big2.outBig2 -> big2.inBig2;
    big2.outBig3 -> big3.inBig2;
    big2.outBig4 -> big4.inBig2;

    big3.outBig0 -> big0.inBig3;
    big3.outBig1 -> big1.inBig3;
    big3.outBig2 -> big2.inBig3;
    big3.outBig3 -> big3.inBig3;
    big3.outBig4 -> big4.inBig3;

    big4.outBig0 -> big0.inBig4;
    big4.outBig1 -> big1.inBig4;
    big4.outBig2 -> big2.inBig4;
    big4.outBig3 -> big3.inBig4;
    big4.outBig4 -> big4.inBig4;

    // [[[end]]]
}
