/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This implementation keeps close to the Savina implementation
 * with Akka. There is no notion of time and there is no delay
 * or work done when a philosopher is thinking or eating.
 * 
 * @author Hannes Klein
 */

target Cpp {
    cmake-include: "PhilosopherReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


reactor ArbitratorReactor(numPhilosophers:int(20), numForks:int(20)) {
    
    public preamble {=
        #include "PhilosopherCommon.hh"
        #include <bitset>
    =}
    
    //TODO parametrize the size of the bitset
    state messagesToSend:{=std::vector<std::pair<int,Message>>=};
    state forks:{=std::bitset<20>=};
    state numExitedPhilosophers:int(0);
    
    input inStart:void;
    output outFinished:void;
    
    //TODO parametrize
    output[20] outPhilosophers:{=Message=};
    input[20] inPhilosophers:{=Message=};
    output outCounter:void;
    
    logical action sendMessages:void;
    
    reaction(startup) {=
        messagesToSend.reserve(numPhilosophers);
    =}
    
    reaction(inStart) -> outPhilosophers, outCounter {=
        
        // reset state
        messagesToSend.clear();
        numExitedPhilosophers = 0;
        forks.reset();
        
        // reset other reactors and start execution
        for(auto& p: outPhilosophers) {
            p.set(Message{StartMsg});
        }
        outCounter.set();
    =}
    
    reaction(sendMessages) -> outPhilosophers {=
        for(int i = 0; i < messagesToSend.size(); i++) {
            outPhilosophers[messagesToSend[i].first].set(messagesToSend[i].second);
        }
        messagesToSend.clear();
    =}
    
    reaction(inPhilosophers) -> outFinished, sendMessages {=
        
        // the order of checking the inputs gives the philosophers a priority
        for(int i = 0; i < inPhilosophers.size(); i++) {
            if(inPhilosophers[i].is_present()) {
                if(inPhilosophers[i].get()->type == HungryMsg) {
                    
                    bool leftFork = forks[i];
                    bool rightFork = forks[(i + 1) % numForks];
                    
                    if(leftFork || rightFork) {
                        // someone else has access to the fork
                        //outPhilosophers[i].set(Message{DeniedMsg});
                        messagesToSend.push_back(std::pair{i, Message{DeniedMsg}});
                    } else {
                        forks[i] = true;
                        forks[(i + 1) % numForks] = true;
                        //outPhilosophers[i].set(Message{EatMsg});
                        messagesToSend.push_back(std::pair{i, Message{EatMsg}});
                    }
                    
                } else if(inPhilosophers[i].get()->type == DoneMsg) {
                    
                    forks[i] = false;
                    forks[(i + 1) % numForks] = false;
                    
                } else if(inPhilosophers[i].get()->type == ExitMsg) {
                    
                    numExitedPhilosophers += 1;
                    if(numForks == numExitedPhilosophers) {
                        outFinished.set();
                    }
                }
            }
        }
        
        // schedule sending messages here for efficiency
        sendMessages.schedule();
    =}
}

reactor PhilosopherReactor(instance:int(0), rounds:int(10000)) {
    
    public preamble {=
        #include "PhilosopherCommon.hh"
    =}
    
    state localCounter:long(0); // count failed tries
    state roundsSoFar:int(0); // count successful tries
    
    input inArbitrator:{=Message=};
    output outArbitrator:{=Message=};
    output outCounterDenied:long;
    
    logical action requestToEat:void;
    logical action finish:void;
    
    reaction(requestToEat) -> outArbitrator {=
        outArbitrator.set(Message{HungryMsg});
    =}
    
    reaction(finish) -> outArbitrator {=
        outArbitrator.set(Message{ExitMsg});
        outCounterDenied.set(localCounter);
    =}
    
    reaction(inArbitrator) -> outArbitrator, requestToEat, finish {=
        
        if(inArbitrator.get()->type == DeniedMsg) {
            localCounter += 1;
            outArbitrator.set(Message{HungryMsg});
            
        } else if(inArbitrator.get()->type == EatMsg) {
            roundsSoFar += 1;
            outArbitrator.set(Message{DoneMsg});
            
            if(roundsSoFar < rounds) {
                requestToEat.schedule();
            } else {
                finish.schedule();
            }
        } else if(inArbitrator.get()->type == StartMsg) {
            //reset state
            localCounter = 0;
            roundsSoFar = 0;
            
            //start eating
            requestToEat.schedule();
        }
    =}
}

reactor CounterReactor(numLocalCounters:int(20)) {
    
    private preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state counter:long(0);
    state receivedLocalCounts:int(0);
    
    //TODO parametrize
    input[20] inLocalCounters:long;
    input inController:void;
    
    reaction(inController) {=
        //reset local state
        counter = 0L;
        receivedLocalCounts = 0;
    =}
    
    reaction(inLocalCounters) {=
        for(int i = 0; i < inLocalCounters.size(); i++) {
            if(inLocalCounters[i].is_present()) {
                counter += *(inLocalCounters[i].get());
                receivedLocalCounts += 1;
            }
        }
        
        if(receivedLocalCounts >= numLocalCounters) {
            reactor::log::Info() << "Counted: " << counter;
        }
    =}
}

main reactor PhilosopherBenchmark(numIterations:int(12), numEatingRounds:int(10000)) {
    
    arbitrator = new ArbitratorReactor(numPhilosophers=20, numForks=20);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> arbitrator.inStart;
    arbitrator.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("PhilosopherReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "numEatingRounds", numEatingRounds, "numPhilosophers", 20);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    //TODO parametrize
    philosophers = new[20] PhilosopherReactor(rounds=numEatingRounds);
    counter = new CounterReactor(numLocalCounters=20);
    
    arbitrator.outPhilosophers -> philosophers.inArbitrator;
    philosophers.outArbitrator -> arbitrator.inPhilosophers;
    arbitrator.outCounter -> counter.inController;
    philosophers.outCounterDenied -> counter.inLocalCounters;
    
}
