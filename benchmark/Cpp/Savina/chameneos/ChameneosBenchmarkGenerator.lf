/**
 * Micro-benchmark from the Savina benchmark suite. Intended
 * to measure the effects on shared resources (the mailbox of
 * the mall actor) while processing messages in the actor model.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * To break the causality loop the mall reactor contains a logical
 * action.
 * 
 * @author Hannes Klein
 */

/* [[[cog
# This file is a code generator using the python module cog:
# See https://nedbatchelder.com/code/cog/
#
# All instructions for code  generation are in-lined in comments
# like this one. With that you can use this file as a normal source file
# but also to generate code.
# 
# To change the generated code in-line within this file run:
# $ python -m cog -r this-file.lf
# To generate a new file from this file stripping the generator code in the process run:
# $ python -m cog -d -o output-file.lf this-file.lf
#
# Use the command line option -D to specify generator parameters, for example:
# $ python -m cog -r -D parameter=100 this-file.lf
#
# Generator parameters used in this file:
# -D numReactors=5
# 
]]] */
// [[[end]]]

/* [[[cog
  # force existence, type and default values of generator parameters
  if 'numChameneos' in globals():
    numChameneos = int(numChameneos)
  else:
    globals()['numChameneos'] = 5
  
  # output the current value of the generator parameters used in the last generation run
  cog.outl(f'// Generated file with the following parameters:')
  cog.outl(f'// numChameneos = {numChameneos}')
]]] */
// Generated file with the following parameters:
// numChameneos = 5
// [[[end]]]

target Cpp {
    build-type : RelWithDebInfo
};

import BenchmarkRunner from "../BenchmarkRunner.lf";


public preamble {=
    enum Color {
      RED,
      YELLOW,
      BLUE,
      FADED
    };
    
    enum MsgType {
      StartMsg,
      MeetMsg,
      ChangeMsg,
      MeetingCountMsg,
      ExitMsg
    };
    
    struct Message {
      MsgType type;
      Color color;
      int id;
    
      Message() {}
    
      Message(MsgType _type, Color _color, int _id):
        type(_type), color(_color), id(_id) {}
    
      Message(MsgType _type):
        type(_type) {
        // use default values for other members
      }
    };
=}


reactor ChameneosMallReactor(numMeetings:int(200000), numChameneos:int(100)) {
    
    public preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state sumMeetings:int(0);
    state numFaded:int(0);
    state meetings:int(numMeetings);
    state messages:{=std::vector<reactor::ImmutableValuePtr<Message>>=};
    
    state inputs:{=std::vector<reactor::Input<Message>*>=};
    state outputs:{=std::vector<reactor::Output<Message>*>=};
    
    input inStart:void;
    output outFinished:void;
    
    /* [[[cog
      for i in range(numChameneos):
        cog.outl('output outChameneo'+str(i)+':{=Message=};')
    ]]] */
    output outChameneo0:{=Message=};
    output outChameneo1:{=Message=};
    output outChameneo2:{=Message=};
    output outChameneo3:{=Message=};
    output outChameneo4:{=Message=};
    // [[[end]]]

    /* [[[cog
      for i in range(numChameneos):
        cog.outl('input inChameneo'+str(i)+':{=Message=};')
    ]]] */
    input inChameneo0:{=Message=};
    input inChameneo1:{=Message=};
    input inChameneo2:{=Message=};
    input inChameneo3:{=Message=};
    input inChameneo4:{=Message=};
    // [[[end]]]
    
    // logical action to break causality loop
    logical action pairChameneos:void;
    
    reaction(startup) {=
        
        // initializations
        messages = std::vector<reactor::ImmutableValuePtr<Message>>(numChameneos);
        
        // organize inputs and outputs in vectors for easier access
        
        inputs.reserve(numChameneos);
        /* [[[cog
          for i in range(numChameneos):
            cog.outl('inputs.push_back(&inChameneo'+str(i)+');')
        ]]] */
        inputs.push_back(&inChameneo0);
        inputs.push_back(&inChameneo1);
        inputs.push_back(&inChameneo2);
        inputs.push_back(&inChameneo3);
        inputs.push_back(&inChameneo4);
        // [[[end]]]
        
        outputs.reserve(numChameneos);
        /* [[[cog
          for i in range(numChameneos):
            cog.outl('outputs.push_back(&outChameneo'+str(i)+');')
        ]]] */
        outputs.push_back(&outChameneo0);
        outputs.push_back(&outChameneo1);
        outputs.push_back(&outChameneo2);
        outputs.push_back(&outChameneo3);
        outputs.push_back(&outChameneo4);
        // [[[end]]]
    =}
    
    reaction(inStart) ->
      /* [[[cog
        for i in range(numChameneos):
          cog.out('outChameneo'+str(i))
          if i < numChameneos-1:
            cog.outl(',')
          else:
            cog.outl('')
      ]]] */
      outChameneo0,
      outChameneo1,
      outChameneo2,
      outChameneo3,
      outChameneo4
      // [[[end]]]
    {=
        
         // reset local state
         sumMeetings = 0;
         numFaded = 0;
         meetings = numMeetings;
         
         // start execution
         for(int i = 0; i < outputs.size(); i++) {
            outputs[i]->set(Message{StartMsg});
         }
    
    =}
    
    reaction(pairChameneos) ->
      /* [[[cog
        for i in range(numChameneos):
          cog.out('outChameneo'+str(i))
          if i < numChameneos-1:
            cog.outl(',')
          else:
            cog.outl('')
      ]]] */
      outChameneo0,
      outChameneo1,
      outChameneo2,
      outChameneo3,
      outChameneo4
      // [[[end]]]
    {=
        
        int waitingChameneoIndex = -1;
        
        for(int i = 0; i < outputs.size(); ++i) {
            if(messages[i] != nullptr) {
                // Chameneo i present in mall
                if(meetings > 0) {
                    if(waitingChameneoIndex == -1) {
                        waitingChameneoIndex = i;
                    } else {
                        meetings -= 1;
                        reactor::log::Debug() << "setting up meeting " << meetings << " between: " << waitingChameneoIndex << ", " << i;
                        outputs[waitingChameneoIndex]->set(messages[i]);
                        messages[waitingChameneoIndex] = nullptr;
                        messages[i] = nullptr;
                        waitingChameneoIndex = -1;
                    }
               } else {
                    outputs[i]->set(Message{ExitMsg});
               }
            }
        }
    =}
    
    reaction(
        /* [[[cog
          for i in range(numChameneos):
            cog.out('inChameneo'+str(i))
            if i < numChameneos-1:
              cog.outl(',')
            else:
              cog.outl('')

        ]]] */
        inChameneo0,
        inChameneo1,
        inChameneo2,
        inChameneo3,
        inChameneo4
        // [[[end]]]
    ) -> outFinished {=
        
        // detect all chameneos that are present
        for(int i = 0; i < inputs.size(); ++i) {
            if(inputs[i]->is_present()) {
                if(inputs[i]->get()->type == MeetingCountMsg) {
                    numFaded += 1;
                    sumMeetings = sumMeetings + inputs[i]->get()->id; // reuse id field
                    if (numFaded == numChameneos) {
                        outFinished.set();
                        return;
                    }
                } else {
                    messages[i] = inputs[i]->get();
                }
            }
        }
        
        pairChameneos.schedule();
    =}
}

reactor ChameneosChameneoReactor(startColor:{=Color=}({=RED=}), id:int(-1), numChameneos:int(100)) {
    
    public preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state meetings:int(0);
    state color:{=Color=}(startColor);
    
    state inputs:{=std::vector<reactor::Input<Message>*>=};
    state outputs:{=std::vector<reactor::Output<Message>*>=};
    
    input inMall:{=Message=};
    output outMall:{=Message=};
    
    /* [[[cog
      for i in range(numChameneos):
        cog.outl('output outChameneo'+str(i)+':{=Message=};')
    ]]] */
    output outChameneo0:{=Message=};
    output outChameneo1:{=Message=};
    output outChameneo2:{=Message=};
    output outChameneo3:{=Message=};
    output outChameneo4:{=Message=};
    // [[[end]]]
    
    /* [[[cog
      for i in range(numChameneos):
        cog.outl('input inChameneo'+str(i)+':{=Message=};')
    ]]] */
    input inChameneo0:{=Message=};
    input inChameneo1:{=Message=};
    input inChameneo2:{=Message=};
    input inChameneo3:{=Message=};
    input inChameneo4:{=Message=};
    // [[[end]]]
    
    logical action returnToMall:void;
    
    reaction(startup) {=
        
        // organize inputs and outputs in vectors for easier access
        
        inputs.reserve(numChameneos);
        /* [[[cog
          for i in range(numChameneos):
            cog.outl('inputs.push_back(&inChameneo'+str(i)+');')
        ]]] */
        inputs.push_back(&inChameneo0);
        inputs.push_back(&inChameneo1);
        inputs.push_back(&inChameneo2);
        inputs.push_back(&inChameneo3);
        inputs.push_back(&inChameneo4);
        // [[[end]]]
        
        outputs.reserve(numChameneos);
        /* [[[cog
          for i in range(numChameneos):
            cog.outl('outputs.push_back(&outChameneo'+str(i)+');')
        ]]] */
        outputs.push_back(&outChameneo0);
        outputs.push_back(&outChameneo1);
        outputs.push_back(&outChameneo2);
        outputs.push_back(&outChameneo3);
        outputs.push_back(&outChameneo4);
        // [[[end]]]
    =}
    
    reaction(inMall) -> returnToMall, outMall,
      /* [[[cog
        for i in range(numChameneos):
          cog.out('outChameneo'+str(i))
          if i < numChameneos-1:
            cog.outl(',')
          else:
            cog.outl('')
      ]]] */
      outChameneo0,
      outChameneo1,
      outChameneo2,
      outChameneo3,
      outChameneo4
      // [[[end]]]
    {=
        
        if(inMall.get()->type == StartMsg) {
            
            // reset local state
            meetings = 0;
            color = startColor;
            
            // start execution
            outMall.set(Message{MeetMsg, color, id});
            
        } else if(inMall.get()->type == MeetMsg) {
            
            Color otherColor = inMall.get()->color;
            int senderId = inMall.get()->id;
            color = complement(color, otherColor);
            meetings += 1;
            outputs[senderId]->set(Message{ChangeMsg, color, id});
            outMall.set(Message{MeetMsg, color, id});
            
        } else if(inMall.get()->type == ExitMsg) {
            
            color = FADED;
            outMall.set(Message{MeetingCountMsg, color, meetings});
            
        }
    =}
    
    reaction(
        /* [[[cog
          for i in range(numChameneos):
            cog.out('inChameneo'+str(i))
            if i < numChameneos-1:
              cog.outl(',')
            else:
              cog.outl('')

        ]]] */
        inChameneo0,
        inChameneo1,
        inChameneo2,
        inChameneo3,
        inChameneo4
        // [[[end]]]
    ) -> outMall {=
        
        Message message;
        
        // find message
        for(int i = 0; i < inputs.size(); i++) {
            if(inputs[i]->is_present()) {
                message = *(inputs[i]->get());
            }
        }
        
        if(message.type == ChangeMsg) {
            color = message.color;
            meetings += 1;
            outMall.set(Message{MeetMsg, color, id}); // go back to mall
        }
        
    =}
    
    private preamble {=
        
        Color complement(const Color color, const Color otherColor) {
            switch(color) {
              case RED:
                switch(otherColor) {
                  case RED:
                    return RED;
                  case YELLOW:
                    return BLUE;
                  case BLUE:
                    return YELLOW;
                  case FADED:
                    return FADED;
                }
              case YELLOW:
                switch(otherColor) {
                  case RED:
                    return BLUE;
                  case YELLOW:
                    return YELLOW;
                  case BLUE:
                    return RED;
                  case FADED:
                    return FADED;
                }
              case BLUE:
                switch(otherColor) {
                  case RED:
                    return YELLOW;
                  case YELLOW:
                    return RED;
                  case BLUE:
                    return BLUE;
                  case FADED:
                    return FADED;
                }
              case FADED:
                return FADED;
            }
            
           reactor::log::Error() <<
            "Error while calculating the color complement given the two colors " <<
            color << ", " << otherColor << ".";
           return FADED;
        }
        
    =}
}



main reactor ChameneosBenchmark(numIterations:int(12), numMeetings:int(200000)) {
    
    /* [[[cog
      cog.outl('mall = new ChameneosMallReactor(numMeetings=numMeetings, numChameneos='+str(numChameneos)+');')
    ]]] */
    mall = new ChameneosMallReactor(numMeetings=numMeetings, numChameneos=5);
    // [[[end]]]
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> mall.inStart;
    mall.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("ChameneosReactorLFCppBenchmark");
        /* [[[cog
          cog.outl('printArgs("numIterations", numIterations, "numMeetings", numMeetings, "numChameneos", '+str(numChameneos)+');')
        ]]] */
        printArgs("numIterations", numIterations, "numMeetings", numMeetings, "numChameneos", 5);
        /// [[[end]]]
        printSystemInfo();
        runner.inStart.set();
    =}
    
    /* [[[cog
      for i in range(numChameneos):
        cog.outl('chameneo'+str(i)+' = new ChameneosChameneoReactor(startColor={=static_cast<Color>('+str(i)+'%3)=}, id='+str(i)+', numChameneos='+str(numChameneos)+');')
    ]]] */
    chameneo0 = new ChameneosChameneoReactor(startColor={=static_cast<Color>(0%3)=}, id=0, numChameneos=5);
    chameneo1 = new ChameneosChameneoReactor(startColor={=static_cast<Color>(1%3)=}, id=1, numChameneos=5);
    chameneo2 = new ChameneosChameneoReactor(startColor={=static_cast<Color>(2%3)=}, id=2, numChameneos=5);
    chameneo3 = new ChameneosChameneoReactor(startColor={=static_cast<Color>(3%3)=}, id=3, numChameneos=5);
    chameneo4 = new ChameneosChameneoReactor(startColor={=static_cast<Color>(4%3)=}, id=4, numChameneos=5);
    // [[[end]]]
    
    // Connect chamaneos and the mall.
    
    /* [[[cog
      for i in range(numChameneos):
        cog.outl('chameneo'+str(i)+'.outMall -> mall.inChameneo'+str(i)+';')
    ]]] */
    chameneo0.outMall -> mall.inChameneo0;
    chameneo1.outMall -> mall.inChameneo1;
    chameneo2.outMall -> mall.inChameneo2;
    chameneo3.outMall -> mall.inChameneo3;
    chameneo4.outMall -> mall.inChameneo4;
    // [[[end]]]

    /* [[[cog
      for i in range(numChameneos):
        cog.outl('mall.outChameneo'+str(i)+' -> chameneo'+str(i)+'.inMall;')
    ]]] */
    mall.outChameneo0 -> chameneo0.inMall;
    mall.outChameneo1 -> chameneo1.inMall;
    mall.outChameneo2 -> chameneo2.inMall;
    mall.outChameneo3 -> chameneo3.inMall;
    mall.outChameneo4 -> chameneo4.inMall;
    // [[[end]]]
    
    // Connect every Chameneo with every Chameneo.
    
    /* [[[cog
      for i in range(numChameneos):
        for j in range(numChameneos):
          cog.outl(f'chameneo{i}.outChameneo{j} -> chameneo{j}.inChameneo{i};')
        cog.outl('')
    ]]] */
    chameneo0.outChameneo0 -> chameneo0.inChameneo0;
    chameneo0.outChameneo1 -> chameneo1.inChameneo0;
    chameneo0.outChameneo2 -> chameneo2.inChameneo0;
    chameneo0.outChameneo3 -> chameneo3.inChameneo0;
    chameneo0.outChameneo4 -> chameneo4.inChameneo0;

    chameneo1.outChameneo0 -> chameneo0.inChameneo1;
    chameneo1.outChameneo1 -> chameneo1.inChameneo1;
    chameneo1.outChameneo2 -> chameneo2.inChameneo1;
    chameneo1.outChameneo3 -> chameneo3.inChameneo1;
    chameneo1.outChameneo4 -> chameneo4.inChameneo1;

    chameneo2.outChameneo0 -> chameneo0.inChameneo2;
    chameneo2.outChameneo1 -> chameneo1.inChameneo2;
    chameneo2.outChameneo2 -> chameneo2.inChameneo2;
    chameneo2.outChameneo3 -> chameneo3.inChameneo2;
    chameneo2.outChameneo4 -> chameneo4.inChameneo2;

    chameneo3.outChameneo0 -> chameneo0.inChameneo3;
    chameneo3.outChameneo1 -> chameneo1.inChameneo3;
    chameneo3.outChameneo2 -> chameneo2.inChameneo3;
    chameneo3.outChameneo3 -> chameneo3.inChameneo3;
    chameneo3.outChameneo4 -> chameneo4.inChameneo3;

    chameneo4.outChameneo0 -> chameneo0.inChameneo4;
    chameneo4.outChameneo1 -> chameneo1.inChameneo4;
    chameneo4.outChameneo2 -> chameneo2.inChameneo4;
    chameneo4.outChameneo3 -> chameneo3.inChameneo4;
    chameneo4.outChameneo4 -> chameneo4.inChameneo4;

    // [[[end]]]
}
