/**
 * Concurrency benchmark from the Savina benchmark suite.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 * 
 * This implementation is close to the Savina Akka implementation
 * in terms of the work that is done in each actor/reactor and
 * that for each message sent in Savina there is a message send
 * in this implementation. But this implementation does not
 * show the basic idea of the problem in that the waiting
 * room is basically never because the customers arrival is
 * in sync with the barber cutting the hair of customers.
 * 
 * There are some interesting different possibilities to implement the
 * benchmark more based on the original idea behind it instead
 * of the Savina implementation. For example by using threads that
 * trigger events in physical time and handling missed
 * deadlines if the waiting room is full. But these would lack
 * comparability with the Savina benchmark even more.
 * 
 * @author Hannes Klein
 */

target Cpp {
    keepalive : true,
    cmake-include: "SleepingBarberReactorCpp.cmake"
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

reactor CustomerControllerReactor(numHaircuts:int(2000), averageProductionRate:int(1000)) {
    
    public preamble {=
        #include "include/PseudoRandom.hh"
        #include "SleepingBarberCommon.hh"
        #include <list>
    =}
    
    private preamble {=
        #include "reactor-cpp/logging.hh"
    =}
    
    state numHairCutsSoFar:int(0);
    state numAttempts:long(0); // idGenerator in Savina
    state nextCustomerToSendFirstIdx:int(0);
    state customersToReturn:{=std::list<int>=};
    state random:{=PseudoRandom=};
    
    input inStart:void;
    output outFinished:void;
    
    //TODO  parametrize
    output outRoom:{=Message=};
    output outBarber:{=Message=}; // only needed to reset between iterations
    input[2000] inCustomers:{=Message=};
    
    logical action sendCustomersFirstVisit:void;
    logical action sendCustomersToReturn:void;
    logical action exit:void;
    
    reaction(inStart) -> outRoom, outBarber, sendCustomersFirstVisit {=
        
        // reset local state
        numHairCutsSoFar = 0;
        numAttempts = 0;
        nextCustomerToSendFirstIdx = 0;
        customersToReturn.clear();
        random = PseudoRandom();
        
        // send signals to reset
        outBarber.set(Message{ResetMsg});
        outRoom.set(Message{ResetMsg});
        
        // start execution
        sendCustomersFirstVisit.schedule();
    =}
    
    reaction(sendCustomersFirstVisit) -> outRoom, sendCustomersFirstVisit, sendCustomersToReturn {=
        
        if(nextCustomerToSendFirstIdx == numHaircuts) {
            sendCustomersToReturn.schedule();
            return;
        }
        
        numAttempts += 1;
        outRoom.set(Message{EnterMsg, nextCustomerToSendFirstIdx});
        nextCustomerToSendFirstIdx += 1;
        sendCustomersFirstVisit.schedule();
        busyWait(random.nextInt(averageProductionRate) + 10);
    =}
    
    reaction(sendCustomersToReturn) -> outRoom {=
        
        if(customersToReturn.empty()) {
            // wait for finish
            return;
        }
        
        numAttempts += 1;
        outRoom.set(Message{EnterMsg, customersToReturn.front()});
        customersToReturn.pop_front();
        sendCustomersToReturn.schedule();
    =}
    
    reaction(exit) -> outRoom, outBarber, outFinished {=
        
        outRoom.set(Message{ExitMsg});
        outBarber.set(Message{ExitMsg});
        outFinished.set();
    =}
    
    reaction(inCustomers) -> sendCustomersToReturn, exit {=
        
        for(int i = 0; i < inCustomers.size(); i++) {
            if(inCustomers[i].is_present()) {
                if(inCustomers[i].get()->type == ReturnedMsg) {
                    
                    customersToReturn.push_back(i);
                    
                } else if(inCustomers[i].get()->type == DoneMsg) {
                    
                    numHairCutsSoFar += 1;
                    if(numHairCutsSoFar == numHaircuts) {
                        reactor::log::Info() << "Hair cuts given: " << numHairCutsSoFar << "; Total attempts: " << numAttempts;
                        exit.schedule();
                    }
                }
            }
        }
        sendCustomersToReturn.schedule(); //accept to schedule the last time without reason
    =}
    
    private preamble {=
        
        static int busyWait(const int limit) {
            int test = 0;
            
            for(int k = 0; k < limit; ++k) {
                rand();
                ++test;
            }
            
            return test;
        }
    =}
}

reactor CustomerReactor(instance:int(0)) {
    
    public preamble {=
        #include "SleepingBarberCommon.hh"
    =}
    
    output outController:{=Message=};
    input inRoom:{=Message=};
    input inBarber:{=Message=};
    
    reaction(inRoom) -> outController {=
        
        if(inRoom.get()->type == FullMsg) {
            
            outController.set(Message{ReturnedMsg, instance});
            
        } else if(inRoom.get()->type == WaitMsg) {
            
            // do nothing, just sit in the waiting room
        }
    =}
    
    reaction(inBarber) -> outController {=
        
        if(inBarber.get()->type == StartMsg) {
            
            // do nothing, the barber is barbering me now.
            
        } else if(inBarber.get()->type == DoneMsg) {
            
            outController.set(Message{DoneMsg});
            // this reactor is finished and could be destroyed
        }
    =}
}

reactor BarberReactor(averageHaircutRate:int(1000)) {
    
    public preamble {=
        #include "SleepingBarberCommon.hh"
        #include "include/PseudoRandom.hh"
        #include "reactor-cpp/logging.hh"
    =}
    
    state currentCustomerIdx:int(-1);
    state random:{=PseudoRandom=};
    
    //TODO parametrize
    input inRoom:{=Message=};
    input inController:{=Message=};
    output[2000] outCustomers:{=Message=};
    output outRoom:{=Message=};
    
    logical action cutHair:void;
    
    reaction(inController) {=
        
        if(inController.get()->type == ResetMsg) {
            
            // reset local state
            currentCustomerIdx = -1;
            random = PseudoRandom();
            
        }  else if(inController.get()->type == ExitMsg) {
            
            // do nothing
        }
    =}
    
    reaction(cutHair) -> outRoom, outCustomers {=
        
        reactor::log::Debug() << "Cutting hair of customer " << currentCustomerIdx;
        busyWait(random.nextInt(averageHaircutRate) + 10); // doing work inline is overall faster in this benchmark
        outCustomers[currentCustomerIdx].set(Message{DoneMsg});
        currentCustomerIdx = -1;
        outRoom.set(Message{NextMsg});
    =}
    
    reaction(inRoom) -> outCustomers {=
        
        if(inRoom.get()->type == EnterMsg) {
            
            currentCustomerIdx = inRoom.get()->id;
            reactor::log::Debug() << "Barber is serving customer " << currentCustomerIdx;
            outCustomers[currentCustomerIdx].set(Message{StartMsg});
            cutHair.schedule();
            
        } else if(inRoom.get()->type == WaitMsg) {
            
            // do nothing and to to sleep
        }
    =}
    
    private preamble{=
        
        static int busyWait(const int limit) {
            int test = 0;
            
            for(int k = 0; k < limit; ++k) {
                rand();
                ++test;
            }
            
            return test;
        }
    =}
}

reactor WaitingRoomReactor(capacity:int(1000), numCustomers:int(2000)) {
    
    public preamble {=
        #include "SleepingBarberCommon.hh"
        #include "reactor-cpp/logging.hh"
        #include <queue>
    =}
    
    state waitingCustomers:{=std::queue<int>=};
    state barberAsleep:bool(true);
    
    //TODO parametrize
    output[2000] outCustomers:{=Message=};
    input inBarber:{=Message=};
    output outBarber:{=Message=};
    input inController:{=Message=};
    
    logical action wakeBarber:{=Message=};
    
    reaction(inBarber, wakeBarber) -> outBarber {=
        
        if(wakeBarber.is_present() && wakeBarber.get()->type == NextMsg ||
            inBarber.is_present() && inBarber.get()->type == NextMsg) {
            
            if(!waitingCustomers.empty()) {
                int customerIdx = waitingCustomers.front();
                reactor::log::Debug() << "Room is sending customer " << customerIdx << " to the barber.";
                waitingCustomers.pop();
                outBarber.set(Message{EnterMsg, customerIdx});
            } else {
                outBarber.set(Message{WaitMsg});
                barberAsleep = true;
            }
        }
    =}
    
    reaction(inController) -> outCustomers, wakeBarber, outBarber {=
        
        if(inController.get()->type == EnterMsg) {
            
            int customerIdx = inController.get()->id;
            reactor::log::Debug() << "Customer " << customerIdx << " trying to enter.";
            
            if(waitingCustomers.size() == capacity) {
                outCustomers[customerIdx].set(Message{FullMsg});
            } else {
                
                waitingCustomers.push(customerIdx);
                if(barberAsleep) {
                    barberAsleep = false;
                    wakeBarber.schedule(Message{NextMsg, customerIdx});
                } else {
                    outCustomers[customerIdx].set(Message{WaitMsg});
                }
            }
            
        } else if(inController.get()->type == ResetMsg) {
            
            // reset local state
            waitingCustomers = std::queue<int>();
            barberAsleep = true;
            
        } else if(inController.get()->type == ExitMsg) {
            
            // do nothing, controller sends exit msg to barber directly
        }
    =}
}

main reactor SleepingBarberBenchmark(numIterations:int(12), waitingRoomSize:int(1000), averageProductionRate:int(1000), averageHaircutRate:int(1000)) {
    
    controller = new CustomerControllerReactor(numHaircuts=2000, averageProductionRate=averageProductionRate);
    runner = new BenchmarkRunner(numIterations=numIterations);
    
    runner.outIterationStart -> controller.inStart;
    controller.outFinished -> runner.inIterationFinish;
    
    reaction(startup) -> runner.inStart {=
        printBenchmarkInfo("SleepingBarberReactorLFCppBenchmark");
        printArgs("numIterations", numIterations, "waitingRoomSize", waitingRoomSize, "averageProductionRate", averageProductionRate, "averageHaircutRate", averageHaircutRate, "numHaircuts", 2000);
        printSystemInfo();
        runner.inStart.set();
    =}
    
    //TODO parametrize
    room = new WaitingRoomReactor(capacity=waitingRoomSize, numCustomers=2000);
    barber = new BarberReactor(averageHaircutRate=averageHaircutRate);
    customers = new[2000] CustomerReactor();
    
    controller.outRoom -> room.inController;
    controller.outBarber -> barber.inController;
    
    room.outCustomers -> customers.inRoom;
    room.outBarber -> barber.inRoom;
    
    barber.outCustomers -> customers.inBarber;
    barber.outRoom -> room.inBarber;
    
    customers.outController -> controller.inCustomers;
}
