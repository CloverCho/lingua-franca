/**
 * Copyright (C) 2021 TU Dresden
 *
 * Micro-benchmark from the Savina benchmark suite.
 * See documentation in the C++ version.
 *
 * @author ClÃ©ment Fournier
 */

target Rust {
    single-file-project: true,
    build-type: Release,
    cargo-features: ["cli"],
};

import BenchmarkRunner from "../BenchmarkRunner.lf";

main reactor PingPong(count: u32(1000000)) {
    runner = new BenchmarkRunner();

    ping = new Ping(count=count);
    pong = new Pong(expected=count);
    ping.send -> pong.receive;
    pong.send -> ping.receive;
}

reactor Ping(count: u32(1000000)) {
    input receive: u32;
    output send: u32;
    state pingsLeft: u32(count);
    logical action serve;

    reaction(startup, serve) -> send {=
        ctx.set(send, self.pingsLeft);
        self.pingsLeft -= 1;
    =}

    reaction (receive) -> serve {=
        if self.pingsLeft > 0 {
            ctx.schedule(serve, Asap);
        } else {
            ctx.request_stop(Asap);
        }
    =}
}

reactor Pong(expected: u32(1000000)) {
    state expected(expected);

    input receive: u32;
    output send: u32;
    state count: u32(0);

    reaction(receive) -> send {=
        self.count += 1;
        ctx.set(send, ctx.get(receive).unwrap());
    =}

    reaction(shutdown) {=
        assert_eq!(self.count, self.expected);
    =}
}
