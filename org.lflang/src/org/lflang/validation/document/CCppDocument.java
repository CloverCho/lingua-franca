package org.lflang.validation.document;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.lflang.validation.document.DiagnosticAcceptor.Severity;

public class CCppDocument extends GeneratedDocument {

    /** Matches line numbers that occur in line directives. */
    private static final Pattern LINE_NUMBER = Pattern.compile(
        "(#line\\s+)\\b(?<number>\\d+)\\b"
    );// FIXME: Make this more specific and change find() to matches()

    /** Matches error messages generated by GCC. */
    private static final Pattern GCC_ERROR = Pattern.compile(
        "<stdin>:(?<line>\\d+)(:(?<column>\\d+))?: "
            + "(?<severity>error|warning|note): (?<message>[^\n$\r]*)"
    );

    /** Matches tokens in C or C++. */
    private static final Pattern TOKEN = Pattern.compile("\\w+");

    private final String extension;

    /* ------------------------  CONSTRUCTORS  -------------------------- */


    /**
     * Instantiates a <code>CCppDocument</code> with
     * lines of text  and mappings from that text to the
     * source code.
     * @param lines the generated text lines
     * @param sourceMap mappings from positions in the
     *                  generated text to the source code
     * @param directory the directory in which this
     *                  <code>CCppDocument</code> lives
     */
    private CCppDocument(
        List<String> lines,
        NavigableMap<Position, Position> sourceMap,
        File directory,
        String extension
    ) {
        super(lines, sourceMap, directory);
        this.extension = extension;
    }

    /**
     * Returns a CCppDocument instance modeling the file
     * <code>f</code>, or null if <code>f</code> could not
     * be read.
     * @param directory the directory in which this
     *                  <code>CCppDocument</code> lives
     * @param generatedLines the content of a generated C or
     *                       C++ file
     * @return a CCppDocument instance, or null if the file
     * could not be read
     */
    public static CCppDocument getCCppDocument(
        List<String> generatedLines, final File directory, final String extension
    ) {
        NavigableMap<Position, Position> sourceMap = new TreeMap<>();
        // This initial size will be incorrect by only a
        // constant factor of not much more than two, which
        // is not much worse (in terms of space) than the
        // default.
        final List<String> finalTargetLines = new ArrayList<>(generatedLines.size());
        int srcLine = 1; // One-based indexing.
        Matcher lineNumberMatcher;
        for (String line : generatedLines) {
            lineNumberMatcher = LINE_NUMBER.matcher(
                line
            );
            if (lineNumberMatcher.find()) {
                srcLine = Integer.parseInt(lineNumberMatcher.group("number"));
            } else {
                sourceMap.put(
                    Position.fromZeroBased(finalTargetLines.size(), 0),
                    Position.fromOneBased(srcLine, 1)
                );
                finalTargetLines.add(line);
                srcLine++;
            }
        }
        return new CCppDocument(finalTargetLines, sourceMap, directory, extension);
    }

    /* ---------------------  PROTECTED METHODS  ------------------------ */
    @Override
    protected ProcessBuilder getVerificationProcess() {
        return new ProcessBuilder(
            "gcc", "-fsyntax-only",
            "-x", extension,
            "-I", getDirectory().getAbsolutePath(),
            "-"
        );
    }

    /* -----------------------  PRIVATE METHODS  ------------------------ */

    @Override
    protected void addDiagnostic(String line, DiagnosticAcceptor acceptor) {
        final Matcher matcher = GCC_ERROR.matcher(line);
        if (!matcher.matches()) {
            return;
        }
        final int lineNumber = Integer.parseInt(matcher.group("line"));
        final int column = matcher.group("column") == null ? 1 : Integer.parseInt(matcher.group("column"));
        final Position position = adjustPosition(Position.fromOneBased(lineNumber, column));
        final String message = matcher.group("message");
        final DiagnosticAcceptor.Severity severity;
        switch (matcher.group("severity")) {
        case "error":
            severity = Severity.ERROR;
            break;
        case "warning":
            severity = Severity.WARNING;
            break;
        default:
            severity = Severity.INFO;
        }
        final String offendingLine = getLines().get(lineNumber - 1);
        int tokenLength = offendingLine.length() - (column - 1);
        Matcher tokenMatcher = TOKEN.matcher(offendingLine);
        // Uses column - 1 to convert from one-based to zero-based indexing
        if (tokenMatcher.find(column - 1)) tokenLength = tokenMatcher.group().length();
        acceptor.acceptDiagnostic(
            severity,
            message + " (" + lineNumber + ", " + column + ")",
            position,
            position.translated(0, tokenLength)
        ); // FIXME: Provide a correct column delta
    }
}
