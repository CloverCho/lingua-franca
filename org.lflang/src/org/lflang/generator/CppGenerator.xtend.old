/* Generator for Cpp target. */




/*************
 * Copyright (c) 2019-2021, TU Dresden.

 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ***************/
package org.lflang.generator

import com.google.inject.Inject
import java.text.SimpleDateFormat
import java.util.Date
import java.util.LinkedList
import java.util.List
import java.util.stream.IntStream
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.lflang.ASTUtils
import org.lflang.FileConfig
import org.lflang.Target
import org.lflang.TargetProperty.LogLevel
import org.lflang.TimeValue
import org.lflang.lf.Action
import org.lflang.lf.ActionOrigin
import org.lflang.lf.Connection
import org.lflang.lf.Instantiation
import org.lflang.lf.LfPackage
import org.lflang.lf.Model
import org.lflang.lf.Parameter
import org.lflang.lf.Port
import org.lflang.lf.Preamble
import org.lflang.lf.Reaction
import org.lflang.lf.Reactor
import org.lflang.lf.StateVar
import org.lflang.lf.TimeUnit
import org.lflang.lf.Timer
import org.lflang.lf.TriggerRef
import org.lflang.lf.VarRef
import org.lflang.lf.Visibility

import static extension org.lflang.ASTUtils.*
import static extension org.lflang.FileConfig.*
import org.lflang.scoping.LFGlobalScopeProvider

/** Generator for C++ target.
 * 
 *  @author{Christian Menard <christian.menard@tu-dresden.de}
 *  @author{Edward A. Lee <eal@berkeley.edu>}
 *  @author{Marten Lohstroh <marten@berkeley.edu>}
 */
class CppGenerator extends GeneratorBase {

    override printInfo() {
        super.printInfo()
        println('******** generated binaries: ' + fileConfig.binPath)
    }

    def extractDir(String path) {
        var result = path
        if (path.startsWith('platform:')) {
            result = result.substring(9)
        }
        if (path.startsWith('file:')) {
            result = result.substring(5)
        }
        var lastSlash = result.lastIndexOf('/')
        if (lastSlash >= 0) {
            result = result.substring(0, lastSlash)
        }
        return result
    }
    
    /**
     * If the argument is a multiport with width given as an integer,
     * then return that integer. Otherwise, through an exception for
     * now. FIXME: Support parameters for widths.
     * @param port The port. 
     */
    protected def int multiportWidth(Port port) {
        val spec = multiportWidthSpec(port)
        if (spec !== null && spec.length === 1) {
            if(port.widthSpec.terms.get(0).parameter === null) {
                return port.widthSpec.terms.get(0).width
            }
        }
        throw new Exception("Only multiport widths with literal integer values are supported for now.")
    }

    def declareDeadlineHandlers(Reactor r) '''
        «FOR n : r.reactions.filter([Reaction x | x.deadline !== null]) BEFORE '// local deadline handlers\n' AFTER '\n'»
            void «n.name»_deadline_handler();
        «ENDFOR»
    '''

    def implementReactionDeadlineHandlers(Reactor r) '''
        «FOR n : r.reactions.filter([Reaction x | x.deadline !== null]) BEFORE '\n' SEPARATOR '\n'»
            // deadline handler for reaction «n.label»
            «IF r.isGeneric»«r.templateLine»«ENDIF»
            void «r.templateName»::«n.name»_deadline_handler() {
              «n.deadline.code.toText»
            }
        «ENDFOR»
    '''


    // //////////////////////////////////////////////
    // // Protected methods

    /**
     * Generate code for the body of a reaction that takes an input and
     * schedules an action with the value of that input.
     * @param the action to schedule
     * @param the port to read from
     */
    override generateDelayBody(Action action, VarRef port) {
        // Since we cannot easily decide whether a given type evaluates
        // to void, we leave this job to the target compiler, by calling
        // the template function below.
        '''
            // delay body for «action.name»
            lfutil::after_delay(&«action.name», &«port.name»);
        '''
    }

    /**
     * Generate code for the body of a reaction that is triggered by the
     * given action and writes its value to the given port.
     * @param the action that triggers the reaction
     * @param the port to write to
     */
    override generateForwardBody(Action action, VarRef port) // Since we cannot easily decide whether a given type evaluates
    // to void, we leave this job to the target compiler, by calling
    // the template function below.
    '''
        // forward body for «action.name»
        lfutil::after_forward(&«action.name», &«port.name»);
    '''

    /** Given a representation of time that may possibly include units,
     *  return a string that C++ recognizes as a time value.
     * 
     *  @param time A TimeValue that represents a time.
     *  @return A string, such as "100ms" for 100 milliseconds.
     */
    override timeInTargetLanguage(TimeValue time) {
        if (time !== null) {
            if (time.unit != TimeUnit.NONE) {
                return time.time.toString() + timeUnitsToCppUnits.get(time.unit)
            } else if (time.time == 0) {
                return '''reactor::Duration::zero()'''
            } else {
                return '''/* «reportError("Valid times must be zero or have a unit!")» */'''
            }
        }
        return '''/* «reportError("Expected a time")» */'''
    }

    override getTargetTimeType() '''reactor::Duration'''

    override getTargetTagType() '''reactor::Tag'''

    override getTargetTagIntervalType() {
        return getTargetUndefinedType()
    }

    override getTargetUndefinedType() '''/* «reportError("undefined type")» */'''

    // this override changes the undefined type for actions to void
    override getTargetType(Action a) {
        val inferred = a.inferredType;
        if (inferred.isUndefined) {
            return "void"
        } else {
            return inferred.targetType
        }
    }

    override getTargetFixedSizeListType(String baseType,
        Integer size) '''std::array<«baseType», «size.toString»>'''

    override getTargetVariableSizeListType(
        String baseType) '''std::vector<«baseType»>'''
        
    override supportsGenerics() {
        true
    }
    
    override String generateDelayGeneric()
        '''T'''
        
    override getTarget() {
        return Target.CPP
    }
    
}
