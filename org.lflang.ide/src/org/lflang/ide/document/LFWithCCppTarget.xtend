package org.lflang.ide.document

import org.eclipse.xtext.resource.XtextResource
import org.eclipse.xtext.ide.server.Document
import org.eclipse.lsp4j.Diagnostic
import org.eclipse.lsp4j.DiagnosticSeverity
import org.eclipse.lsp4j.Position

import java.util.List
import java.util.ArrayList
import java.util.regex.Pattern
import java.util.regex.Matcher
import java.io.BufferedReader
import java.io.InputStreamReader
import org.eclipse.lsp4j.Range

import org.apache.log4j.Logger
import org.eclipse.lsp4j.services.LanguageServer

/**
 * Represents an LFDocument whose target language is C or C++.
 */
class LFWithCCppTarget extends LFDocument {
		
	/** Matches line numbers that occur in line directives. */
	val static Pattern LINE_NUMBER = Pattern.compile(
		'(?<=\\#line\\s+)\\b(\\d+)\\b'
	)
	
	/** Matches error messages generated by GCC. */
	val static Pattern GCC_ERROR = Pattern.compile(
		'<stdin>:(?<line>\\d+)(:(?<column>\\d+))?: '
		+ '(?<severity>error|warning|note): (?<message>[^\n$\r]*)'
	)
	
	/** ------------------------  CONSTRUCTORS  -------------------------- */
	
	/**
	 * Initializes an LFWithCCppTarget corresponding to resource with the
	 * contents of document.
	 * @param resource the LF file whose contents and semantics are modeled
	 *     by this LFWithCCppTarget
	 * @param document the document whose contents and semantics are modeled
	 *     by this LFWithCCppTarget
	 */
	new(XtextResource resource, Document document) {
		super(resource, document)
	}
	
	/**
	 * Initializes an LFWithCCppTarget whose lines are contents corresponding
	 * to resource.
	 * @param resource the LF file whose contents and semantics are modeled
	 *     by this LFWithCCppTarget
	 * @param contents the lines of code in the LF file whose contents and
	 *     semantics are modeled by this LFWithCCppTarget
	 */
	new(XtextResource resource, String[] contents) {
		super(resource, contents)
	}
	
	/** ---------------------  PROTECTED METHODS  ------------------------ */
	
	override protected void updateTargetLinesAndSourceMap() {
		// Update target lines
		targetLines = compile
		// Update source map
		sourceMap.clear
		val String[] finalTargetLines = newArrayOfSize(targetLines.length)
		var srcLine = 0
		var finalTargetLine = 0
		var Matcher lineNumberMatcher
		for (
			var targetLine = 0; targetLine < targetLines.length; targetLine++
		) {
			lineNumberMatcher = LINE_NUMBER.matcher(
				targetLines.get(targetLine)
			)
			if (lineNumberMatcher.find) { // FIXME should match exactly, not just find
				srcLine = Integer.parseInt(lineNumberMatcher.group) - 1 // Zero indexing
			} else {
				sourceMap.put(
					new Position(finalTargetLine, 0),
					new Position(srcLine, 0)
				)
				finalTargetLines.set(finalTargetLine, targetLines.get(targetLine))
				finalTargetLine++
				srcLine++
			}
		}
		targetLines = newArrayOfSize(finalTargetLine)
		System.arraycopy(finalTargetLines, 0, targetLines, 0, finalTargetLine)
	}
	
	override protected List<Diagnostic> getDiagnostics() {
		val echo = new ProcessBuilder("echo", combinedTargetLines)
		val gcc = new ProcessBuilder(
			'gcc', '-fsyntax-only',
			'-x', target.extension,
			'-I', getOutFile.getParentFile.absolutePath,
			'-'
		)
		val List<ProcessBuilder> pipeline = new ArrayList<ProcessBuilder>
		pipeline.add(echo)
		pipeline.add(gcc)
		val List<Process> processes = ProcessBuilder.startPipeline(pipeline)
		LOG.debug('target.extension=' + target.extension)
		LOG.debug('indft in target lines? ' + combinedTargetLines.contains('indft'))
		LOG.debug('Echoing string starting with ' + combinedTargetLines.substring(0, 1000))
		val BufferedReader reader = new BufferedReader(
			new InputStreamReader(processes.get(1).getErrorStream())
		)
		val diagnostics = new ArrayList<Diagnostic>
		var String line;
		LOG.debug('Getting diagnostics...')
		while ((line = reader.readLine()) !== null) {
			LOG.debug(line)
			addDiagnostic(line, diagnostics);
		}
		return diagnostics
	}
	
	/** -----------------------  PRIVATE METHODS  ------------------------ */
	
	/**
	 * Searches line for a diagnostic and, if one is found, adds it to
	 * diagnostics.
	 * @param line a line of the GCC error stream for a document
	 * @param diagnostics the list of diagnostics to which any new diagnostics
	 *     should be added
	 */
	def private void addDiagnostic(String line, List<Diagnostic> diagnostics) {
		val Matcher matcher = GCC_ERROR.matcher(line)
		if (!matcher.matches) {
			return
		}
		LOG.debug('Diagnostics line matches expected pattern: ' + line)
		val lineNumber = Integer.parseInt(matcher.group("line")) - 1 // Zero indexing
		LOG.debug('')
		var Range range
		if (matcher.group("column") === null) {
			range = new Range(
				adjustPosition(new Position(lineNumber, 0)),
				adjustPosition(new Position(lineNumber, line.length)) // FIXME: off-by-one error?
			)
		} else {
			val column = Integer.parseInt(matcher.group("column")) - 1 // Zero indexing
			range = new Range(
				adjustPosition(new Position(lineNumber, column)),
				adjustPosition(new Position(lineNumber, line.length)) // FIXME: end at token end?
			)
		}
		val message = matcher.group("message")
		// GCC gives only 3 distinct severity levels instead of 4? TODO verify.
		var DiagnosticSeverity severity = switch (matcher.group("severity")) {
			case "error": DiagnosticSeverity.Error
			case "warning": DiagnosticSeverity.Warning
			default: DiagnosticSeverity.Hint
		}
		diagnostics.add(new Diagnostic(
			range, message, severity, "gcc"
		))
	}
	
}