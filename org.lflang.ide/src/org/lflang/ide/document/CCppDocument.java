package org.lflang.ide.document;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.Position;
import org.eclipse.lsp4j.Range;

public class CCppDocument extends GeneratedDocument {

    /** Matches line numbers that occur in line directives. */
    private static final Pattern LINE_NUMBER = Pattern.compile(
        "(#line\\s+)\\b(?<number>\\d+)\\b"
    );// FIXME: Make this more specific and change find() to matches()

    /** Matches error messages generated by GCC. */
    private static final Pattern GCC_ERROR = Pattern.compile(
        "<stdin>:(?<line>\\d+)(:(?<column>\\d+))?: "
            + "(?<severity>error|warning|note): (?<message>[^\n$\r]*)"
    );

    private final String extension;

    /* ------------------------  CONSTRUCTORS  -------------------------- */


    /**
     * Instantiates a <code>CCppDocument</code> with
     * lines of text  and mappings from that text to the
     * source code.
     * @param lines the generated text lines
     * @param sourceMap mappings from positions in the
     *                  generated text to the source code
     * @param directory the directory in which this
     *                  <code>CCppDocument</code> lives
     */
    private CCppDocument(
        List<String> lines,
        NavigableMap<Position, Position> sourceMap,
        File directory,
        String extension
    ) {
        super(lines, sourceMap, directory);
        this.extension = extension;
    }

    /**
     * Returns a CCppDocument instance modeling the file
     * <code>f</code>, or null if <code>f</code> could not
     * be read.
     * @param directory the directory in which this
     *                  <code>CCppDocument</code> lives
     * @param generatedLines the content of a generated C or
     *                       C++ file
     * @return a CCppDocument instance, or null if the file
     * could not be read
     */
    public static CCppDocument getCCppDocument(List<String> generatedLines, File directory, String extension) {
        NavigableMap<Position, Position> sourceMap = new TreeMap<>(new PositionComparator());
        // Update source map
        sourceMap.clear();
        // This initial size will be incorrect by only a
        // constant factor of not much more than two, which
        // is not much worse (in terms of space) than the
        // default.
        final List<String> finalTargetLines = new ArrayList<>(generatedLines.size());
        int srcLine = 0;
        Matcher lineNumberMatcher;
        for (String line : generatedLines) {
            lineNumberMatcher = LINE_NUMBER.matcher(
                line
            );
            if (lineNumberMatcher.find()) {
                // Decrement to convert from 1-based to 0-based indexing
                srcLine = Integer.parseInt(lineNumberMatcher.group("number")) - 1;
            } else {
                sourceMap.put(
                    new Position(finalTargetLines.size(), 0),
                    new Position(srcLine, 0)
                );
                finalTargetLines.add(line);
                srcLine++;
            }
        }
        return new CCppDocument(finalTargetLines, sourceMap, directory, extension);
    }

    /* ---------------------  PROTECTED METHODS  ------------------------ */
    @Override
    protected ProcessBuilder getVerificationProcess() {
        return new ProcessBuilder(
            "gcc", "-fsyntax-only",
            "-x", extension,
            "-I", getDirectory().getAbsolutePath(),
            "-"
        );
    }

    /* -----------------------  PRIVATE METHODS  ------------------------ */

    @Override
    protected void addDiagnostic(String line, List<Diagnostic> diagnostics) {
        final Matcher matcher = GCC_ERROR.matcher(line);
        if (!matcher.matches()) {
            return;
        }
        LOG.debug("Diagnostics line matches expected pattern: " + line);
        // Decrement to convert from 1-based to 0-based indexing
        final int lineNumber = Integer.parseInt(matcher.group("line")) - 1;
        final int column;
        Range range;
        if (matcher.group("column") == null) {
            column = 0;
        } else {
            // Decrement to convert from 1-based to 0-based indexing
            column = Integer.parseInt(matcher.group("column")) - 1;
        }
        range = new Range(
            adjustPosition(new Position(lineNumber, column)),
            adjustPosition(new Position(lineNumber, line.length())) // FIXME: end at token end?
        );
        final String message = matcher.group("message");
        // GCC gives only 3 distinct severity levels instead of 4? TODO: verify.
        final DiagnosticSeverity severity;
        switch (matcher.group("severity")) {
        case "error":
            severity = DiagnosticSeverity.Error;
            break;
        case "warning":
            severity = DiagnosticSeverity.Warning;
            break;
        default:
            severity = DiagnosticSeverity.Hint;
        }
        diagnostics.add(new Diagnostic(
            range, message, severity, "gcc"
        ));
    }
}
