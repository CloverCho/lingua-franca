package org.lflang.ide.document;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.Position;
import org.eclipse.lsp4j.Range;

public class CCppDocument extends GeneratedDocument {

    /** Matches line numbers that occur in line directives. */
    private static final Pattern LINE_NUMBER = Pattern.compile(
        "(#line\\s+)\\b(?<number>\\d+)\\b"
    );// FIXME: Make this more specific and change find() to matches()

    /** Matches error messages generated by GCC. */
    private static final Pattern GCC_ERROR = Pattern.compile(
        "<stdin>:(?<line>\\d+)(:(?<column>\\d+))?: "
            + "(?<severity>error|warning|note): (?<message>[^\n$\r]*)"
    );

    /* ------------------------  CONSTRUCTORS  -------------------------- */


    /**
     * Instantiates a <code>CCppDocument</code> with
     * lines of text  and mappings from that text to the
     * source code.
     * @param lines the generated text lines
     * @param sourceMap mappings from positions in the
     *                  generated text to the source code
     */
    public CCppDocument(List<String> lines, NavigableMap<Position, Position> sourceMap) {
        super(lines, sourceMap);
    }

    /**
     * Returns a CCppDocument instance modeling the file
     * <code>f</code>, or null if <code>f</code> could not
     * be read.
     * @param generatedLines the content of a generated C or
     *                       C++ file
     * @return a CCppDocument instance, or null if the file
     * could not be read
     */
    public static CCppDocument getCCppDocument(List<String> generatedLines) {
        NavigableMap<Position, Position> sourceMap = new TreeMap<>(new PositionComparator());
        // Update source map
        sourceMap.clear();
        // This initial size will be incorrect by only a
        // constant factor of not much more than two, which
        // is not much worse (in terms of space) than the
        // default.
        final List<String> finalTargetLines = new ArrayList<>(generatedLines.size());
        int srcLine = 0;
        Matcher lineNumberMatcher;
        for (String line : generatedLines) {
            lineNumberMatcher = LINE_NUMBER.matcher(
                line
            );
            if (lineNumberMatcher.find()) {
                // Decrement to convert from 1-based to 0-based indexing
                srcLine = Integer.parseInt(lineNumberMatcher.group("number")) - 1;
            } else {
                sourceMap.put(
                    new Position(finalTargetLines.size(), 0),
                    new Position(srcLine, 0)
                );
                finalTargetLines.add(line);
                srcLine++;
            }
        }
        return new CCppDocument(finalTargetLines, sourceMap);
    }

    /* -----------------------  PUBLIC METHODS  ------------------------- */
    // FIXME: Account for the possibility of one target document with multiple sources?
    @Override
    public List<Diagnostic> getDiagnostics(File workingDir, String extension) throws IOException {
        final ProcessBuilder echo = new ProcessBuilder(
            "echo", getCombinedLines()
        );
        final ProcessBuilder gcc = new ProcessBuilder(
            "gcc", "-fsyntax-only",
            "-x", extension,
            "-I", workingDir.getAbsolutePath(),
            "-"
        );
        final List<ProcessBuilder> pipeline = new ArrayList<>();
        pipeline.add(echo);
        pipeline.add(gcc);
        final List<Process> processes = ProcessBuilder.startPipeline(pipeline);
        final BufferedReader reader = new BufferedReader(
            new InputStreamReader(processes.get(1).getErrorStream())
        );
        final List<Diagnostic> diagnostics = new ArrayList<>();
        String line;
        LOG.debug("Getting diagnostics...");
        while ((line = reader.readLine()) != null) {
            LOG.debug(line);
            addDiagnostic(line, diagnostics);
        }
        return diagnostics;
    }

    /* -----------------------  PRIVATE METHODS  ------------------------ */

    /**
     * Searches line for a diagnostic and, if one is found, adds it to
     * diagnostics.
     * @param line a line of the GCC error stream for a document
     * @param diagnostics the list of diagnostics to which any new diagnostics
     *     should be added
     */
    private void addDiagnostic(String line, List<Diagnostic> diagnostics) {
        final Matcher matcher = GCC_ERROR.matcher(line);
        if (!matcher.matches()) {
            return;
        }
        LOG.debug("Diagnostics line matches expected pattern: " + line);
        // Decrement to convert from 1-based to 0-based indexing
        final int lineNumber = Integer.parseInt(matcher.group("line")) - 1;
        Range range;
        if (matcher.group("column") == null) {
            range = new Range(
                adjustPosition(new Position(lineNumber, 0)),
                adjustPosition(new Position(lineNumber, line.length())) // FIXME: off-by-one error?
            );
        } else {
            // Decrement to convert from 1-based to 0-based indexing
            final int column = Integer.parseInt(matcher.group("column")) - 1;
            range = new Range(
                adjustPosition(new Position(lineNumber, column)),
                adjustPosition(new Position(lineNumber, line.length())) // FIXME: end at token end?
            );
        }
        final String message = matcher.group("message");
        // GCC gives only 3 distinct severity levels instead of 4? TODO: verify.
        final DiagnosticSeverity severity;
        switch (matcher.group("severity")) {
        case "error":
            severity = DiagnosticSeverity.Error;
            break;
        case "warning":
            severity = DiagnosticSeverity.Warning;
            break;
        default:
            severity = DiagnosticSeverity.Hint;
        }
        diagnostics.add(new Diagnostic(
            range, message, severity, "gcc"
        ));
    }
}
