package org.lflang.ide.document;

import org.lflang.ide.DocumentRegistry;
import org.lflang.generator.Main;

import org.apache.log4j.Logger;

import org.eclipse.lsp4j.services.LanguageServer;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ide.server.Document;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.nio.file.Files;
import java.io.File;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.io.PrintWriter;

import com.google.common.base.Joiner;
import com.google.common.io.MoreFiles;

/**
 * Represents a Lingua Franca document.
 */
public class LFDocument {

    protected static final Logger LOG = Logger.getLogger(LanguageServer.class);

    /**
     * Represents a unique identifier for an LFDocument
     * according to its absolute file system location and
     * target language.
     */
    public static class ID {

        private static final Pattern TARGET_PATTERN = Pattern.compile(
            "(\\btarget\\s+)\\b(?<language>"
                + Joiner.on("|").join(TargetLanguage.values())
                + ")\\b"
        );

        final File file;
        final TargetLanguage target;

        /**
         * Creates a unique identifier corresponding to the
         * given document.
         * @param resource the <code>XtextResource</code>
         *                 that determines the document's
         *                 location in the file system
         * @param document the <code>Document</code> that
         *                 determines the document's target
         *                 language
         */
		public ID(XtextResource resource, Document document) {
            // FIXME: Bad space complexity. Should use an iterator.
            this(resource, getLines(document));
        }

        /**
         * Creates a unique identifier corresponding to the
         * given document.
         * @param resource the <code>XtextResource</code>
         *                 that determines the document's
         *                 file system location
         * @param contents the lines of the Document that
         *                 determine the document's target
         *                 language
         */
		public ID(XtextResource resource, List<String> contents) {
            // FIXME: This is very flimsy. What if someone writes "target C"
            //  before the real target declaration and then comments it out?
            file = resource.getURI().isFile() ?
                   new File(resource.getURI().toFileString()) : null;
            String result = null;
            Matcher matcher;
            for (String line : contents) {
                matcher = TARGET_PATTERN.matcher(line);
                if (matcher.find()) {
                    result = matcher.group("language");
                    break;
                }
            }
            target = TargetLanguage.fromString(result);
        }

        /**
         * Returns whether this <code>LFDocument.ID</code> is
         * equal to <code>other</code>. This is true iff
         * <code>other</code> is an <code>LFDocument.ID</code>
         * corresponding to the same file system location
         * and the same target language, even if the original
         * representation of the file system location is
         * different.
         * @param other the object against which this ID is
         *              to be compared
         * @return whether this ID is equal to
         * <code>other</code>
         */
        @Override
        public boolean equals(Object other) {
            if (!(other instanceof LFDocument.ID)) {
                return false;
            }
            return ((LFDocument.ID) other).target == target
                && ((LFDocument.ID) other).file.equals(file);
        }

        /**
         * Returns the target language of the LF file
         * identified by this ID.
         */
        public TargetLanguage getTarget() {
            return target;
        }

        @Override
        public String toString() {
            return "<LF File at " + file.toString() + " with target language " + target.toString() + ">";
        }
    }

    /**
     * The <code>XtextResource</code> representation of
     * this document
     */
    private final XtextResource resource;
    /** The content of this document */
    private List<String> lines;
    /** Models of the documents generated by this document */
    private final Map<File, GeneratedDocument> generatedDocuments;
    /** The unique identifier of this document */
    private final ID id;

    /* ------------------------  CONSTRUCTORS  -------------------------- */

    /**
     * Initializes an <code>LFDocument</code> corresponding
     * to <code>resource</code> with the contents
     * of <code>document</code>.
     * @param resource the LF file whose contents and
     *                 semantics are modeled by this
     *                 <code>LFDocument</code>
     * @param document the document whose contents and
     *                 semantics are modeled by this
     *                 <code>LFDocument</code>
     */
	public LFDocument(XtextResource resource, Document document) {
        this(resource, getLines(document));
    }

    /**
     * Initializes an <code>LFDocument</code>.
     * @param resource the LF file whose contents and
     *                 semantics are modeled by this
     *                 <code>LFDocument</code>
     * @param contents the lines of code in the LF file
     *                 whose contents and semantics are
     *                 modeled by this <code>LFDocument
     *                 </code>
     */
	public LFDocument(XtextResource resource, List<String> contents) {
        this.resource = resource;
        this.lines = contents;
        generatedDocuments = new HashMap<>();
        id = new ID(resource, contents);
    }

    /* -----------------------  PUBLIC METHODS  ------------------------- */

    /**
     * Updates the model of the document represented by this
     * <code>LFDocument</code>.
     * Updates the client with any diagnostics associated
     * with this <code>LFDocument</code>.
     */
    public void refresh(Document document) {
        if (!attemptQuickUpdate(document)) {
            LOG.debug("Quick update failed. Attempting complete update...");
            // FIXME: Redundant work with attemptQuickUpdate?
            lines = getLines(document);
            try {
                compile();
            } catch (IOException e) {
                LOG.error("Failed to compile LF document " + this + ".", e);
                return;
            }
            findGeneratedDocuments();
        }
        final List<Diagnostic> foundDiagnostics = new ArrayList<>();
        for (Map.Entry<File, GeneratedDocument> entry : generatedDocuments.entrySet()) {
            LOG.debug("Getting diagnostics from generated document " + entry.getKey());
            try {
                foundDiagnostics.addAll(entry.getValue().getDiagnostics(
                    entry.getKey().getParentFile(),
                    getExtension(entry.getKey())
                )); // FIXME: Must include Xtext-provided diagnostics
            } catch (IOException e) {
                LOG.error("Failed to compute diagnostics for " + this + ".", e);
            }
        }
        LOG.debug("Found " + foundDiagnostics.size() + " diagnostics: " + foundDiagnostics); // TODO remove
        DocumentRegistry.getInstance().publishDiagnostics(
            resource, foundDiagnostics
        );
    }

    /**
     * Returns the target language of this LFDocument.
     * @return the target language of this LFDocument
     */
    public TargetLanguage getTarget() {
        return id.target;
    }

    /* -----------------------  PRIVATE METHODS  ------------------------ */

    /**
     * Updates document models to match the LF source code.
     * Returns true iff changes to the document
     * could be resolved without ambiguity. Otherwise, does
     * nothing and returns false.
     */
    private boolean attemptQuickUpdate(Document document) {
        return false; // Not yet implemented
    }

    /**
     * Extracts a list of lines from a Document.
     * @param document a document containing the desired
     *                 content
     * @return all lines in the document
     */
    private static List<String> getLines(Document document) {
        final List<String> contents = new ArrayList<>(document.getLineCount());
        // FIXME: Quadratic time!!! because the implementation of
        //  Document.getLineContent(i) is linear wrt the length of
        //  the document, up to the ith line. This is the
        //  unacceptable cost of staying DRY.
        for (var i = 0; i < document.getLineCount(); i++) {
            contents.add(document.getLineContent(i));
        }
        return contents;
    }

    /**
     * Returns the Lingua Franca file location used for
     * compilation.
     */
    private File getSrcFile() {
        final File f = new File(
            new File(getCompileDir(), "src"), id.file.getName()
        );
        f.getParentFile().mkdirs();
        return f;
    }

    /**
     * Returns the target language file produced by
     * compilation.
     */
    private File getOutDir() {
        return new File(getCompileDir(), "src-gen");
    }

    /**
     * Returns the working directory for any temporary files
     * needed for compilation.
     */
    private File getCompileDir() {
        // FIXME: I am not sure whether this ought to be cached rather than
        //  re-computed each time. Caching is more complex because it creates
        //  more state to keep track of, but it also feels silly to re-compute
        //  this.
        final File compileDir = DocumentRegistry.getInstance().getSaveLocation(
            new File(
                id.file.getParentFile(),
                id.file.getName().replace(".", "_dot_")
            )
        );
        compileDir.mkdirs();
        LOG.debug("Compile directory: " + compileDir.getAbsolutePath());
        return compileDir;
    }

    /**
     * Compiles this to its target language and saves the
     * result in <code>lines</code>.
     */
    private void compile() throws IOException {
        // FIXME: It is surprising that it is necessary to delete the directory, but it is:
        //  If it is not deleted, the LF compiler will crash because lib files already exist.
        if (getCompileDir().exists()) {
            MoreFiles.deleteRecursively(getCompileDir().toPath()); // This function is in beta.
        }
        final PrintWriter writer = new PrintWriter(getSrcFile()); // FIXME: Do not create a new file?
        for (String lfLine : lines) {
            writer.println(lfLine);
        }
        writer.close();
        Main.main(new String[] {
            "--no-compile",
            getSrcFile().getAbsolutePath()
        });
    }

    /**
     * Returns the file extension that appears at the end of
     * <code>f</code>.
     * @param f a file
     * @return the file extension that appears at the end of
     * <code>f</code>
     */
    private static String getExtension(File f) {
        if (!f.isFile()) return "";
        String name = f.getName();
        int dotIdx = name.lastIndexOf('.');
        return dotIdx == -1 ? "" : name.substring(dotIdx + 1);
    }


    /**
     * Re-discovers and instantiates models of any generated
     * documents present in the file system.
     */
    private void findGeneratedDocuments() {
        generatedDocuments.clear();
        // FIXME: 2 here is a magic number. Justify it or
        //  replace it with a static final list of excluded
        //  directories.
        findGeneratedDocumentsRecursive(getOutDir(), 2);
    }

    /**
     * Finds any generated files that are at most <code>
     * maxDepth</code> levels below <code>f</code>. Intended
     * only to be called by <code>findGeneratedDocuments
     * </code>.
     */
    private void findGeneratedDocumentsRecursive(File f, int maxDepth) {
        if (maxDepth < 0) return;
        if (f.isFile()) {
            try { // FIXME: Check if generated document has mappings to this LFDocument
                final GeneratedDocument g = GeneratedDocumentFactory.getGeneratedDocument(
                    Files.readAllLines(f.toPath()), getExtension(f)
                );
                if (g != null) generatedDocuments.put(f, g);
            } catch (IOException e) {
                LOG.error("Failed to read " + f + ".", e);
            }
        } else {
            File[] children = f.listFiles();
            assert children != null;
            for (File c : children) {
                findGeneratedDocumentsRecursive(c, maxDepth - 1);
            }
        }
    }
}
