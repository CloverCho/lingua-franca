package org.lflang.ide.document;

import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ide.server.Document;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.DiagnosticSeverity;
import org.eclipse.lsp4j.Position;

import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.eclipse.lsp4j.Range;

/**
 * Represents an LFDocument whose target language is C or C++.
 */
public class LFWithCCppTarget extends LFDocument {

    /** Matches line numbers that occur in line directives. */
    private static final Pattern LINE_NUMBER = Pattern.compile(
        "(#line\\s+)\\b(?<number>\\d+)\\b"
    );// FIXME make this more specific and change find() to matches()

    /** Matches error messages generated by GCC. */
    private static final Pattern GCC_ERROR = Pattern.compile(
        "<stdin>:(?<line>\\d+)(:(?<column>\\d+))?: "
            + "(?<severity>error|warning|note): (?<message>[^\n$\r]*)"
    );

    /* ------------------------  CONSTRUCTORS  -------------------------- */

    /**
     * Initializes an LFWithCCppTarget corresponding to resource with the
     * contents of document.
     * @param resource the LF file whose contents and semantics are modeled
     *     by this LFWithCCppTarget
     * @param document the document whose contents and semantics are modeled
     *     by this LFWithCCppTarget
     */
	public LFWithCCppTarget(XtextResource resource, Document document) {
        super(resource, document);
    }

    /**
     * Initializes an LFWithCCppTarget whose lines are contents corresponding
     * to resource.
     * @param resource the LF file whose contents and semantics are modeled
     *     by this LFWithCCppTarget
     * @param contents the lines of code in the LF file whose contents and
     *     semantics are modeled by this LFWithCCppTarget
     */
    public LFWithCCppTarget(XtextResource resource, List<String> contents) {
        super(resource, contents);
    }

    /* ---------------------  PROTECTED METHODS  ------------------------ */

    @Override
    protected void updateTargetLinesAndSourceMap() {
        // Update target lines
        try {
            targetLines = compile();
        } catch (IOException e) {
            LOG.error("Failed to compile " + this + ". Aborting.", e);
            return;
        }
        // Update source map
        sourceMap.clear();
        final List<String> finalTargetLines = new ArrayList<>(targetLines.size());
        int srcLine = 0;
        Matcher lineNumberMatcher;
        for (String line : targetLines) {
            lineNumberMatcher = LINE_NUMBER.matcher(
                line
            );
            if (lineNumberMatcher.find()) {
                // Decrement to convert from 1-based to 0-based indexing
                srcLine = Integer.parseInt(lineNumberMatcher.group("number")) - 1;
            } else {
                sourceMap.put(
                    new Position(finalTargetLines.size(), 0),
                    new Position(srcLine, 0)
                );
                finalTargetLines.add(line);
                srcLine++;
            }
        }
        targetLines = finalTargetLines;
    }

    @Override
    protected List<Diagnostic> getDiagnostics() throws IOException {
        final ProcessBuilder echo = new ProcessBuilder(
            "echo", getCombinedTargetLines()
        );
        final ProcessBuilder gcc = new ProcessBuilder(
            "gcc", "-fsyntax-only",
            "-x", getTarget().getExtension(),
            "-I", getOutFile().getParentFile().getAbsolutePath(),
            "-"
        );
        final List<ProcessBuilder> pipeline = new ArrayList<>();
        pipeline.add(echo);
        pipeline.add(gcc);
        final List<Process> processes = ProcessBuilder.startPipeline(pipeline);
        LOG.debug("target.extension=" + getTarget().getExtension());
        LOG.debug("Echoing string starting with " + getCombinedTargetLines().substring(0, 1000));
        final BufferedReader reader = new BufferedReader(
            new InputStreamReader(processes.get(1).getErrorStream())
        );
        final List<Diagnostic> diagnostics = new ArrayList<>();
        String line;
        LOG.debug("Getting diagnostics...");
        while ((line = reader.readLine()) != null) {
            LOG.debug(line);
            addDiagnostic(line, diagnostics);
        }
        return diagnostics;
    }

    /* -----------------------  PRIVATE METHODS  ------------------------ */

    /**
     * Searches line for a diagnostic and, if one is found, adds it to
     * diagnostics.
     * @param line a line of the GCC error stream for a document
     * @param diagnostics the list of diagnostics to which any new diagnostics
     *     should be added
     */
    private void addDiagnostic(String line, List<Diagnostic> diagnostics) {
        final Matcher matcher = GCC_ERROR.matcher(line);
        if (!matcher.matches()) {
            return;
        }
        LOG.debug("Diagnostics line matches expected pattern: " + line);
        // Decrement to convert from 1-based to 0-based indexing
        final int lineNumber = Integer.parseInt(matcher.group("line")) - 1;
        LOG.debug("");
        Range range;
        if (matcher.group("column") == null) {
            range = new Range(
                adjustPosition(new Position(lineNumber, 0)),
                adjustPosition(new Position(lineNumber, line.length())) // FIXME: off-by-one error?
            );
        } else {
            // Decrement to convert from 1-based to 0-based indexing
            final int column = Integer.parseInt(matcher.group("column")) - 1;
            range = new Range(
                adjustPosition(new Position(lineNumber, column)),
                adjustPosition(new Position(lineNumber, line.length())) // FIXME: end at token end?
            );
        }
        final String message = matcher.group("message");
        // GCC gives only 3 distinct severity levels instead of 4? TODO: verify.
        final DiagnosticSeverity severity;
        switch (matcher.group("severity")) {
            case "error":
                severity = DiagnosticSeverity.Error;
                break;
            case "warning":
                severity = DiagnosticSeverity.Warning;
                break;
            default:
                severity = DiagnosticSeverity.Hint;
        }
        diagnostics.add(new Diagnostic(
            range, message, severity, "gcc"
        ));
    }

}