/*
 * generated by Xtext 2.17.0
 */
package org.icyphy.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LinguaFrancaGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTargetAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTargetTargetParserRuleCall_0_0 = (RuleCall)cTargetAssignment_0.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		private final Assignment cComponentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cComponentsComponentParserRuleCall_2_0 = (RuleCall)cComponentsAssignment_2.eContents().get(0);
		
		///////////// Overall file
		//Model:
		//	target=Target
		//	imports+=Import*
		//	components+=Component+;
		@Override public ParserRule getRule() { return rule; }
		
		//target=Target imports+=Import* components+=Component+
		public Group getGroup() { return cGroup; }
		
		//target=Target
		public Assignment getTargetAssignment_0() { return cTargetAssignment_0; }
		
		//Target
		public RuleCall getTargetTargetParserRuleCall_0_0() { return cTargetTargetParserRuleCall_0_0; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
		
		//components+=Component+
		public Assignment getComponentsAssignment_2() { return cComponentsAssignment_2; }
		
		//Component
		public RuleCall getComponentsComponentParserRuleCall_2_0() { return cComponentsComponentParserRuleCall_2_0; }
	}
	public class TargetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Target");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTargetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		///////////// Top level elements
		//Target:
		//	'target' name=ID ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'target' name=ID ';'
		public Group getGroup() { return cGroup; }
		
		//'target'
		public Keyword getTargetKeyword_0() { return cTargetKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamePathParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Import:
		//	'import' name=Path ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=Path ';'
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=Path
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Path
		public RuleCall getNamePathParserRuleCall_1_0() { return cNamePathParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class ComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Component");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReactorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCompositeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Component:
		//	Reactor | Composite;
		@Override public ParserRule getRule() { return rule; }
		
		//Reactor | Composite
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Reactor
		public RuleCall getReactorParserRuleCall_0() { return cReactorParserRuleCall_0; }
		
		//Composite
		public RuleCall getCompositeParserRuleCall_1() { return cCompositeParserRuleCall_1; }
	}
	public class ReactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Reactor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReactorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cComponentBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cComponentBodyComponentBodyParserRuleCall_1_0 = (RuleCall)cComponentBodyAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Reactor:
		//	'reactor'
		//	componentBody=ComponentBody
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'reactor' componentBody=ComponentBody '}'
		public Group getGroup() { return cGroup; }
		
		//'reactor'
		public Keyword getReactorKeyword_0() { return cReactorKeyword_0; }
		
		//componentBody=ComponentBody
		public Assignment getComponentBodyAssignment_1() { return cComponentBodyAssignment_1; }
		
		//ComponentBody
		public RuleCall getComponentBodyComponentBodyParserRuleCall_1_0() { return cComponentBodyComponentBodyParserRuleCall_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}
	public class CompositeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Composite");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCompositeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cComponentBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cComponentBodyComponentBodyParserRuleCall_1_0 = (RuleCall)cComponentBodyAssignment_1.eContents().get(0);
		private final Assignment cInstancesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInstancesInstanceParserRuleCall_2_0 = (RuleCall)cInstancesAssignment_2.eContents().get(0);
		private final Assignment cConnectionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConnectionsConnectionParserRuleCall_3_0 = (RuleCall)cConnectionsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Composite:
		//	'composite'
		//	componentBody=ComponentBody
		//	instances+=Instance*
		//	connections+=Connection*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'composite' componentBody=ComponentBody instances+=Instance* connections+=Connection* '}'
		public Group getGroup() { return cGroup; }
		
		//'composite'
		public Keyword getCompositeKeyword_0() { return cCompositeKeyword_0; }
		
		//componentBody=ComponentBody
		public Assignment getComponentBodyAssignment_1() { return cComponentBodyAssignment_1; }
		
		//ComponentBody
		public RuleCall getComponentBodyComponentBodyParserRuleCall_1_0() { return cComponentBodyComponentBodyParserRuleCall_1_0; }
		
		//instances+=Instance*
		public Assignment getInstancesAssignment_2() { return cInstancesAssignment_2; }
		
		//Instance
		public RuleCall getInstancesInstanceParserRuleCall_2_0() { return cInstancesInstanceParserRuleCall_2_0; }
		
		//connections+=Connection*
		public Assignment getConnectionsAssignment_3() { return cConnectionsAssignment_3; }
		
		//Connection
		public RuleCall getConnectionsConnectionParserRuleCall_3_0() { return cConnectionsConnectionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class ComponentBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.ComponentBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cParametersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParametersParamsParserRuleCall_1_0 = (RuleCall)cParametersAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInputsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInputsInputParserRuleCall_3_0 = (RuleCall)cInputsAssignment_3.eContents().get(0);
		private final Assignment cOutputsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOutputsOutputParserRuleCall_4_0 = (RuleCall)cOutputsAssignment_4.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cTimersAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cTimersTimerParserRuleCall_5_0_0 = (RuleCall)cTimersAssignment_5_0.eContents().get(0);
		private final Assignment cActionsAssignment_5_1 = (Assignment)cAlternatives_5.eContents().get(1);
		private final RuleCall cActionsActionParserRuleCall_5_1_0 = (RuleCall)cActionsAssignment_5_1.eContents().get(0);
		private final Assignment cPreambleAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cPreamblePreambleParserRuleCall_6_0 = (RuleCall)cPreambleAssignment_6.eContents().get(0);
		private final Assignment cReactionsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cReactionsReactionParserRuleCall_7_0 = (RuleCall)cReactionsAssignment_7.eContents().get(0);
		
		//// The following enforces the order of definitions:
		//// inputs, outputs, timers and actions, preamble, reactions.
		//ComponentBody:
		//	name=ID parameters=Params? '{'
		//	inputs+=Input*
		//	outputs+=Output* (timers+=Timer | actions+=Action)*
		//	preamble=Preamble?
		//	reactions+=Reaction*;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID parameters=Params? '{' inputs+=Input* outputs+=Output* (timers+=Timer | actions+=Action)* preamble=Preamble?
		//reactions+=Reaction*
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//parameters=Params?
		public Assignment getParametersAssignment_1() { return cParametersAssignment_1; }
		
		//Params
		public RuleCall getParametersParamsParserRuleCall_1_0() { return cParametersParamsParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//inputs+=Input*
		public Assignment getInputsAssignment_3() { return cInputsAssignment_3; }
		
		//Input
		public RuleCall getInputsInputParserRuleCall_3_0() { return cInputsInputParserRuleCall_3_0; }
		
		//outputs+=Output*
		public Assignment getOutputsAssignment_4() { return cOutputsAssignment_4; }
		
		//Output
		public RuleCall getOutputsOutputParserRuleCall_4_0() { return cOutputsOutputParserRuleCall_4_0; }
		
		//(timers+=Timer | actions+=Action)*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//timers+=Timer
		public Assignment getTimersAssignment_5_0() { return cTimersAssignment_5_0; }
		
		//Timer
		public RuleCall getTimersTimerParserRuleCall_5_0_0() { return cTimersTimerParserRuleCall_5_0_0; }
		
		//actions+=Action
		public Assignment getActionsAssignment_5_1() { return cActionsAssignment_5_1; }
		
		//Action
		public RuleCall getActionsActionParserRuleCall_5_1_0() { return cActionsActionParserRuleCall_5_1_0; }
		
		//preamble=Preamble?
		public Assignment getPreambleAssignment_6() { return cPreambleAssignment_6; }
		
		//Preamble
		public RuleCall getPreamblePreambleParserRuleCall_6_0() { return cPreamblePreambleParserRuleCall_6_0; }
		
		//reactions+=Reaction*
		public Assignment getReactionsAssignment_7() { return cReactionsAssignment_7; }
		
		//Reaction
		public RuleCall getReactionsReactionParserRuleCall_7_0() { return cReactionsReactionParserRuleCall_7_0; }
	}
	public class InputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Input");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final Keyword cNameInputKeyword_1_0_1 = (Keyword)cNameAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///////////// Statements
		//// Note explicit allowance of keywords for names of inputs, outputs, clocks.
		//Input:
		//	'input' name=(ID | 'input') (':' type=Type)? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'input' name=(ID | 'input') (':' type=Type)? ';'
		public Group getGroup() { return cGroup; }
		
		//'input'
		public Keyword getInputKeyword_0() { return cInputKeyword_0; }
		
		//name=(ID | 'input')
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(ID | 'input')
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }
		
		//'input'
		public Keyword getNameInputKeyword_1_0_1() { return cNameInputKeyword_1_0_1; }
		
		//(':' type=Type)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//type=Type
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_1_0() { return cTypeTypeParserRuleCall_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class OutputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Output");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOutputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final Keyword cNameOutputKeyword_1_0_1 = (Keyword)cNameAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Output:
		//	'output' name=(ID | 'output') (':' type=Type)? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'output' name=(ID | 'output') (':' type=Type)? ';'
		public Group getGroup() { return cGroup; }
		
		//'output'
		public Keyword getOutputKeyword_0() { return cOutputKeyword_0; }
		
		//name=(ID | 'output')
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(ID | 'output')
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }
		
		//'output'
		public Keyword getNameOutputKeyword_1_0_1() { return cNameOutputKeyword_1_0_1; }
		
		//(':' type=Type)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//type=Type
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_1_0() { return cTypeTypeParserRuleCall_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class TimerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Timer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final Keyword cNameTimerKeyword_1_0_1 = (Keyword)cNameAlternatives_1_0.eContents().get(1);
		private final Assignment cTimingAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTimingTimingParserRuleCall_2_0 = (RuleCall)cTimingAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Timer:
		//	'timer' name=(ID | 'timer') timing=Timing? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'timer' name=(ID | 'timer') timing=Timing? ';'
		public Group getGroup() { return cGroup; }
		
		//'timer'
		public Keyword getTimerKeyword_0() { return cTimerKeyword_0; }
		
		//name=(ID | 'timer')
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(ID | 'timer')
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }
		
		//'timer'
		public Keyword getNameTimerKeyword_1_0_1() { return cNameTimerKeyword_1_0_1; }
		
		//timing=Timing?
		public Assignment getTimingAssignment_2() { return cTimingAssignment_2; }
		
		//Timing
		public RuleCall getTimingTimingParserRuleCall_2_0() { return cTimingTimingParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Action");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cActionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final Keyword cNameActionKeyword_1_0_1 = (Keyword)cNameAlternatives_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDelayAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Alternatives cDelayAlternatives_2_1_0 = (Alternatives)cDelayAssignment_2_1.eContents().get(0);
		private final RuleCall cDelayIDTerminalRuleCall_2_1_0_0 = (RuleCall)cDelayAlternatives_2_1_0.eContents().get(0);
		private final RuleCall cDelayNUMBERTerminalRuleCall_2_1_0_1 = (RuleCall)cDelayAlternatives_2_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Action:
		//	'action' name=(ID | 'action') ('(' delay=(ID | NUMBER) ')')? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'action' name=(ID | 'action') ('(' delay=(ID | NUMBER) ')')? ';'
		public Group getGroup() { return cGroup; }
		
		//'action'
		public Keyword getActionKeyword_0() { return cActionKeyword_0; }
		
		//name=(ID | 'action')
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(ID | 'action')
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }
		
		//'action'
		public Keyword getNameActionKeyword_1_0_1() { return cNameActionKeyword_1_0_1; }
		
		//('(' delay=(ID | NUMBER) ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//delay=(ID | NUMBER)
		public Assignment getDelayAssignment_2_1() { return cDelayAssignment_2_1; }
		
		//(ID | NUMBER)
		public Alternatives getDelayAlternatives_2_1_0() { return cDelayAlternatives_2_1_0; }
		
		//ID
		public RuleCall getDelayIDTerminalRuleCall_2_1_0_0() { return cDelayIDTerminalRuleCall_2_1_0_0; }
		
		//NUMBER
		public RuleCall getDelayNUMBERTerminalRuleCall_2_1_0_1() { return cDelayNUMBERTerminalRuleCall_2_1_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class ReactionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Reaction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReactionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cTriggersAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cTriggersIDTerminalRuleCall_1_1_0_0 = (RuleCall)cTriggersAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cTriggersAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cTriggersIDTerminalRuleCall_1_1_1_1_0 = (RuleCall)cTriggersAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cGetsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGetsGetsParserRuleCall_2_0 = (RuleCall)cGetsAssignment_2.eContents().get(0);
		private final Assignment cSetsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSetsSetsParserRuleCall_3_0 = (RuleCall)cSetsAssignment_3.eContents().get(0);
		private final Assignment cCodeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCodeCODETerminalRuleCall_4_0 = (RuleCall)cCodeAssignment_4.eContents().get(0);
		
		//Reaction:
		//	'reaction' ('(' (triggers+=ID (',' triggers+=ID)*)? ')')?
		//	gets=Gets?
		//	sets=Sets?
		//	code=CODE;
		@Override public ParserRule getRule() { return rule; }
		
		//'reaction' ('(' (triggers+=ID (',' triggers+=ID)*)? ')')? gets=Gets? sets=Sets? code=CODE
		public Group getGroup() { return cGroup; }
		
		//'reaction'
		public Keyword getReactionKeyword_0() { return cReactionKeyword_0; }
		
		//('(' (triggers+=ID (',' triggers+=ID)*)? ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//(triggers+=ID (',' triggers+=ID)*)?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//triggers+=ID
		public Assignment getTriggersAssignment_1_1_0() { return cTriggersAssignment_1_1_0; }
		
		//ID
		public RuleCall getTriggersIDTerminalRuleCall_1_1_0_0() { return cTriggersIDTerminalRuleCall_1_1_0_0; }
		
		//(',' triggers+=ID)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }
		
		//triggers+=ID
		public Assignment getTriggersAssignment_1_1_1_1() { return cTriggersAssignment_1_1_1_1; }
		
		//ID
		public RuleCall getTriggersIDTerminalRuleCall_1_1_1_1_0() { return cTriggersIDTerminalRuleCall_1_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//gets=Gets?
		public Assignment getGetsAssignment_2() { return cGetsAssignment_2; }
		
		//Gets
		public RuleCall getGetsGetsParserRuleCall_2_0() { return cGetsGetsParserRuleCall_2_0; }
		
		//sets=Sets?
		public Assignment getSetsAssignment_3() { return cSetsAssignment_3; }
		
		//Sets
		public RuleCall getSetsSetsParserRuleCall_3_0() { return cSetsSetsParserRuleCall_3_0; }
		
		//code=CODE
		public Assignment getCodeAssignment_4() { return cCodeAssignment_4; }
		
		//CODE
		public RuleCall getCodeCODETerminalRuleCall_4_0() { return cCodeCODETerminalRuleCall_4_0; }
	}
	public class PreambleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Preamble");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPreambleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCodeCODETerminalRuleCall_1_0 = (RuleCall)cCodeAssignment_1.eContents().get(0);
		
		//Preamble:
		//	'preamble' code=CODE;
		@Override public ParserRule getRule() { return rule; }
		
		//'preamble' code=CODE
		public Group getGroup() { return cGroup; }
		
		//'preamble'
		public Keyword getPreambleKeyword_0() { return cPreambleKeyword_0; }
		
		//code=CODE
		public Assignment getCodeAssignment_1() { return cCodeAssignment_1; }
		
		//CODE
		public RuleCall getCodeCODETerminalRuleCall_1_0() { return cCodeCODETerminalRuleCall_1_0; }
	}
	public class InstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Instance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cNewKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActorClassAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActorClassIDTerminalRuleCall_3_0 = (RuleCall)cActorClassAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cParametersAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cParametersAssignmentsParserRuleCall_4_1_0 = (RuleCall)cParametersAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// FIXME: reactorClass should ideally be something like [Reactor|Composite],
		//// to get cross references to work. But this doesn't work for importing
		//// foreign reactors that are not defined in Lingua Franca.
		//Instance:
		//	name=ID '=' 'new' actorClass=ID ('(' parameters=Assignments? ')')? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '=' 'new' actorClass=ID ('(' parameters=Assignments? ')')? ';'
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//'new'
		public Keyword getNewKeyword_2() { return cNewKeyword_2; }
		
		//actorClass=ID
		public Assignment getActorClassAssignment_3() { return cActorClassAssignment_3; }
		
		//ID
		public RuleCall getActorClassIDTerminalRuleCall_3_0() { return cActorClassIDTerminalRuleCall_3_0; }
		
		//('(' parameters=Assignments? ')')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//parameters=Assignments?
		public Assignment getParametersAssignment_4_1() { return cParametersAssignment_4_1; }
		
		//Assignments
		public RuleCall getParametersAssignmentsParserRuleCall_4_1_0() { return cParametersAssignmentsParserRuleCall_4_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class ConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Connection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftPortAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftPortPortParserRuleCall_0_0 = (RuleCall)cLeftPortAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightPortAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPortPortParserRuleCall_2_0 = (RuleCall)cRightPortAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Connection:
		//	leftPort=Port '->' rightPort=Port ';';
		@Override public ParserRule getRule() { return rule; }
		
		//leftPort=Port '->' rightPort=Port ';'
		public Group getGroup() { return cGroup; }
		
		//leftPort=Port
		public Assignment getLeftPortAssignment_0() { return cLeftPortAssignment_0; }
		
		//Port
		public RuleCall getLeftPortPortParserRuleCall_0_0() { return cLeftPortPortParserRuleCall_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//rightPort=Port
		public Assignment getRightPortAssignment_2() { return cRightPortAssignment_2; }
		
		//Port
		public RuleCall getRightPortPortParserRuleCall_2_0() { return cRightPortPortParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class AssignmentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Assignments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAssignmentsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAssignmentsAssignmentParserRuleCall_0_0 = (RuleCall)cAssignmentsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAssignmentsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAssignmentsAssignmentParserRuleCall_1_1_0 = (RuleCall)cAssignmentsAssignment_1_1.eContents().get(0);
		
		///////////// Pieces
		//Assignments:
		//	assignments+=Assignment (',' assignments+=Assignment)*;
		@Override public ParserRule getRule() { return rule; }
		
		//assignments+=Assignment (',' assignments+=Assignment)*
		public Group getGroup() { return cGroup; }
		
		//assignments+=Assignment
		public Assignment getAssignmentsAssignment_0() { return cAssignmentsAssignment_0; }
		
		//Assignment
		public RuleCall getAssignmentsAssignmentParserRuleCall_0_0() { return cAssignmentsAssignmentParserRuleCall_0_0; }
		
		//(',' assignments+=Assignment)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//assignments+=Assignment
		public Assignment getAssignmentsAssignment_1_1() { return cAssignmentsAssignment_1_1; }
		
		//Assignment
		public RuleCall getAssignmentsAssignmentParserRuleCall_1_1_0() { return cAssignmentsAssignmentParserRuleCall_1_1_0; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Assignment:
		//	name=ID '=' value=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '=' value=Value
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//value=Value
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Value
		public RuleCall getValueValueParserRuleCall_2_0() { return cValueValueParserRuleCall_2_0; }
	}
	public class GetsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Gets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cGetsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cGetsIDTerminalRuleCall_0_0 = (RuleCall)cGetsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cGetsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cGetsIDTerminalRuleCall_1_1_0 = (RuleCall)cGetsAssignment_1_1.eContents().get(0);
		
		//// Specification of what inputs a reaction reads.
		//Gets:
		//	gets+=ID (',' gets+=ID)?;
		@Override public ParserRule getRule() { return rule; }
		
		//gets+=ID (',' gets+=ID)?
		public Group getGroup() { return cGroup; }
		
		//gets+=ID
		public Assignment getGetsAssignment_0() { return cGetsAssignment_0; }
		
		//ID
		public RuleCall getGetsIDTerminalRuleCall_0_0() { return cGetsIDTerminalRuleCall_0_0; }
		
		//(',' gets+=ID)?
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//gets+=ID
		public Assignment getGetsAssignment_1_1() { return cGetsAssignment_1_1; }
		
		//ID
		public RuleCall getGetsIDTerminalRuleCall_1_1_0() { return cGetsIDTerminalRuleCall_1_1_0; }
	}
	public class ParamsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Params");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParamsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParamsParamParserRuleCall_1_0 = (RuleCall)cParamsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParamsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParamsParamParserRuleCall_2_1_0 = (RuleCall)cParamsAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Parameters for actors and composites.
		//Params:
		//	'(' params+=Param (',' params+=Param)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' params+=Param (',' params+=Param)* ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//params+=Param
		public Assignment getParamsAssignment_1() { return cParamsAssignment_1; }
		
		//Param
		public RuleCall getParamsParamParserRuleCall_1_0() { return cParamsParamParserRuleCall_1_0; }
		
		//(',' params+=Param)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//params+=Param
		public Assignment getParamsAssignment_2_1() { return cParamsAssignment_2_1; }
		
		//Param
		public RuleCall getParamsParamParserRuleCall_2_1_0() { return cParamsParamParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Param");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypeAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_2_1_0 = (RuleCall)cTypeAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueValueParserRuleCall_3_1_0 = (RuleCall)cValueAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//// Single parameter.
		//Param:
		//	'const'? name=ID (':' type=Type)? ('(' value=Value ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//'const'? name=ID (':' type=Type)? ('(' value=Value ')')?
		public Group getGroup() { return cGroup; }
		
		//'const'?
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(':' type=Type)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':'
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }
		
		//type=Type
		public Assignment getTypeAssignment_2_1() { return cTypeAssignment_2_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_1_0() { return cTypeTypeParserRuleCall_2_1_0; }
		
		//('(' value=Value ')')?
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//value=Value
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }
		
		//Value
		public RuleCall getValueValueParserRuleCall_3_1_0() { return cValueValueParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
	}
	public class TimingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Timing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOffsetAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cOffsetAlternatives_1_0 = (Alternatives)cOffsetAssignment_1.eContents().get(0);
		private final Keyword cOffsetNOWKeyword_1_0_0 = (Keyword)cOffsetAlternatives_1_0.eContents().get(0);
		private final RuleCall cOffsetIDTerminalRuleCall_1_0_1 = (RuleCall)cOffsetAlternatives_1_0.eContents().get(1);
		private final RuleCall cOffsetNUMBERTerminalRuleCall_1_0_2 = (RuleCall)cOffsetAlternatives_1_0.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPeriodAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Alternatives cPeriodAlternatives_2_1_0 = (Alternatives)cPeriodAssignment_2_1.eContents().get(0);
		private final Keyword cPeriodONCEKeyword_2_1_0_0 = (Keyword)cPeriodAlternatives_2_1_0.eContents().get(0);
		private final Keyword cPeriodSTOPKeyword_2_1_0_1 = (Keyword)cPeriodAlternatives_2_1_0.eContents().get(1);
		private final RuleCall cPeriodIDTerminalRuleCall_2_1_0_2 = (RuleCall)cPeriodAlternatives_2_1_0.eContents().get(2);
		private final RuleCall cPeriodNUMBERTerminalRuleCall_2_1_0_3 = (RuleCall)cPeriodAlternatives_2_1_0.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Timing specification for a timer: (offset, period)
		//// Can be empty, which means (0,0) = (NOW, ONCE).
		//// E.g. (0) or (NOW) or (NOW, ONCE) or (100, 1000)
		//// The latter means fire with period 1000, offset 100.
		//Timing:
		//	'(' offset=('NOW' | ID | NUMBER) (',' period=('ONCE' | 'STOP' | ID | NUMBER))? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' offset=('NOW' | ID | NUMBER) (',' period=('ONCE' | 'STOP' | ID | NUMBER))? ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//offset=('NOW' | ID | NUMBER)
		public Assignment getOffsetAssignment_1() { return cOffsetAssignment_1; }
		
		//('NOW' | ID | NUMBER)
		public Alternatives getOffsetAlternatives_1_0() { return cOffsetAlternatives_1_0; }
		
		//'NOW'
		public Keyword getOffsetNOWKeyword_1_0_0() { return cOffsetNOWKeyword_1_0_0; }
		
		//ID
		public RuleCall getOffsetIDTerminalRuleCall_1_0_1() { return cOffsetIDTerminalRuleCall_1_0_1; }
		
		//NUMBER
		public RuleCall getOffsetNUMBERTerminalRuleCall_1_0_2() { return cOffsetNUMBERTerminalRuleCall_1_0_2; }
		
		//(',' period=('ONCE' | 'STOP' | ID | NUMBER))?
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//period=('ONCE' | 'STOP' | ID | NUMBER)
		public Assignment getPeriodAssignment_2_1() { return cPeriodAssignment_2_1; }
		
		//('ONCE' | 'STOP' | ID | NUMBER)
		public Alternatives getPeriodAlternatives_2_1_0() { return cPeriodAlternatives_2_1_0; }
		
		//'ONCE'
		public Keyword getPeriodONCEKeyword_2_1_0_0() { return cPeriodONCEKeyword_2_1_0_0; }
		
		//'STOP'
		public Keyword getPeriodSTOPKeyword_2_1_0_1() { return cPeriodSTOPKeyword_2_1_0_1; }
		
		//ID
		public RuleCall getPeriodIDTerminalRuleCall_2_1_0_2() { return cPeriodIDTerminalRuleCall_2_1_0_2; }
		
		//NUMBER
		public RuleCall getPeriodNUMBERTerminalRuleCall_2_1_0_3() { return cPeriodNUMBERTerminalRuleCall_2_1_0_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class PortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Port");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_1_2_0 = (RuleCall)cAlternatives_1_2.eContents().get(0);
		private final Keyword cInputKeyword_1_2_1 = (Keyword)cAlternatives_1_2.eContents().get(1);
		private final Keyword cOutputKeyword_1_2_2 = (Keyword)cAlternatives_1_2.eContents().get(2);
		
		//// 'input' and 'output' are allowed port names despite being keywords.
		//Port:
		//	ID | ID '.' (ID | 'input' | 'output');
		@Override public ParserRule getRule() { return rule; }
		
		//ID | ID '.' (ID | 'input' | 'output')
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//ID '.' (ID | 'input' | 'output')
		public Group getGroup_1() { return cGroup_1; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }
		
		//ID | 'input' | 'output'
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_2_0() { return cIDTerminalRuleCall_1_2_0; }
		
		//'input'
		public Keyword getInputKeyword_1_2_1() { return cInputKeyword_1_2_1; }
		
		//'output'
		public Keyword getOutputKeyword_1_2_2() { return cOutputKeyword_1_2_2; }
	}
	public class SetsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Sets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSetsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSetsIDTerminalRuleCall_1_0 = (RuleCall)cSetsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSetsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSetsIDTerminalRuleCall_2_1_0 = (RuleCall)cSetsAssignment_2_1.eContents().get(0);
		
		//// Specification of what outputs a reaction writes.
		//Sets:
		//	'->' sets+=ID (',' sets+=ID)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'->' sets+=ID (',' sets+=ID)?
		public Group getGroup() { return cGroup; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0() { return cHyphenMinusGreaterThanSignKeyword_0; }
		
		//sets+=ID
		public Assignment getSetsAssignment_1() { return cSetsAssignment_1; }
		
		//ID
		public RuleCall getSetsIDTerminalRuleCall_1_0() { return cSetsIDTerminalRuleCall_1_0; }
		
		//(',' sets+=ID)?
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//sets+=ID
		public Assignment getSetsAssignment_2_1() { return cSetsAssignment_2_1; }
		
		//ID
		public RuleCall getSetsIDTerminalRuleCall_2_1_0() { return cSetsIDTerminalRuleCall_2_1_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCODETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A type is in the target language, hence either an ID or target code.
		//Type:
		//	ID | CODE;
		@Override public ParserRule getRule() { return rule; }
		
		//ID | CODE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//CODE
		public RuleCall getCODETerminalRuleCall_1() { return cCODETerminalRuleCall_1; }
	}
	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNUMBERTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCODETerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Value:
		//	ID | NUMBER | STRING | CODE;
		@Override public ParserRule getRule() { return rule; }
		
		//ID | NUMBER | STRING | CODE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_1() { return cNUMBERTerminalRuleCall_1; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2() { return cSTRINGTerminalRuleCall_2; }
		
		//CODE
		public RuleCall getCODETerminalRuleCall_3() { return cCODETerminalRuleCall_3; }
	}
	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.Path");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//// The following cannot be terminal because it overlaps ID.
		//Path:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	
	
	private final ModelElements pModel;
	private final TargetElements pTarget;
	private final ImportElements pImport;
	private final ComponentElements pComponent;
	private final ReactorElements pReactor;
	private final CompositeElements pComposite;
	private final ComponentBodyElements pComponentBody;
	private final InputElements pInput;
	private final OutputElements pOutput;
	private final TimerElements pTimer;
	private final ActionElements pAction;
	private final ReactionElements pReaction;
	private final PreambleElements pPreamble;
	private final InstanceElements pInstance;
	private final ConnectionElements pConnection;
	private final AssignmentsElements pAssignments;
	private final AssignmentElements pAssignment;
	private final GetsElements pGets;
	private final ParamsElements pParams;
	private final ParamElements pParam;
	private final TimingElements pTiming;
	private final PortElements pPort;
	private final SetsElements pSets;
	private final TypeElements pType;
	private final ValueElements pValue;
	private final TerminalRule tNUMBER;
	private final TerminalRule tCODE;
	private final PathElements pPath;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LinguaFrancaGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pTarget = new TargetElements();
		this.pImport = new ImportElements();
		this.pComponent = new ComponentElements();
		this.pReactor = new ReactorElements();
		this.pComposite = new CompositeElements();
		this.pComponentBody = new ComponentBodyElements();
		this.pInput = new InputElements();
		this.pOutput = new OutputElements();
		this.pTimer = new TimerElements();
		this.pAction = new ActionElements();
		this.pReaction = new ReactionElements();
		this.pPreamble = new PreambleElements();
		this.pInstance = new InstanceElements();
		this.pConnection = new ConnectionElements();
		this.pAssignments = new AssignmentsElements();
		this.pAssignment = new AssignmentElements();
		this.pGets = new GetsElements();
		this.pParams = new ParamsElements();
		this.pParam = new ParamElements();
		this.pTiming = new TimingElements();
		this.pPort = new PortElements();
		this.pSets = new SetsElements();
		this.pType = new TypeElements();
		this.pValue = new ValueElements();
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.NUMBER");
		this.tCODE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.icyphy.LinguaFranca.CODE");
		this.pPath = new PathElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.icyphy.LinguaFranca".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///////////// Overall file
	//Model:
	//	target=Target
	//	imports+=Import*
	//	components+=Component+;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///////////// Top level elements
	//Target:
	//	'target' name=ID ';';
	public TargetElements getTargetAccess() {
		return pTarget;
	}
	
	public ParserRule getTargetRule() {
		return getTargetAccess().getRule();
	}
	
	//Import:
	//	'import' name=Path ';';
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Component:
	//	Reactor | Composite;
	public ComponentElements getComponentAccess() {
		return pComponent;
	}
	
	public ParserRule getComponentRule() {
		return getComponentAccess().getRule();
	}
	
	//Reactor:
	//	'reactor'
	//	componentBody=ComponentBody
	//	'}';
	public ReactorElements getReactorAccess() {
		return pReactor;
	}
	
	public ParserRule getReactorRule() {
		return getReactorAccess().getRule();
	}
	
	//Composite:
	//	'composite'
	//	componentBody=ComponentBody
	//	instances+=Instance*
	//	connections+=Connection*
	//	'}';
	public CompositeElements getCompositeAccess() {
		return pComposite;
	}
	
	public ParserRule getCompositeRule() {
		return getCompositeAccess().getRule();
	}
	
	//// The following enforces the order of definitions:
	//// inputs, outputs, timers and actions, preamble, reactions.
	//ComponentBody:
	//	name=ID parameters=Params? '{'
	//	inputs+=Input*
	//	outputs+=Output* (timers+=Timer | actions+=Action)*
	//	preamble=Preamble?
	//	reactions+=Reaction*;
	public ComponentBodyElements getComponentBodyAccess() {
		return pComponentBody;
	}
	
	public ParserRule getComponentBodyRule() {
		return getComponentBodyAccess().getRule();
	}
	
	///////////// Statements
	//// Note explicit allowance of keywords for names of inputs, outputs, clocks.
	//Input:
	//	'input' name=(ID | 'input') (':' type=Type)? ';';
	public InputElements getInputAccess() {
		return pInput;
	}
	
	public ParserRule getInputRule() {
		return getInputAccess().getRule();
	}
	
	//Output:
	//	'output' name=(ID | 'output') (':' type=Type)? ';';
	public OutputElements getOutputAccess() {
		return pOutput;
	}
	
	public ParserRule getOutputRule() {
		return getOutputAccess().getRule();
	}
	
	//Timer:
	//	'timer' name=(ID | 'timer') timing=Timing? ';';
	public TimerElements getTimerAccess() {
		return pTimer;
	}
	
	public ParserRule getTimerRule() {
		return getTimerAccess().getRule();
	}
	
	//Action:
	//	'action' name=(ID | 'action') ('(' delay=(ID | NUMBER) ')')? ';';
	public ActionElements getActionAccess() {
		return pAction;
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//Reaction:
	//	'reaction' ('(' (triggers+=ID (',' triggers+=ID)*)? ')')?
	//	gets=Gets?
	//	sets=Sets?
	//	code=CODE;
	public ReactionElements getReactionAccess() {
		return pReaction;
	}
	
	public ParserRule getReactionRule() {
		return getReactionAccess().getRule();
	}
	
	//Preamble:
	//	'preamble' code=CODE;
	public PreambleElements getPreambleAccess() {
		return pPreamble;
	}
	
	public ParserRule getPreambleRule() {
		return getPreambleAccess().getRule();
	}
	
	//// FIXME: reactorClass should ideally be something like [Reactor|Composite],
	//// to get cross references to work. But this doesn't work for importing
	//// foreign reactors that are not defined in Lingua Franca.
	//Instance:
	//	name=ID '=' 'new' actorClass=ID ('(' parameters=Assignments? ')')? ';';
	public InstanceElements getInstanceAccess() {
		return pInstance;
	}
	
	public ParserRule getInstanceRule() {
		return getInstanceAccess().getRule();
	}
	
	//Connection:
	//	leftPort=Port '->' rightPort=Port ';';
	public ConnectionElements getConnectionAccess() {
		return pConnection;
	}
	
	public ParserRule getConnectionRule() {
		return getConnectionAccess().getRule();
	}
	
	///////////// Pieces
	//Assignments:
	//	assignments+=Assignment (',' assignments+=Assignment)*;
	public AssignmentsElements getAssignmentsAccess() {
		return pAssignments;
	}
	
	public ParserRule getAssignmentsRule() {
		return getAssignmentsAccess().getRule();
	}
	
	//Assignment:
	//	name=ID '=' value=Value;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//// Specification of what inputs a reaction reads.
	//Gets:
	//	gets+=ID (',' gets+=ID)?;
	public GetsElements getGetsAccess() {
		return pGets;
	}
	
	public ParserRule getGetsRule() {
		return getGetsAccess().getRule();
	}
	
	//// Parameters for actors and composites.
	//Params:
	//	'(' params+=Param (',' params+=Param)* ')';
	public ParamsElements getParamsAccess() {
		return pParams;
	}
	
	public ParserRule getParamsRule() {
		return getParamsAccess().getRule();
	}
	
	//// Single parameter.
	//Param:
	//	'const'? name=ID (':' type=Type)? ('(' value=Value ')')?;
	public ParamElements getParamAccess() {
		return pParam;
	}
	
	public ParserRule getParamRule() {
		return getParamAccess().getRule();
	}
	
	//// Timing specification for a timer: (offset, period)
	//// Can be empty, which means (0,0) = (NOW, ONCE).
	//// E.g. (0) or (NOW) or (NOW, ONCE) or (100, 1000)
	//// The latter means fire with period 1000, offset 100.
	//Timing:
	//	'(' offset=('NOW' | ID | NUMBER) (',' period=('ONCE' | 'STOP' | ID | NUMBER))? ')';
	public TimingElements getTimingAccess() {
		return pTiming;
	}
	
	public ParserRule getTimingRule() {
		return getTimingAccess().getRule();
	}
	
	//// 'input' and 'output' are allowed port names despite being keywords.
	//Port:
	//	ID | ID '.' (ID | 'input' | 'output');
	public PortElements getPortAccess() {
		return pPort;
	}
	
	public ParserRule getPortRule() {
		return getPortAccess().getRule();
	}
	
	//// Specification of what outputs a reaction writes.
	//Sets:
	//	'->' sets+=ID (',' sets+=ID)?;
	public SetsElements getSetsAccess() {
		return pSets;
	}
	
	public ParserRule getSetsRule() {
		return getSetsAccess().getRule();
	}
	
	//// A type is in the target language, hence either an ID or target code.
	//Type:
	//	ID | CODE;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//Value:
	//	ID | NUMBER | STRING | CODE;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}
	
	//terminal NUMBER:
	//	'-'? INT ('.' INT)?;
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	}
	
	//terminal CODE:
	//	'{=' .* '=}';
	public TerminalRule getCODERule() {
		return tCODE;
	}
	
	//// The following cannot be terminal because it overlaps ID.
	//Path:
	//	ID ('.' ID)*;
	public PathElements getPathAccess() {
		return pPath;
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
