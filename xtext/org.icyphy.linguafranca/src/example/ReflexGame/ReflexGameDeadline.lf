target C (
    run="bin/ReflexGame -keepalive"
);
// Produce a counting sequence at random times with a minimum
// and maximum time between outputs specified as parameters.
reactor RandomSource(min_time:time(2 sec), max_time:time(5 sec)) {
    preamble {=
        // Generate a random additional delay over the minimum. 
        // Assume millisecond precision is enough.
        interval_t additional_time(interval_t min_time, interval_t max_time) {
            int interval_in_msec = (max_time - min_time) / MSEC(1);
            return (rand() % interval_in_msec) * MSEC(1);
        }
    =}
    input trigger:int;
    output start:int;
    physical action prompt(min_time);
    state attempt:int(0);
    
    reaction(startup) -> prompt {=
        printf("***********************************************\n");
        printf("Watch for the prompt, then hit Return or Enter.\n");
        printf("Type Control-D (EOF) to quit.\n\n");
        
        // Random number functions are part of stdlib.h, which is included by reactor.h.
        // Set a seed for random number generation based on the current time.
        srand(time(0));
        
        // Schedule the next event.
        schedule(prompt, additional_time(self->min_time, self->max_time), NULL);
    =}
    reaction(prompt) -> start, prompt {=
        self->attempt++;
        printf("%d. Hit Return or Enter!", self->attempt);
        fflush(stdout);
        set(start, self->attempt);
    =}
    reaction(trigger) -> prompt {=
        // Schedule the next event.
        schedule(prompt, additional_time(self->min_time, self->max_time), NULL);
    =}
}
reactor GetUserInput {
    
    state elapsed_msecs:time(0);
    state attempts:int(0);
    
    input prompt:int;
    output press:int;

    reaction(prompt) -> press {=
        int c;
        int nsecs;
        // No human has a shorter reaction time than 100 ms.
        while((c = getchar()) != '\n' || (nsecs = get_physical_time() - get_logical_time()) < 100000000) {
        	if (c == EOF) {
            	stop();
            	break;
            } 
       }
       if (c != EOF) {
       	self->attempts = prompt;
       	self->elapsed_msecs += nsecs / 1000000;
       	set(press, nsecs);
       }
       
    =}

	reaction(shutdown) {=
        printf("\n**** Average response time: %d milliseconds.\n", self->elapsed_msecs/self->attempts);
    =}
    
}

reactor ReportPerformance {
	input press:int; // FIXME: this should be time, but the validator chokes on it.
	
	reaction(press) {=
		printf("On time! Reaction time: %lld nanoseconds\n", press);        	
	=} deadline(300 msec) {=
		printf("Too late! Reaction time: %lld nanoseconds\n", press);
	=}
}

main reactor ReflexGame {
    p = new RandomSource();
    g = new GetUserInput();
    r = new ReportPerformance();
    p.start -> g.prompt;
    g.press -> p.trigger;
    g.press -> r.press;
}
