/**
 * Reactor that publishes strings to a specified MQTT topic.
 * See MQTTTest for prerequisites and an example usage.
 * 
 * This publisher appends to the end of the message the
 * timestamp of the message at the publisher. The receiving
 * end, by default, ignores this, but it can instead a
 * "poor man's version of Ptides," where, by adding a
 * sufficient logical delay, it can assign a deterministic
 * timestamp equal to the publisher's timestamp plus a constant
 * delay.  See MQTTSubscriber.
 * 
 * Notice that the appended timestamp (64 bits or 8 bytes)
 * is easy to ignore because the message is a null-terminated
 * string.
 * 
 * This publisher also ensures in-order delivery messages to
 * subscribers. If an attempt is made to send a message before
 * the delivery of the previous message has completed, then the reaction
 * that sends the message (the reaction to an input 'in') will
 * block until the previous delivery has completed.
 * 
 * @author Ravi Akella
 * @author Edward A. Lee
 */
target C;

/**
 * Reactor that publishes strings to a specified MQTT topic.
 * @param topic The topic name on which to publish.
 * @param address The IP address of the MQTT broker.
 * @param clientID The name of the client instance.
 *  These names are required to be unique.
 */
reactor MQTTPublisher (
    topic:string("DefaultTopic"),
    address:string("tcp://localhost:1883"),
    clientID:string("DefaultPublisher")
) {
    preamble {=
        #include "MQTTClient.h"
        
        // Timeout for completion of message sending in milliseconds.
        #define TIMEOUT     10000L
        
        // FIXME: These should not be a global.
        MQTTClient client;
        MQTTClient_message mqtt_msg = MQTTClient_message_initializer;
 
        // Connection options for the client.
        // Making this global means that all instances of this reactor have
        // the same connection options.
        MQTTClient_connectOptions pub_connect_options = MQTTClient_connectOptions_initializer;
 
        // Struct type used to keep track of messages in flight between reactions.
        typedef struct inflight_t {
            bool message_in_flight;
            MQTTClient_deliveryToken delivery_token;
        } inflight_t;
        
        /** Callback invoked once delivery is complete. */
        void pub_delivered(void *inflight, MQTTClient_deliveryToken dt) {
            // printf("DEBUG: Message with token value %d delivery confirmed\n", dt);
            ((inflight_t*)inflight)->message_in_flight = false;
        }
        /** Callback invoked if the connection is lost. */
        void pub_connection_lost(void *context, char *cause) {
            printf("\nMQTTPublisher: Connection lost\n");
            printf("  cause: %s\n", cause);
        }
    =}
    // Input type char* instead of string is used for dynamically
    // allocated character arrays (as opposed to static constant strings).
    input in:char*;
    
    // State variable that keeps track of a message in flight.
    // FIXME: Replace with simple pair of arguments when the grammar supports this.
    state inflight:inflight_t({={false, 0}=});
    
    // Connect to the broker. Exit if this fails.
    reaction(startup){=
        MQTTClient_create(&client, self->address, self->clientID, MQTTCLIENT_PERSISTENCE_NONE, NULL);
        pub_connect_options.keepAliveInterval = 20;
        pub_connect_options.cleansession = 1;

        // Set up callback functions.
        // Second to last argument should be a pointer to a function
        // to handle notification of delivery of a message.
        // But this reactor isn't sending any messages.
        // Second argument is a pointer to context that will be passed to pub_delivered,
        // which in this case is a pointer to the inflight state variable.
        MQTTClient_setCallbacks(client, &self->inflight, pub_connection_lost, NULL, pub_delivered);
        
        // Connect to the broker.
        int rc; // response code.
        if ((rc = MQTTClient_connect(client, &pub_connect_options)) != MQTTCLIENT_SUCCESS) {
            fprintf(stderr, "MQTTPublisher: Failed to connect to MQTT broker.\n");
            fprintf(stderr, "Perhaps one is not running? Return code: %d\n", rc);
            exit(EXIT_FAILURE);
        }
        // printf("DEBUG: MQTTPublisher connected to broker.\n");
    =}
    
    // React to an input by sending a message with the value of the input as the payload.
    // If delivery has not yet completed for a previously sent message, then wait for
    // it to complete before proceeding (blocking this reaction).
    reaction(in) {=
        if(self->inflight.message_in_flight) {
            // Wait for message delivery to be complete.
            // printf("DEBUG: Waiting for publication of message: %s\n", in);
            // printf("DEBUG: on topic '%s' for publisher with ClientID: %s\n", self->topic, self->clientID);
            int rc = MQTTClient_waitForCompletion(client, self->inflight.delivery_token, TIMEOUT);
            if (rc != MQTTCLIENT_SUCCESS) {
                fprintf(stderr, "ERROR: Message delivery failed with error code %d.\n", rc);
                fprintf(stderr, "Message: %s\n", in);
                fprintf(stderr, "On topic '%s' for publisher with ClientID: %s\n", self->topic, self->clientID);
            }
        }
        mqtt_msg.payload = in;
        mqtt_msg.payloadlen = strlen(in) + 1; // Account for null character.
        
        // QoS 2 means that the message will be delivered exactly once.
        mqtt_msg.qos = 2;
        
        // Retained messages are held by the server and sent to future new subscribers.
        // Specify that this message should not be retained.
        // It will be sent only to subscribers currently subscribed.
        mqtt_msg.retained = 0;
        
        MQTTClient_publishMessage(client, self->topic, &mqtt_msg, &self->inflight.delivery_token);
        self->inflight.message_in_flight = true;        
    =}
    
    reaction(shutdown) {=
        printf("MQTTPublisher: Client ID %s disconnecting.\n", self->clientID);
        MQTTClient_disconnect(client, 10000);
        MQTTClient_destroy(&client);
    =}
}