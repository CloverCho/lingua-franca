/**
 * Reactor that subscribes to a specified MQTT topic on which
 * string messages are published.
 * See MQTTTest for prerequisites and an example usage.
 * 
 * @author Ravi Akella
 * @author Edward A. Lee
 */
target C;
reactor MQTTSubscriber (
    address:string("tcp://localhost:1883"),
    clientID:string("DefaultSubscriber"),
    topic:string("DefaultTopic")
) {
    preamble {=
        #include "MQTTClient.h"
        #define QOS         2
        #define TIMEOUT     10000L
        
        // FIXME: This should not be a global. See FIXME below.
        MQTTClient client;
        
        // Connection options for the client.
        // Making this global means that all instances of this reactor have
        // the same connection options.
        MQTTClient_connectOptions sub_connect_options = MQTTClient_connectOptions_initializer;
                
        // Callback function invoked by MQTT when a message arrives.
        int message_arrived(void *incomingMessage, char *topicName, int topicLen, MQTTClient_message *message) {
            // printf("DEBUG: MQTTSubscriber: Message arrived on topic %s: %s\n", topicName, (char*)message->payload);

            // The incoming message is in dynamically allocated memory.
            // We copy the message using schedule_copy() because, unfortunately, Paho MQTT uses its own
            // version of malloc() and free() (defined in Heap.h and Heap.c).
            // We could modify Paho MQTT to use the generic malloc() and free(),
            // and then we could use schedule_value() to avoid the copy.
            schedule_copy(incomingMessage, 0, (char*)message->payload, message->payloadlen);
            
            // MQTTClient_freeMessage() also frees the memory allocated to the payload,
            // which is why we have to copy the message here.
            MQTTClient_freeMessage(&message);
            MQTTClient_free(topicName);
            
            // Return true to indicate that the message has been successfully handled.
            return 1;
        }
        
        /** Callback invoked if the connection is lost. */
        void sub_connection_lost(void *incomingMessage, char *cause) {
            printf("\nConnection lost\n");
            printf("  cause: %s\n", cause);
        }
    =}
    
    // Output for sending the incoming MQTT message.
    // Use type char* rather than string because it is not
    // a static string, but rather dynamically allocated memory.
    output message:char*;

    // Action that is triggered when there is an incoming MQTT message.
    // Use a physical action here so that the logical time when the action
    // is triggered is the physical time of arrival of the message.
    physical action incomingMessage:char*;
    
    // State variable storing the MQTT client created for each instance of this reactor.
    // FIXME: When the grammar allows it, replace the global above with a state variable
    // and replace all references to "client" with "self->client".
    // state client:MQTTClient;
    
    reaction(startup) -> incomingMessage {=
        MQTTClient_create(&client, self->address, self->clientID, MQTTCLIENT_PERSISTENCE_NONE, NULL);
        sub_connect_options.keepAliveInterval = 20;
        sub_connect_options.cleansession = 1;
        
        // Set up callback functions.
        // Last argument should be a pointer to a function to
        // handle notification of delivery of a sent message.
        // But this reactor isn't sending any messages.
        MQTTClient_setCallbacks(client, incomingMessage, sub_connection_lost, message_arrived, NULL);
        
        // Connect to the broker.
        int rc; // response code.
        if ((rc = MQTTClient_connect(client, &sub_connect_options)) != MQTTCLIENT_SUCCESS) {
            fprintf(stderr, "MQTTSubscriber: Failed to connect to MQTT broker.\n");
            fprintf(stderr, "Perhaps one is not running? Return code: %d\n", rc);
            exit(EXIT_FAILURE);
        }
        
        MQTTClient_subscribe(client, self->topic, QOS);
    =}
    
    reaction(incomingMessage) -> message {=
        // The incomingMessage action contains a token that we can just forward.
        // The allocated memory will be freed when the token's reference count hits 0.
        set_token(message, incomingMessage_token);
    =}
    
    reaction(shutdown) {=
        printf("MQTTPublisher: Client ID %s disconnecting.\n", self->clientID);
        MQTTClient_disconnect(client, 10000);
        MQTTClient_destroy(&client);
    =}
}