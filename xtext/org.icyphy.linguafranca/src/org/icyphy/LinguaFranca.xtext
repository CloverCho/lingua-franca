grammar org.icyphy.LinguaFranca with org.eclipse.xtext.common.Terminals

generate linguaFranca "http://www.icyphy.org/LinguaFranca"

/////////// Overall file
Model:
	target=Target 
	(imports += Import)*
	(blocks += (Reactor | Composite))+
	;

/////////// Top level elements
Target:
	'target' name=ID ';';
	
Import:
	'import' name=Path ';';

// The following enforces the order of definitions:
// inputs, outputs, clocks, etc.
Reactor:
	'reactor' name=ID parameters=Params? '{'
	(inputs += Input)*
	(outputs += Output)*
	(clocks += Clock)*
	(preamble = Preamble)?
	(constructor = Constructor)?
	(reactions += Reaction)*
	'}';
	
Composite:
	'composite' name=ID parameters=Params? '{'
	(inputs += Input)*
	(outputs += Output)*
	(clocks += Clock)*
	(preamble = Preamble)?
	(constructor = Constructor)?
	(reactions += Reaction)*
	(instances += Instance)*
	(connections += Connection)*
	'}';
	
/////////// Statements

// Note explicit allowance of keywords for names of inputs, outputs, clocks.
Input:
	'input' name=(ID | 'input') (':' type=Type)? ';';

Output:
	'output' name=(ID | 'output') (':' type=Type)? ';';

Clock:
	'clock' name=(ID | 'clock') period=Period?';';
	
Reaction:
	'reaction' 
	('(' (triggers+=ID (',' triggers+=ID)*)? ')')?
	gets=Gets?
	sets=Sets?
	code=CODE;
	
Preamble:
	'preamble' code=CODE;

Constructor:
	'constructor' code=CODE;
	
// FIXME: reactorClass should ideally be something like [Reactor|Composite],
// to get cross references to work. But this doesn't work for importing
// foreign reactors that are not defined in Lingua Franca.
Instance:
	'instance' name=ID '=' actorClass=ID ('(' parameters=Assignments? ')')? ';' ;

Connection:
    leftPort=Port '->' rightPort=Port ';';

/////////// Pieces

Assignments:
	assignments+=Assignment (',' assignments+=Assignment)*;
	
Assignment:
	name=ID '=' value=Value;

// Specification of what inputs a reaction reads.
Gets:
	gets+=ID (',' gets+=ID)?;

// Parameters for actors and composites.
Params:
    '(' params+=Param (',' params+=Param)* ')';

// Single parameter.
Param:
    'const'? name=ID (':' type=Type)? ('(' value=Value ')')?;

// Periodicity spec for a trigger.
// E.g. (1000) or (1000, 100) or (1000, 100, 10)
// The latter means fire with period 1000, offset 100, 10 times.
Period:
	'(' period=(ID | NUMBER) (',' offset=(ID | NUMBER) (',' count=(ID | NUMBER))? )?')';

// 'input' and 'output' are allowed port names despite being keywords.
Port:
    ID | (ID '.' (ID | 'input' | 'output'));

// Specification of what outputs a reaction writes.
Sets:
	'->' sets+=ID (',' sets+=ID)?;

// A type is in the target language, hence either an ID or target code.
Type:
    ID | CODE ;
    
Value:
    ID | NUMBER | STRING | CODE;

/////////// Elementary components
// Terminals must be mutually exclusive. They are used by the lexer before parsing.

// FIXME: Can we replace this with something more general? E.g., scientific notation, hex, etc.?
terminal NUMBER:
    '-'? INT ('.' INT)? ;

// FIXME: What if the code needs to contain '=}'?
// Just escaping with \ is not a good idea because then every \ has to be escaped \\.
// Perhaps the string EQUALS_BRACE could become '=}'?
terminal CODE:
    '{=' .* '=}' ;

// The following cannot be terminal because it overlaps ID.
Path:
	ID ('.' ID)* ;
