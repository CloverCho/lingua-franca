// Grammar for Lingua Franca
// The Lingua-Franca toolkit is is licensed under the BSD 2-Clause License.
// See LICENSE.md file in the top repository directory.

grammar org.icyphy.LinguaFranca with org.eclipse.xtext.common.Terminals

generate linguaFranca "http://www.icyphy.org/LinguaFranca"

/////////// Overall file
Model:
	target=Target 
	(imports += Import)*
	(reactors += Reactor)+;

/////////// Top level elements
Target:
	'target' name=ID ( '(' properties+=Property (',' properties+=Property)* ')' )? ';';
	
Import:
	'import' name=Path ';';

Reactor:
	(main?='main'? & realtime?='realtime'?) 'reactor' name=ID
   	('(' parameters+=Parameter (',' parameters+=Parameter)* ')')? '{'
   	(preamble = Preamble)?
   	((inits += Initialization) // TODO: code-gen for init
	| (states += State)
   	| (inputs += Input)
   	| (outputs += Output)
   	| (timers += Timer)
   	| (actions += Action)
   	| (instantiations += Instantiation)
   	| (connections += Connection)
   	| (deadlines += Deadline)
   	| (reactions += Reaction)
   	| (mutations += Mutation))*
   	'}';
	
/////////// Statements

// Types are optional for use in untyped languages.
State:
	'state' name=ID (':' type=Type)? ('(' value=(Literal | ID) ')') ';';

Input:
	'input' name=ID (':' type=Type)? ';';

Output:
	'output' name=ID (':' type=Type)? ';';

Timer:
	'timer' name=ID timing=Timing?';';

Action:
	origin=ActionOrigin 'action' name=ID ('(' delay=TimeOrValue ')')? (':' type=Type)? ';';
	
Reaction:
	('reaction')
	('(' (triggers+=VarRef (',' triggers+=VarRef)*)? ')')?
	(sources+=VarRef (',' sources+=VarRef)*)?
	('->' effects+=VarRef (',' effects+=VarRef)*)?
	code=CODE
	(localDeadline=LocalDeadline)?;

LocalDeadline:
    'deadline' '(' time=TimeOrValue ')' deadlineCode=CODE;
    
Mutation:
	('mutation')
	('(' (triggers+=[Trigger] (',' triggers+=[Trigger])*)? ')')?
	(sources+=[Input] (',' sources+=[Input])*)?
	('->' effects+=[Effect] (',' effects+=[Effect])*)?
	code=CODE;

Initialization: // FIXME: startup/shutdown
	('initialize')
	(sources+=[Input] (',' sources+=[Input])*)?
	('->' effects+=[Effect] (',' effects+=[Effect])*)?
	code=CODE;

Preamble:
	'preamble' code=CODE;

Instantiation:
	name=ID '=' 'new' reactorClass=[Reactor] '(' (parameters+=Assignment (',' parameters+=Assignment)*)? ')' ';' ;

Connection:
    leftPort=VarRef '->' rightPort=VarRef ';';

Deadline:
    'deadline' '(' port=VarRef ',' delay=TimeOrValue ',' action=[Action] ')' ';';

KEYWORD:
	'input' | 'state' | 'output' | 'timer' | 'action';

/////////// Pieces

Variable:
	Port | Action | Timer;

Trigger:
	Action | Input
;

Effect:
	Action | Output
;

VarRef: variable=[Variable] | container=[Instantiation] '.' variable=[Variable];

Assignment:
	(lhs=[Parameter] '=' rhs=TimeOrValue);
	
Property:
	name=ID '=' value=Literal;

// Single parameter.
Parameter:
    name=ID ((':' ofTimeType?='time' '(' time=INT (unit=TimeUnit)? ')')
           | ((':' type=Type)? '(' value=Literal ')')
            )?;

// Timing specification for a timer: (offset, period)
// Can be empty, which means (0,0) = (NOW, ONCE).
// E.g. (0) or (NOW) or (NOW, ONCE) or (100, 1000)
// The latter means fire with period 1000, offset 100.
Timing:
	'(' offset=TimeOrValue (',' period=TimeOrValue)?')';

// Time is either a reference to a parameter or an integer value, 
// a number followed by a unit specification (unless the value is zero). 
// If it is a constant, the validator should check that if the value
// is non-zero, it is accompanied by a unit.
TimeOrValue:
    (parameter=[Parameter] | value=Literal | (time=INT unit=TimeUnit));
    
Port:
    Input | Output;

// A type is in the target language, hence either an ID or target code.
Type:
    ID | CODE ;

Literal: STRING | CODE | FLOAT | INT | NEGINT;

/////////// Elementary components
// Terminals must be mutually exclusive. They are used by the lexer before parsing.

terminal NEGINT: '-'('0'..'9')+;

terminal FLOAT: '-'?('0'..'9')+'.'('0'..'9')+;

// FIXME: What if the code needs to contain '=}'?
// Just escaping with \ is not a good idea because then every \ has to be escaped \\.
// Perhaps the string EQUALS_BRACE could become '=}'?
terminal CODE:
    '{=' .* '=}' ;

// The following cannot be terminal because it overlaps ID.
Path:
	ID ('.' ID)* ;
	
/////////// Enums
enum ActionOrigin:
    LOGICAL = 'logical' | PHYSICAL = 'physical';
    
enum TimeUnit:
	NONE='empty' |
	NSEC='nsec' | NSECS='nsecs' | 
	USEC='usec' | USECS='usecs' | 
	MSEC='msec' | MSECS='msecs' | 
	SEC='sec' | SECS='secs' | SECOND='second' | SECONDS='seconds' | 
	MIN='min' | MINS='mins' | MINUTE='minute' | MINUTES='minutes' | 
	HOUR='hour' | HOURS='hours' | 
	DAY='day' | DAYS='days' | 
	WEEK='week' | WEEKS='weeks';
    