grammar org.icyphy.LinguaFranca with org.eclipse.xtext.common.Terminals

generate linguaFranca "http://www.icyphy.org/LinguaFranca"

/////////// Overall file
Model:
	target=Target 
	(imports += Import)*
	(components += Component)+
	;

/////////// Top level elements
Target:
	'target' name=ID ';';
	
Import:
	'import' name=Path ';';

Component:
	Reactor | Composite;

Reactor:
   	'reactor'
   	componentBody=ComponentBody
   	'}';
Composite:
	(modifiers += COMPOSITE_MODIFIER)*
   	'composite'
   	componentBody=ComponentBody
   	(instances += Instance)*
   	(connections += Connection)*
   	'}';
// The following enforces the order of definitions:
// inputs, outputs, timers and actions, preamble, reactions.
ComponentBody:
	name=ID parameters=Params? '{'
   	(inputs += Input)*
   	(outputs += Output)*
   	((timers += Timer) | (actions += Action))*
   	(preamble = Preamble)?
   	(reactions += Reaction)*;
	
/////////// Statements

// Note explicit allowance of keywords for names of inputs, outputs, clocks.
Input:
	'input' name=(ID | 'input') (':' type=Type)? ';';

Output:
	'output' name=(ID | 'output') (':' type=Type)? ';';

Timer:
	'timer' name=(ID | 'timer') timing=Timing?';';

Action:
	'action' name=(ID | 'action') ('(' delay=(ID | NUMBER) ')')?';';

Reaction:
	'reaction' 
	('(' (triggers+=ID (',' triggers+=ID)*)? ')')?
	gets=Gets? // FIXME: rename to 'uses'
	sets=Sets? // FIXME: rename to 'produces'
	code=CODE;
	
Preamble:
	'preamble' code=CODE;
	
// FIXME: reactorClass should ideally be something like [Reactor|Composite],
// to get cross references to work. But this doesn't work for importing
// foreign reactors that are not defined in Lingua Franca.
Instance:
	name=ID '=' 'new' actorClass=ID ('(' parameters=Assignments? ')')? ';' ;

Connection:
    leftPort=Port '->' rightPort=Port ';';

/////////// Pieces

Assignments:
	assignments+=Assignment (',' assignments+=Assignment)*;
	
Assignment:
	name=ID '=' value=Value;

// Specification of what inputs a reaction reads.
Gets:
	gets+=ID (',' gets+=ID)?;

// Parameters for actors and composites.
Params:
    '(' params+=Param (',' params+=Param)* ')';

// Single parameter.
Param:
    'const'? name=ID (':' type=Type)? ('(' value=Value ')')?;

// Timing specification for a timer: (offset, period)
// Can be empty, which means (0,0) = (NOW, ONCE).
// E.g. (0) or (NOW) or (NOW, ONCE) or (100, 1000)
// The latter means fire with period 1000, offset 100.
Timing:
	'(' offset=('NOW' | ID | NUMBER) (',' period=('ONCE' | 'STOP' | ID | NUMBER))?')';

// 'input' and 'output' are allowed port names despite being keywords.
Port:
    ID | (ID '.' (ID | 'input' | 'output'));

// Specification of what outputs a reaction writes.
Sets:
	'->' sets+=ID (',' sets+=ID)?;

// A type is in the target language, hence either an ID or target code.
Type:
    ID | CODE ;
    
Value:
    ID | NUMBER | STRING | CODE;

/////////// Elementary components
// Terminals must be mutually exclusive. They are used by the lexer before parsing.

terminal COMPOSITE_MODIFIER:
	'main' | 'threaded';

// FIXME: Can we replace this with something more general? E.g., scientific notation, hex, etc.?
terminal NUMBER:
    '-'? INT ('.' INT)? ;

// FIXME: What if the code needs to contain '=}'?
// Just escaping with \ is not a good idea because then every \ has to be escaped \\.
// Perhaps the string EQUALS_BRACE could become '=}'?
terminal CODE:
    '{=' .* '=}' ;

// The following cannot be terminal because it overlaps ID.
Path:
	ID ('.' ID)* ;
