/* The Lingua Franca grammar. */

/*************
Copyright (c) 2020, The University of California at Berkeley.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
***************/

/** 
 * Grammar for Lingua Franca.
 * @author{Marten Lohstroh <marten@berkeley.edu>}
 * @author{Edward A. Lee <eal@berkeley.edu>}
 */

grammar org.icyphy.LinguaFranca with org.eclipse.xtext.common.Terminals

generate linguaFranca "http://www.icyphy.org/LinguaFranca"

/////////// Overall file

/**
 * Top-level AST node.
 */
Model:
    target=Target
    (imports+=Import)*
    (preambles+=Preamble)*
    (reactors+=Reactor)+;

/////////// Top level elements

/**
 * Specification of the target language. Target properties can be specified in
 * YAML format to pass on configuration details to the runtime environment. 
 */
Target:
    'target' name=ID (config=KeyValuePairs)? ';';

/**
 * Import declaration.
 */
Import:
    'import' importURI=Path ';';

/**
 * Declaration of a reactor class.
 */
Reactor:
    (main?='main'? & realtime?='realtime'?) 'reactor' name=ID 
    ('<' typeParms+=ID (',' typeParms+=ID)* '>')?
    ('(' parameters+=Parameter (',' parameters+=Parameter)* ')')? '{'
    (     (preambles+=Preamble)
        | (stateVars+=StateVar)
        | (inputs+=Input)
        | (outputs+=Output)
        | (timers+=Timer)
        | (actions+=Action)
        | (instantiations+=Instantiation)
        | (connections+=Connection)
        | (reactions+=Reaction)
        | (mutations+=Mutation)
    )* '}';

/////////// Statements

/**
 * Declaration of a state variable. Types are optional, but may be required 
 * during validation (depending on the target language). Initialization is also 
 * optional. A state variable can be initialized by assigning a `TimeOrValue`, 
 * or list of these. Note that a `TimeOrValue` may also be a reference to a 
 * parameter.
 * The following checks must be carried out during validation: 
 *  - if the list of initialization values has more than one element in it, a 
 *  type must be specified;
 *  - if the `time` type is specified, there can only be a single initialization
 *  element, which has to denote a time or a reference to a parameter that
 *  denotes a time; and
 *  - if a time is specified, units must be specified as well, unless the time 
 *  value is zero.
 */
 StateVar:
    'state' name=ID (
        (':' (ofTimeType?='time' | type=Type))? 
        ('(' init+=TimeOrValue (',' init+=TimeOrValue)* ')' )?
    ) ';'    
;

Input:
    (mutable?='mutable')? 'input' name=ID (':' type=Type)? ';';

Output:
    'output' name=ID (':' type=Type)? ';';

// Timing specification for a timer: (offset, period)
// Can be empty, which means (0,0) = (NOW, ONCE).
// E.g. (0) or (NOW) or (NOW, ONCE) or (100, 1000)
// The latter means fire with period 1000, offset 100.
Timer:
    'timer' name=ID ('(' offset=TimeOrValue (',' period=TimeOrValue)? ')')? ';';

// Action that has either a physical or logical origin.
// 
// If the origin is logical, the minDelay is a minimum logical delay
// after the logical time at which schedule() is called that the
// action will occur. If the origin is physical, then the 
// minDelay is a minimum logical delay after the physical time
// at which schedule() is called that the action will occur.
//
// For all actions, minInterArrival is the minimum physical time
// to elapse between action occurrences.
Action:
    (origin=ActionOrigin)? 'action' name=ID 
    ('(' minDelay=TimeOrValue (',' minInterArrival=TimeOrValue (',' policy=QueuingPolicy)? )? ')')?
    (':' type=Type)? ';';

Reaction:
    ('reaction')
    ('(' (triggers+=TriggerRef (',' triggers+=TriggerRef)*)? ')')?
    (sources+=VarRef (',' sources+=VarRef)*)?
    ('->' effects+=VarRef (',' effects+=VarRef)*)?
    code=Code
    (deadline=Deadline)?;

TriggerRef:
    VarRef | startup?='startup' | shutdown?='shutdown';

Delay:
    'after' time=TimeOrValue;

Deadline:
    'deadline' '(' interval=TimeOrValue ')' code=Code;

Mutation:
    ('mutation')
    ('(' (triggers+=[Trigger] (',' triggers+=[Trigger])*)? ')')?
    (sources+=[Input] (',' sources+=[Input])*)?
    ('->' effects+=[Effect] (',' effects+=[Effect])*)?
    code=Code;

Preamble:
    (visibility=Visibility)? 'preamble' code=Code;

Instantiation:
    name=ID '=' 'new' 
    reactorClass=[Reactor] '(' 
    (parameters+=Assignment (',' parameters+=Assignment)*)? 
    ')' ';';

Connection:
    leftPort=VarRef '->' rightPort=VarRef (delay=Delay)? ';';

//KEYWORD:
//    'input' | 'state' | 'output' | 'timer' | 'action';
    
/////////// For target parameters

KeyValuePairs:
    '{' pairs+=KeyValuePair (',' (pairs+=KeyValuePair))* '}';

KeyValuePair:
    name=Key ':' value=Element;

Array:
    '[' elements+=Element (',' (elements+=Element))* ']';
    
Element:
    keyvalue=KeyValuePairs 
    | array=Array
    | literal=Literal 
    | (time=INT unit=TimeUnit) 
    | id=ID;

/////////// Pieces
Variable:
    Port | Action | Timer;

Trigger:
    Action | Input;

Effect:
    Action | Output;

VarRef:
    variable=[Variable]
    | container=[Instantiation] '.' variable=[Variable];

Assignment:
    (lhs=[Parameter] '=' rhs=TimeOrValue);


/**
 * Parameter declaration with optional type and mandatory initialization.
 */
Parameter:
    name=ID 
//    ((':' ofTimeType?='time' '(' time=INT (unit=TimeUnit)? ')')
//    | ((':' type=Type)? '(' value=LiteralOrCode ')'))?;
    (
        (':' ofTimeType?='time' '(' time=INT (unit=TimeUnit)? ')')
        | ((':' type=Type)? 
            '(' values+=LiteralOrCode (',' values+=LiteralOrCode)*  ')'
          ) 
    )
 ;
 
// Time is either a reference to a parameter or an integer value, 
// a number followed by a unit specification (unless the value is zero). 
// If it is a constant, the validator should check that if the value
// is non-zero, it is accompanied by a unit.
TimeOrValue:
    (parameter=[Parameter] | value=LiteralOrCode | (time=INT unit=TimeUnit));

LiteralOrCode:
    literal=Literal | code=Code;

Port:
    Input | Output;

// A type is in the target language, hence either an ID or target code.
Type:
   (id=ID (stars+='*')* (arraySpec=ArraySpec)?) | code=Code;
   
ArraySpec:
    ofVariableLength?='[]' | '[' length=INT ']';
    
terminal BOOL:
    'true' | 'false';

Literal:
    STRING | FLOAT | INT | NEGINT | BOOL;

/////////// Elementary components
// Terminals must be mutually exclusive. They are used by the lexer before parsing.

@Override
terminal SL_COMMENT: ('//' | '#') !('\n'|'\r')* ('\r'? '\n')?;

@Override
terminal ML_COMMENT: ('/*' -> '*/') | ('\'\'\'' -> '\'\'\'');

// Allow target properties to be expressed in Kebab case.
Key: ID(ID|'-')*;

terminal NEGINT:
    '-' ('0'..'9')+;

terminal FLOAT:
    '-'? ('0'..'9')+ '.' ('0'..'9')+;

// FIXME: What if the code needs to contain '=}'?
// Just escaping with \ is not a good idea because then every \ has to be escaped \\.
// Perhaps the string EQUALS_BRACE could become '=}'?

Code:
    {Code} '{=' (tokens+=Token)* '=}'
;

// The following cannot be terminal because it overlaps ID.
Path: 
    ID ('.' ID)*;

/////////// Enums
enum QueuingPolicy:
    NONE | DEFER='DEFER' | DROP='DROP' | UPDATE='UPDATE';

enum ActionOrigin:
    NONE | LOGICAL='logical' | PHYSICAL='physical';

enum Visibility:
    PRIVATE='private' | PUBLIC='public';

enum TimeUnit:
    NONE |
    NSEC='nsec' | NSECS='nsecs' |
    USEC='usec' | USECS='usecs' |
    MSEC='msec' | MSECS='msecs' |
    SEC='sec' | SECS='secs' | SECOND='second' | SECONDS='seconds' |
    MIN='min' | MINS='mins' | MINUTE='minute' | MINUTES='minutes' |
    HOUR='hour' | HOURS='hours' |
    DAY='day' | DAYS='days' |
    WEEK='week' | WEEKS='weeks';

Token:
    // Imported terminals
    ID | INT | STRING | ML_COMMENT | SL_COMMENT | WS | ANY_OTHER | 
    // Keywords
    'target' | 'import' | 'main' | 'realtime' | 'reactor' | 'state' | 'time' | 
    'mutable' | 'input' | 'output' | 'timer' | 'action' | 'reaction' | 
    'startup' | 'shutdown' | 'after' | 'deadline' | 'mutation' | 'preamble' |
    'new' |
    // Other terminals
    FLOAT | NEGINT | BOOL |
    // Queuing policies
    'DEFER' | 'DROP' | 'UPDATE' |
    // Action origins
    'logical' | 'physical' |
    // Visibility modifiers
    'private' | 'public' |
    // Time units
    'nsec' | 'nsecs' | 'usec' | 'usecs' | 'msec' | 'msecs' | 'sec' | 'secs' | 
    'second' | 'seconds' | 'min' | 'mins' | 'minute' | 'minutes' | 'hour' |
    'hours' | 'day' | 'days' | 'week' | 'weeks' |
    // Braces
    '(' | ')' | '{' | '}' |
    // Brackets
    '[' | ']' | '<' | '>' | '[]' |
    // Punctuation
    ':' | ';' | ',' | '.' |
    // Hyphen
    '-' |
    // Arrow
    '->' | 
    // Assignment
    '=' |
    // Asterisk
    '*'
;