/*
 * generated by Xtext 2.17.0
 */
// The Lingua-Franca toolkit is is licensed under the BSD 2-Clause License.
// See LICENSE.md file in the top repository directory.
package org.icyphy.generator

import java.io.File
import java.util.Hashtable
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.icyphy.linguaFranca.Import
import org.icyphy.linguaFranca.Target

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LinguaFrancaGenerator extends AbstractGenerator {
	val importTable = new Hashtable<String,String>

    // Indicator of whether generator errors occurred.
    protected var generatorErrorsOccurred = false

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// First collect all the imports.
		for (import : resource.allContents.toIterable.filter(Import)) {
			val pieces = import.name.split("\\.")
    		val root = pieces.last
    		val filename = pieces.join(File.separator)
			importTable.put(root, filename)
		}
		// Determine which target is desired.
		for (target : resource.allContents.toIterable.filter(Target)) {
		    var generator = null as GeneratorBase;
			// FIXME: Use reflection here?
			if (target.name.equalsIgnoreCase("Accessor")
					|| target.name.equalsIgnoreCase("Accessors")) {
				generator = new AccessorGenerator()
			} else if (target.name.equalsIgnoreCase("C")) {
				generator = new CGenerator()
			} else if (target.name.equalsIgnoreCase("Cpp")) {
				generator = new CppGenerator()
			} else if (target.name.equalsIgnoreCase("SCL")) {
				generator = new SCLGenerator()
            } else if (target.name.equalsIgnoreCase("TypeScript")) {
                generator = new TypeScriptGenerator()
			} else {
                System.err.println("Warning: No recognized target.")
			    throw new Exception("No recognized target.")
			}
            generator.doGenerate(resource, fsa, context)
            generatorErrorsOccurred = generator.errorsOccurred()
		}
	}
	
	/** Return true if errors occurred in the last call to doGenerate().
     *  @return True if errors occurred.
     */
    def errorsOccurred() {
        return generatorErrorsOccurred;
    }
}
