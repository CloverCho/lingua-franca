/*
 * Copyright (C) 2019 TU Dresden
 * All rights reserved.
 * 
 * The Lingua-Franca toolkit is is licensed under the BSD 2-Clause License.
 * See LICENSE.md file in the top repository directory.
 * 
 * Authors:
 *   Christian Menard
 */

package org.icyphy.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.Hashtable
import java.io.File
import java.nio.file.Paths
import org.eclipse.core.runtime.FileLocator
import java.net.URL
import org.icyphy.linguaFranca.Reactor
import java.text.SimpleDateFormat
import java.util.Date
import org.icyphy.linguaFranca.Time
import org.icyphy.linguaFranca.Timer
import org.icyphy.linguaFranca.Instance
import org.icyphy.linguaFranca.Reaction

class CppGenerator extends GeneratorBase {
	static public var timeUnitsToDearUnits = #{'nsec' -> '_ns', 'usec' -> '_us', 'msec' -> '_ms', 'sec' -> '_s',
		'secs' -> '_s', 'minute' -> '_min', 'minutes' -> '_min', 'hour' -> '_h', 'hours' -> '_h', 'day' -> '_d',
		'days' -> '_d', 'week' -> '_weeks', 'weeks' -> '_weeks'}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context,
		Hashtable<String, String> importTable) {

		super.doGenerate(resource, fsa, context, importTable)

		var srcFile = resource.getURI.toString;
		var mode = Mode.UNDEFINED;

		if (srcFile.startsWith("file:")) { // Called from command line
			srcFile = Paths.get(srcFile.substring(5)).normalize.toString
			mode = Mode.STANDALONE;
		} else if (srcFile.startsWith("platform:")) { // Called from Eclipse
			srcFile = FileLocator.toFileURL(new URL(srcFile)).toString
			srcFile = Paths.get(srcFile.substring(5)).normalize.toString
			mode = Mode.INTEGRATED;
		} else {
			System.err.println("ERROR: Source file protocol is not recognized: " + srcFile);
		}

		fsa.generateFile(_filename + File.separator + "fwd.hh", fwd_hh)
		fsa.generateFile(_filename + File.separator + "main.cc", main_cc)
		fsa.generateFile(_filename + File.separator + "CMakeLists.txt", cmake)

		for (r : _resource.allContents.toIterable.filter(Reactor)) {
			fsa.generateFile(_filename + File.separator + r.getName() + ".hh", r.generateReactorHeader)
			fsa.generateFile(_filename + File.separator + r.getName() + ".cc", r.generateReactorSource)
		}

		doCompile()
	}

	def generate(Time t) '''«t.time»«timeUnitsToDearUnits.get(t.unit)»'''

	def instantiate(Timer t) {
		if (t.timing !== null) {
			'''dear::Timer «t.name»{"«t.name»", this, «t.timing.period.generate», «t.timing.offset.generate»};'''
		} else {
			'''dear::Timer «t.name»{"«t.name»", this};'''
		}
	}

	def instantiate(Instance i) '''«i.reactorClass.name» «i.name»{"«i.name»", this};'''

	def instantiate(Reaction n, int id) '''dear::Reaction r«id»{"r«id»", «id», this, [this]() { r«id»_body(); }};'''

	def instantiateInstances(Reactor r) '''
		«FOR i : r.instances BEFORE '// reactor instances\n' AFTER '\n'»
			«i.instantiate»
		«ENDFOR»
	'''

	def instantiateTimers(Reactor r) '''
		«FOR t : r.timers BEFORE '// timers\n' AFTER '\n'»
			«t.instantiate»
		«ENDFOR»
	'''

	def instantiateReactions(Reactor r) '''
		«FOR n : r.reactions BEFORE '// reactions\n' AFTER '\n'»
			«n.instantiate(r.reactions.lastIndexOf(n))»
		«ENDFOR»
	'''

	def declareReactionBodies(Reactor r) '''
		«FOR n : r.reactions BEFORE '// reactions bodies\n' AFTER '\n'»
			void r«r.reactions.lastIndexOf(n)»_body();
		«ENDFOR»
	'''

	def implementReactionBodies(Reactor r) '''
		«FOR n : r.reactions SEPARATOR '\n'»
			void «r.name»::r«r.reactions.lastIndexOf(n)»_body() {
			  «removeCodeDelimiter(n.code)»
			}
		«ENDFOR»
	'''

	def generateReactorHeader(Reactor r) '''
		«header()»
		
		#pragma once
		
		#include "dear/dear.hh"
		
		using namespace dear::literals;
		
		«FOR i : r.instances»
			#include "«i.reactorClass.name».hh"
		«ENDFOR»
		
		class «r.getName()» : public dear::Reactor {
		 private:
		  «r.instantiateInstances»
		  «r.instantiateTimers»
		  «r.instantiateReactions»
		  «r.declareReactionBodies»
		 public:
		  «IF r.isMain()»
		  	«r.getName()»(const std::string& name, dear::Environment* environment);
		  «ELSE»
		  	«r.getName()»(const std::string& name, dear::Reactor* container);
		  «ENDIF»
		 };
	'''

	def generateReactorSource(Reactor r) '''
		«header()»
		
		#include "«r.getName».hh"
		
		«IF r.isMain()»
			«r.getName()»::«r.getName()»(const std::string& name, dear::Environment* environment)
			  : dear::Reactor(name, environment) {}
		«ELSE»
			«r.getName()»::«r.getName()»(const std::string& name, dear::Reactor* container)
			  : dear::Reactor(name, container) {}
		«ENDIF»
		
		«r.implementReactionBodies»
	'''

	def header() '''
		/*
		 * This file was autogenerated by the Lingua Franca Compiler
		 *
		 * Source: «_resource.getURI()»
		 * Date: «new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date())»
		 */
	'''

	def fwd_hh() '''
		«header()»
		
		#pragma once
		
		«FOR r : _resource.allContents.toIterable.filter(Reactor)»
			class «r.getName()»;
		«ENDFOR»
	'''

	def main_cc() '''
		«header()»
		
		#include <iostream>
		
		int main() {
			std::cout << "Hello World!" << std::endl;
			return 0;
		}
	'''

	def cmake() '''
		cmake_minimum_required(VERSION 3.5)
		project(«_filename» VERSION 1.0.0 LANGUAGES CXX)
		
		include(${CMAKE_ROOT}/Modules/ExternalProject.cmake)
		include(GNUInstallDirs)
		
		set(DEFAULT_BUILD_TYPE "Release")
		if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
		  message(STATUS "Setting build type to '${DEFAULT_BUILD_TYPE}' as none was specified.")
		  set(CMAKE_BUILD_TYPE "${DEFAULT_BUILD_TYPE}" CACHE STRING "Choose the type of build." FORCE)
		  # Set the possible values of build type for cmake-gui
		  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
		endif()
		
		if(NOT DEAR_BUILD_DIR)
		  set(DEAR_BUILD_DIR "" CACHE STRING "Choose the directory to build dear in." FORCE)
		endif()
		
		ExternalProject_Add(
		  dep-dear
		  PREFIX "${DEAR_BUILD_DIR}"
		  GIT_REPOSITORY "git@github.com:cmnrd/dear.git"
		  CMAKE_ARGS
		    -DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE}
		    -DCMAKE_INSTALL_PREFIX:PATH=${CMAKE_INSTALL_PREFIX}
		)
		
		set(DEAR_LIB_NAME "${CMAKE_SHARED_LIBRARY_PREFIX}dear${CMAKE_SHARED_LIBRARY_SUFFIX}")
		set(DEAR_LIB_DIR "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}")
		
		add_library(dear SHARED IMPORTED)
		add_dependencies(dear dep-dear)
		set_target_properties(dear PROPERTIES IMPORTED_LOCATION "${DEAR_LIB_DIR}/${DEAR_LIB_NAME}")
		
		set(CMAKE_INSTALL_RPATH "${DEAR_LIB_DIR}")
		set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
		
		add_executable(«_filename»
		  main.cc
		  «FOR r : _resource.allContents.toIterable.filter(Reactor)»
		  	«r.getName()».cc
		  «ENDFOR»
		)
		target_include_directories(«_filename» PUBLIC ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR})
		target_link_libraries(«_filename» dear)
		
		install(TARGETS «_filename»)
	'''

	def void doCompile() {
		var makeCmd = newArrayList()
		var cmakeCmd = newArrayList()

		var cwd = Paths.get("").toAbsolutePath().toString()
		var srcPath = cwd + File.separator + "src-gen" + File.separator + _filename
		var buildPath = cwd + File.separator + "build" + File.separator + _filename
		var dearPath = cwd + File.separator + "build" + File.separator + "dear"

		makeCmd.addAll("make", "install")
		cmakeCmd.addAll("cmake", "-DCMAKE_INSTALL_PREFIX=" + cwd, "-DDEAR_BUILD_DIR=" + dearPath, srcPath)

		var buildDir = new File(buildPath)
		if(!buildDir.exists()) buildDir.mkdirs()

		println("--- Running cmake:")
		var cmakeBuilder = new ProcessBuilder(cmakeCmd)
		cmakeBuilder.directory(buildDir)
		var cmakeProcess = cmakeBuilder.inheritIO().start()
		cmakeProcess.waitFor()

		if (cmakeProcess.exitValue() == 0) {
			println("--- Running make:")
			var makeBuilder = new ProcessBuilder(makeCmd)
			makeBuilder.directory(buildDir)
			var makeProcess = makeBuilder.inheritIO().start()
			makeProcess.waitFor()

			if (makeProcess.exitValue() == 0) {
				println("SUCCESS (compiling generated C++ code)")
			} else {
				println("ERRROR (while compiling generated C++ code)")
			}
		} else {
			println("ERRROR (while executing cmake)")
		}
	}
}
