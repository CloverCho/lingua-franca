/*
 * generated by Xtext 2.18.0
 */
package org.icyphy.generator

import com.google.inject.Inject
import com.google.inject.Provider
import java.io.BufferedReader
import java.io.File
import java.io.FileReader
import java.io.IOException
import java.util.regex.Pattern
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.GeneratorContext
import org.eclipse.xtext.generator.GeneratorDelegate
import org.eclipse.xtext.generator.JavaIoFileSystemAccess
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.validation.CheckMode
import org.eclipse.xtext.validation.IResourceValidator
import org.icyphy.LinguaFrancaStandaloneSetup

class Main {

	def static main(String[] args) {
		// FIXME: perhaps accept a `-o` flag here
		if (args.empty) {
			System::err.println('Aborting: no path to EMF resource provided!')
			return
		}
		val injector = new LinguaFrancaStandaloneSetup().createInjectorAndDoEMFRegistration
		val main = injector.getInstance(Main)
		main.runGenerator(args.get(0))
	}

	@Inject Provider<ResourceSet> resourceSetProvider

	@Inject IResourceValidator validator

	@Inject GeneratorDelegate generator

	@Inject JavaIoFileSystemAccess fileAccess

	def protected runGenerator(String string) {
		// Load the resource
		val set = resourceSetProvider.get
		val fileRoot = (new File("")).getAbsolutePath()
		val fileName = fileRoot + File.separator + string;
		val resource = set.getResource(URI.createFileURI(fileName), true)

		// Read the code
		val code = new StringBuilder();
		try(val reader = new BufferedReader(new FileReader(fileName))) {
			var String line;
			while ((line = reader.readLine()) !== null) {
				code.append(line).append("\n");
			}
		} catch (IOException e) {
			System::err.println('Aborting. Unable to read file: ' + fileName);
		}

		// Parse out imports and add them to a list
		// RegEx based on org.eclipse.xtext.common.Terminals
		val id = "(?:([a-z]|[A-Z]|_)\\w*)";
		// RegEx based on LinguaFranca.xtext
		val pattern = Pattern.compile("import(?:\\s)*(" + id + "(?:." + id + ")*)\\s*;");
		val matcher = pattern.matcher(code);

		val imports = newArrayList();
		while (matcher.find) {
			imports.add(matcher.group(1));
		}

		// Add the listed imports to the resource
		for (import : imports) {
			set.getResource(URI.createFileURI(fileRoot + File.separator + import), true)
		}

		// Validate the resource
		val issues = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl)
		if (!issues.empty) {
			System::err.println('Aborting. Unable to validate resource.');
			issues.forEach[System.err.println(it)]
			return
		}

		// Configure and start the generator
		fileAccess.outputPath = '../src-gen/'
		val context = new GeneratorContext => [
			cancelIndicator = CancelIndicator.NullImpl
		]
		// FIXME: perhaps use context to pass in additional arguments?
		generator.generate(resource, fileAccess, context)
		System.out.println('Code generation finished.')
	}
}
