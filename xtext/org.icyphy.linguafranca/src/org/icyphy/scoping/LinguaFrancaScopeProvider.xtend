/*
 * generated by Xtext 2.17.0
 */
package org.icyphy.scoping

import com.google.inject.Inject
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.SimpleNameProvider
import org.eclipse.xtext.scoping.Scopes
import org.icyphy.linguaFranca.Connection
import org.icyphy.linguaFranca.Deadline
import org.icyphy.linguaFranca.Reaction
import org.icyphy.linguaFranca.Reactor
import org.icyphy.linguaFranca.VarRef

/**
 * This class enforces custom rules. In particular, it resolves references to 
 * ports, actions, and timers. Ports can be referenced across at most one level
 * of hierarchy. Only local actions and timers can be referenced.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 * @author Marten Lohstroh
 */
class LinguaFrancaScopeProvider extends AbstractLinguaFrancaScopeProvider {

	@Inject SimpleNameProvider nameProvider

	protected enum RefType {
		NULL,
		TRIGGER,
		SOURCE,
		EFFECT,
		DEADLINE,
		CLEFT,
		CRIGHT,
		PARM
	}

	override getScope(EObject context, EReference reference) {
		switch (context) {
			VarRef: return getScopeForVarRef(context, reference)
		}
		return super.getScope(context, reference);
	}

	protected def getScopeForVarRef(VarRef variable, EReference reference) {
		if (reference.name.equals("variable")) { // Resolve hierarchical reference
			val candidates = new ArrayList<EObject>()
			var type = RefType.NULL
			var reactor = null as Reactor
			
			if (variable.eContainer.eContainer instanceof Reactor) {
				reactor = variable.eContainer.eContainer as Reactor	
			} else {
				return Scopes.scopeFor([])
			}
			
			if (variable.eContainer instanceof Deadline) {
				type = RefType.DEADLINE
			} else if (variable.eContainer instanceof Reaction) {
				val reaction = variable.eContainer as Reaction
				if (reaction.triggers.contains(variable)) {
					type = RefType.TRIGGER
				} else if (reaction.sources.contains(variable)) {
					type = RefType.SOURCE
				} else if (reaction.effects.contains(variable)) {
					type = RefType.EFFECT
				}
			} else if (variable.eContainer instanceof Connection) {
				val conn = variable.eContainer as Connection
				if (conn.leftPort === variable) {
					type = RefType.CLEFT
				} else if (conn.rightPort === variable) {
					type = RefType.CRIGHT
				}
			}
			
			if (variable.instance !== null) { // Resolve hierarchical port reference
				val instanceName = nameProvider.getFullyQualifiedName(variable.instance).toString
				val instances = reactor.instances
				for (instance : instances) {
					if (instance.name.equals(instanceName)) {
						if (type == RefType.TRIGGER || type == RefType.SOURCE || type == RefType.CLEFT) {
							return Scopes.scopeFor(instance.reactorClass.outputs)
						} else if (type == RefType.EFFECT || type == RefType.DEADLINE || type == RefType.CRIGHT) {
							return Scopes.scopeFor(instance.reactorClass.inputs)
						} else {
							return Scopes.scopeFor(candidates) // empty set
						}
					}
				}
			} else { // Resolve local reference
				switch (type) {
					case RefType.TRIGGER: {
						candidates.addAll(reactor.inputs)
						candidates.addAll(reactor.actions)
						candidates.addAll(reactor.timers)
					}
					case RefType.SOURCE:
						return super.getScope(variable, reference)
					case RefType.EFFECT: {
						candidates.addAll(reactor.outputs)
						candidates.addAll(reactor.actions)
					}
					case RefType.DEADLINE:
						return Scopes.scopeFor(reactor.inputs)
					case RefType.CLEFT:
						return Scopes.scopeFor(reactor.inputs)
					case RefType.CRIGHT:
						return Scopes.scopeFor(reactor.outputs)
					default: {
					}
				}
				return Scopes.scopeFor(candidates)
			}
		} else { // Resolve instance
			return super.getScope(variable, reference)
		}
	}

//	protected def getScopeForEffectRef(EffectRef effect, EReference reference) {
//		if (reference.name.equals("variable")) { // Resolve hierarchical port reference
//			val reactor = effect.eContainer.eContainer as Reactor;
//			if (effect.instance !== null) {
//				val instanceName = nameProvider.getFullyQualifiedName(effect.instance).toString;
//				val instances = reactor.instances;
//				for (instance : instances) {
//					if (instance.name.equals(instanceName)) {
//						return Scopes.scopeFor(instance.reactorClass.inputs);
//					}
//				}
//			} else { // Resolve local port reference or action
//				val candidates = new ArrayList<EObject>();
//				candidates.addAll(reactor.outputs)
//				candidates.addAll(reactor.actions)
//				return Scopes.scopeFor(candidates)
//			}
//		} else { // Resolve instance
//			return super.getScope(effect, reference);
//		}
//	}
//	protected def getScopeForConnEnd(ConnEnd effect, EReference reference) {
//		if (reference.name.equals("variable")) { // Resolve hierarchical port reference
//			val reactor = effect.eContainer.eContainer as Reactor;
//			if (effect.instance !== null) {
//				val instanceName = nameProvider.getFullyQualifiedName(effect.instance).toString;
//				val instances = reactor.instances;
//				for (instance : instances) {
//					if (instance.name.equals(instanceName)) {
//						return Scopes.scopeFor(instance.reactorClass.inputs);
//					}
//				}
//			} else { // Resolve local port reference
//				val candidates = new ArrayList<EObject>();
//				candidates.addAll(reactor.outputs)
//				return Scopes.scopeFor(candidates)
//			}
//		} else { // Resolve instance
//			return super.getScope(effect, reference);
//		}
//	}
//
//	protected def getScopeForConnStart(ConnStart effect, EReference reference) {
//		if (reference.name.equals("variable")) { // Resolve hierarchical port reference
//			val reactor = effect.eContainer.eContainer as Reactor;
//			if (effect.instance !== null) {
//				val instanceName = nameProvider.getFullyQualifiedName(effect.instance).toString;
//				val instances = reactor.instances;
//				for (instance : instances) {
//					if (instance.name.equals(instanceName)) {
//						return Scopes.scopeFor(instance.reactorClass.outputs);
//					}
//				}
//			} else { // Resolve local port reference
//				val candidates = new ArrayList<EObject>();
//				candidates.addAll(reactor.inputs)
//				return Scopes.scopeFor(candidates)
//			}
//		} else { // Resolve instance
//			return super.getScope(effect, reference);
//		}
//	}

//	protected def getScopeForTriggerRef(TriggerRef trigger, EReference reference) {
//		if (reference.name.equals("variable")) { // Resolve hierarchical port reference
//			val reactor = trigger.eContainer.eContainer as Reactor;
//			if (trigger.instance !== null) {
//				val instanceName = nameProvider.getFullyQualifiedName(trigger.instance).toString;
//				val instances = reactor.instances;
//				for (instance : instances) {
//					if (instance.name.equals(instanceName)) {
//						if (trigger.eContainer instanceof Reaction && (trigger.eContainer as Reaction).triggers.contains(trigger)) {
//							return Scopes.scopeFor(instance.reactorClass.outputs);
//						}
//					}
//				}
//			} else { // Resolve local port reference, action, or timer
//				val candidates = new ArrayList<EObject>();
//				if (trigger.eContainer instanceof Reaction && (trigger.eContainer as Reaction).triggers.contains(trigger)) { // FIXME: handle all Refs in the same style
//					candidates.addAll(reactor.inputs)
//					candidates.addAll(reactor.actions)
//					candidates.addAll(reactor.timers)
//				}
//				return Scopes.scopeFor(candidates)
//			}
//		} else { // Resolve instance
//			return super.getScope(trigger, reference);
//		}
//	}
//
//	protected def IScope getScopeForSourceRef(SourceRef source, EReference reference) {
//		if (reference.name.equals("port")) { // Resolve hierarchical port reference
//			val reactor = source.eContainer.eContainer as Reactor;
//			if (source.instance !== null) {
//				val instanceName = nameProvider.getFullyQualifiedName(source.instance).toString;
//				val instances = reactor.instances;
//				for (instance : instances) {
//					if (instance.name.equals(instanceName)) {
//						return Scopes.scopeFor(instance.reactorClass.outputs);
//					}
//				}
//			} else { // Resolve local port reference
//				return Scopes.scopeFor(reactor.inputs)
//			}
//		} else { // Resolve instance
//			return super.getScope(source, reference);
//		}
//	}
}
