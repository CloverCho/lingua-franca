// Test asynchronous callbacks that trigger a physical action.
// This test case assumes that target is multithreaded.
// This test will not work with the unthreaded C target because that target
// does not implement any mutex protecting the event queue.
target C(
	threads = 1,
	run = "./AsyncCallback -timeout 2 sec"
);

reactor Main {
	
	preamble {=
		#include <pthread.h>
				
		void callback(void* a) {
			schedule(a, 0, NULL);
		}
		// Simulate time passing before a callback occurs.
		void* take_time(void* a) {
			struct timespec sleep_time = {(time_t) 0, (long)200000000};
			struct timespec remaining_time;
			nanosleep(&sleep_time, &remaining_time);
			callback(a);
			return NULL;
		}
		
	=}
	
	timer t(0, 200 msec);
	physical action a:int;
	state i:int(0);
	reaction(t) -> a {=
		pthread_t threadId;
		// start new thread, provide callback
		pthread_create(&threadId, NULL, &take_time, a);
	=}
	
	reaction(a) {=
		instant_t elapsed_time = get_elapsed_logical_time();
		printf("Asynchronous callback %d: Assigned logical time greater than start time by %lld nsec.\n", self->i++, elapsed_time);	
	=}
}
