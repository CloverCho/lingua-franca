import {Args, Present, Parameter, State, Variable, Priority, Mutation, Util, Readable, Schedulable, Triggers, Writable, Named, Reaction, Action, Startup, Scheduler, Timer, Reactor, Port, OutPort, InPort, App } from "./reactor";
import {TimeUnit, TimeValue, UnitBasedTimeValue, Tag, Origin } from "./time"
import {Log} from "./util"

Log.setGlobalLevel(Log.levels.ERROR);
// Code generated by the Lingua Franca compiler for reactor Destination in /Users/matt.weber/git/lingua-franca/xtext/org.icyphy.linguafranca/src/test/TS/Microsteps.lf
// =============== START reactor class Destination
export class Destination extends Reactor {
    x: InPort<number>;
    y: InPort<number>;
    constructor (parent:Reactor) {
        super(parent);
        this.x = new InPort<number>(this);
        this.y = new InPort<number>(this);
        this.addReaction(
            new Triggers(this.x, this.y),
            new Args(this.y, this.x),
            function (this, __y: Readable<number>, __x: Readable<number>) {
                // =============== START react prologue
                let y = __y.get();
                let x = __x.get();
                // =============== END react prologue
                try {
                    let elapsed = this.util.time.getElapsedLogicalTime();
                    console.log("Time since start: " + elapsed);
                    if (! elapsed.isEqualTo(new UnitBasedTimeValue( 0, TimeUnit.sec ))) {
                        console.log("Expected elapsed time to be 0, but it was " + elapsed);
                        this.util.exec.failure();
                    }
                    let count = 0;
                    if (x) {
                        console.log("x is present.");
                        count++;
                    }
                    if (y) {
                        console.log("y is present.");
                        count++;
                    }
                    if (count != 1) {
                        console.log("Expected exactly one input to be present but got " + count);
                        this.util.exec.failure();
                    }
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Destination

// Code generated by the Lingua Franca compiler for reactor Microsteps in /Users/matt.weber/git/lingua-franca/xtext/org.icyphy.linguafranca/src/test/TS/Microsteps.lf
// =============== START reactor class Microsteps
export class Microsteps extends App {
    d: Destination
    start: Timer;
    repeat: Action<Present>;
    constructor (name: string, timeout: TimeValue | undefined = undefined, keepAlive: boolean = false, fast: boolean = false, success?: () => void, fail?: () => void) {
        super(timeout, keepAlive, fast, success, fail);
        this.d = new Destination(this)
        this.start = new Timer(this, 0, 0);
        this.repeat = new Action<Present>(this, Origin.logical);
        this.addReaction(
            new Triggers(this.start),
            new Args(this.start, this.getSchedulable(this.repeat), { x: this.getWritable(this.d.x) }),
            function (this, __start: Readable<Tag>, repeat: Schedulable<Present>, __d: { x: Writable<number> }) {
                // =============== START react prologue
                let start = __start.get();
                let d = {x: __d.x};
                // =============== END react prologue
                try {
                    d.x.set(1);
                    repeat.schedule(0);
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
        this.addReaction(
            new Triggers(this.repeat),
            new Args(this.repeat, { y: this.getWritable(this.d.y) }),
            function (this, __repeat: Readable<Present>, __d: { y: Writable<number> }) {
                // =============== START react prologue
                let repeat = __repeat.get();
                let d = {y: __d.y};
                // =============== END react prologue
                try {
                    d.y.set(1);
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class Microsteps

// ************* Instance Microsteps of class Microsteps
let _app = new Microsteps('Microsteps', undefined, false, false)
// ************* Starting Runtime for Microsteps of class Microsteps
_app._start();
