/*
 * Tests for the Lingua Franca code generator.
 */
package org.icyphy.tests

import com.google.inject.Inject
import java.io.BufferedReader
import java.io.IOException
import java.io.InputStreamReader
import java.util.LinkedList
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.InMemoryFileSystemAccess
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.icyphy.generator.LinguaFrancaGenerator
import org.icyphy.linguaFranca.Model
import org.junit.Test
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.^extension.ExtendWith
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@ExtendWith(InjectionExtension)
@InjectWith(LinguaFrancaInjectorProvider)
class LinguaFrancaGeneratorTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Inject
	LinguaFrancaGenerator generator
	
	@Test
	def void checkCCompiler() {
		var target = "C"
		var testFiles = readTestFiles(target)
		Assertions.assertNotNull(testFiles, "Couldn't find testFiles.txt file for target: " + target)
		
		var errors = new LinkedList<String>()
		var testCount = 0
		for (file: testFiles) {
			testCount++
			compileAndRun(target, file, errors)
		}
		var message = '''Errors: «errors.length» out of «testCount» tests:
* «errors.join("\n* ")»'''
		if (!errors.isEmpty) {
			println("FAILURE:\n" + message)
		}
		Assertions.assertTrue(errors.isEmpty, message)
		println('''SUCCESS. Number of compile and run tests: «testCount»''')
	}
	
	/** Compile the specified test file for the specified target
	 *  and append any encountered errors to the specified list of errors.
	 *  @param target The target.
	 *  @param file The Lingua Franca file name.
	 *  @param errors A list to which to append errors.
	 */
	private def compileAndRun(String target, String file, LinkedList<String> errors) {
        var code = readTestFile(target, file)
        if (code === null) {
        	errors.add("Couldn't find test file: " + file + " for target: " + target)
        	return
        }
        // Check that the file parses.
        println("*** Parsing test file: " + file)
        val parsed = parseHelper.parse(code)
        if (parsed === null) {
        	errors.add('''Parser returned null on file «file».''')
        	return
        }
        val parseErrors = parsed.eResource.errors
        if (!parseErrors.isEmpty) {
        	errors.add('''Parse errors in «file»:
*** «parseErrors.join("\n*** ")»''')
        	return
        }
        
        // Check that code is generated.
        // Give the resource a file name.
        println("Generating code for test file: " + file)
        parsed.eResource.setURI(URI.createURI("platform:/" + file))
        // Create an in-memory filesystem for the result.
        var fsa = new InMemoryFileSystemAccess();
        // Generate the code.
        // FIXME: What is the third argument ("context", not documented anywhere).
        generator.doGenerate(parsed.eResource, fsa, null)
        // Retrieve the generated file.
        var allFiles = fsa.getAllFiles();
        if (fsa.getAllFiles().size() !== 1) {
        	errors.add('''No file generated by the compiler for test file: «file»''')
        	return
        }
 		// Check the resulting filename.
 		var rootFilename = file.substring(0, file.length - 3)
 		if (!allFiles.containsKey(IFileSystemAccess.DEFAULT_OUTPUT + rootFilename + ".c")) {
            errors.add('''Expected file with name «rootFilename + ".c"». But got «allFiles.keySet.join(", ")».''')
            return
    	}
	}
	
	/** Read the "testFiles.txt" file in the test directory for the specified
	 *  target language and return a list of the filenames for tests in that
	 *  directory.
	 *  @param target The target name.
	 *  @return A list of test files, or null if the testFiles.txt file was not found.
	 */
	private def readTestFiles(String target) {
		var inputStream = this.class.getResourceAsStream("/test/" + target + "/testFiles.txt")
		if (inputStream === null) {
			return null
		}
		try {
 			var result = new LinkedList<String>()
			// The following reads a file relative to the classpath.
			// The file needs to be in the src directory.
    		var reader = new BufferedReader(new InputStreamReader(inputStream))
        	var line = ""
        	while ((line = reader.readLine()) !== null) {
            	result.add(line);
        	}
			return result
        } finally {
        	inputStream.close
        }
	}
	
	/** Read a test file for the specified target and return its contents.
	 *  @param target The target name.
	 *  @param filename The file name.
	 *  @return The contents of the file as a String or null if the file cannot be opened.
	 */
	private def readTestFile(String target, String filename) throws IOException {
		var inputStream = this.class.getResourceAsStream("/test/" + target + "/" + filename)
		if (inputStream === null) {
			return null
		}
		try {
    		var resultStringBuilder = new StringBuilder()
			// The following reads a file relative to the classpath.
			// The file needs to be in the src directory.
    		var reader = new BufferedReader(new InputStreamReader(inputStream))
        	var line = ""
        	while ((line = reader.readLine()) !== null) {
            	resultStringBuilder.append(line).append("\n");
        	}
			return resultStringBuilder.toString();
        } finally {
        	inputStream.close
        }
	}
}
