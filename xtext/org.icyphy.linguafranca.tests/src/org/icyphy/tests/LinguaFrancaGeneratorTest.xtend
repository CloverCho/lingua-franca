/*
 * Tests for the Lingua Franca code generator.
 */
package org.icyphy.tests

import com.google.inject.Inject
import java.io.BufferedReader
import java.io.IOException
import java.io.InputStreamReader
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.LinkedList
import org.eclipse.emf.common.util.URI
import org.eclipse.xtext.generator.GeneratorContext
import org.eclipse.xtext.generator.InMemoryFileSystemAccess
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.icyphy.generator.LinguaFrancaGenerator
import org.icyphy.linguaFranca.Model
import org.junit.Test
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.^extension.ExtendWith
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@ExtendWith(InjectionExtension)
@InjectWith(LinguaFrancaInjectorProvider)
class LinguaFrancaGeneratorTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Inject
	LinguaFrancaGenerator generator
	
	@Test
	def void checkCCompiler() {
		var target = "C"
		var testFiles = readTestFiles(target)
		Assertions.assertNotNull(testFiles, "Couldn't find testFiles.txt file for target: " + target)
		
		var errors = new LinkedList<String>()
		var testCount = 0
     	// Write the generated code to a temporary directory.
    	var directory = Files.createTempDirectory("linguafranca")
    	// FIXME: The following causes the files to be deleted as soon as the test is done.
    	// Probably don't want that while debugging.
    	// directory.toFile.deleteOnExit
    	println("Writing code to temporary directory: " + directory)
		for (file: testFiles) {
			testCount++
			compileAndRun(target, file, directory, errors)
		}
		var message = '''Errors: «errors.length» out of «testCount» tests:
* «errors.join("\n* ")»'''
		if (!errors.isEmpty) {
			println("FAILURE:\n" + message)
		}
		Assertions.assertTrue(errors.isEmpty, message)
		println('''SUCCESS. Number of compile and run tests: «testCount»''')
	}
	
	/** Compile the specified test file for the specified target
	 *  and append any encountered errors to the specified list of errors.
	 *  @param target The target.
	 *  @param file The Lingua Franca file name.
	 *  @param directory The directory into which to write temporary files.
	 *  @param errors A list to which to append errors.
	 */
	private def compileAndRun(
		String target, String file, Path directory, LinkedList<String> errors
	) {
        var code = readTestFile(target, file)
        if (code === null) {
        	errors.add("Couldn't find test file: " + file + " for target: " + target)
        	return
        }
        // Check that the file parses.
        println("*** Parsing test file: " + file)
        val parsed = parseHelper.parse(code)
        if (parsed === null) {
        	errors.add('''Parser returned null on file «file».''')
        	return
        }
        val parseErrors = parsed.eResource.errors
        if (!parseErrors.isEmpty) {
        	errors.add('''Parse errors in «file»:
*** «parseErrors.join("\n*** ")»''')
        	return
        }
        
        // Check that code is generated.
        // Give the resource a file name.
        println("Generating code for test file: " + file)
        parsed.eResource.setURI(URI.createURI("platform:/" + file))
        // Create an in-memory filesystem for the result.
        var fsa = new InMemoryFileSystemAccess()
        
        // Generate the code.
        // FIXME: What is the third argument ("context", not documented anywhere).
        generator.doGenerate(parsed.eResource, fsa, new GeneratorContext())
        // Retrieve the generated file.
        var allFiles = fsa.getAllFiles();
        if (fsa.getAllFiles().size() !== 1) {
        	errors.add('''No file generated by the compiler for test file: «file»''')
        	return
        }
    	// Write generated files to the temporary directory.
    	for (generatedFile: allFiles.keySet) {
    		// For some inexplicable reason, xtext's InMemoryFileSystemAccess
    		// prefixes all the file names with "DEFAULT_OUTPUT". Remove that junk.
    		var cleanFilename = generatedFile
    		if (generatedFile.startsWith("DEFAULT_OUTPUT")) {
    			cleanFilename = generatedFile.substring(14)
    		}
    		var destinationCodeFile = Files.createFile(Paths.get(directory.toString, cleanFilename))
    		// FIXME: The following causes the files to be deleted as soon as the test is done.
    		// Probably don't want that while debugging.
    		// destinationCodeFile.toFile.deleteOnExit
    		
    		// Read the generated code and write it to the temporary directory.
   			// Second argument is not documented anywhere in xtext.
   			// It is an "output configuration name", whatever the hell that is.
   			var sourceCode = fsa.readTextFile(generatedFile, "")
    		var sourceCodeAsList = new LinkedList<CharSequence>()
   			sourceCodeAsList.add(sourceCode)
   			Files.write(destinationCodeFile, sourceCodeAsList)
   			
   			// Invoke the compiler on the generated code.
   			// FIXME
    	}
	}
	
	/** Read the "testFiles.txt" file in the test directory for the specified
	 *  target language and return a list of the filenames for tests in that
	 *  directory.
	 *  @param target The target name.
	 *  @return A list of test files, or null if the testFiles.txt file was not found.
	 */
	private def readTestFiles(String target) {
		var inputStream = this.class.getResourceAsStream("/test/" + target + "/testFiles.txt")
		if (inputStream === null) {
			return null
		}
		try {
 			var result = new LinkedList<String>()
			// The following reads a file relative to the classpath.
			// The file needs to be in the src directory.
    		var reader = new BufferedReader(new InputStreamReader(inputStream))
        	var line = ""
        	while ((line = reader.readLine()) !== null) {
            	result.add(line);
        	}
			return result
        } finally {
        	inputStream.close
        }
	}
	
	/** Read a test file for the specified target and return its contents.
	 *  @param target The target name.
	 *  @param filename The file name.
	 *  @return The contents of the file as a String or null if the file cannot be opened.
	 */
	private def readTestFile(String target, String filename) throws IOException {
		var inputStream = this.class.getResourceAsStream("/test/" + target + "/" + filename)
		if (inputStream === null) {
			return null
		}
		try {
    		var resultStringBuilder = new StringBuilder()
			// The following reads a file relative to the classpath.
			// The file needs to be in the src directory.
    		var reader = new BufferedReader(new InputStreamReader(inputStream))
        	var line = ""
        	while ((line = reader.readLine()) !== null) {
            	resultStringBuilder.append(line).append("\n");
        	}
			return resultStringBuilder.toString();
        } finally {
        	inputStream.close
        }
	}
}
