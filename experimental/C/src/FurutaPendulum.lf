target C;
preamble {=
    #include <math.h>
    double sign(double x) {
        return (x > 0.0) - (x < 0.0);
    }
=}
reactor Sensor {
    output angle:double;
    output d_angle:double;
}
reactor Actuator {
    input control:double;
}
reactor Controller(
    h:double(0.005), // Sample interval
    w0:double(6.3),
    k:double(1.0),   // Energy multiplier to swing up.
    n:double(0.5),   // Bound on swing up control magnitude.
    region1:double(0.1),   // Region to exit SwingUp.
    region2:double(0.2),   // Region to exit Stabilize.
    maxSpeed:double(0.05), // Speed to exit Catch.
    ci1:double(-1.04945717118225),
    ci2:double(-0.20432286791216),
    ci3:double(-0.00735846749875),
    ci4:double(-0.00735846749875),
    si1:double(-1.70871686211144),
    si2:double(-0.30395427746831),
    si3:double(-0.03254225945714),
    si4:double(-0.05808270221773),
    phi2:double(-7.0124562)
) {
    input theta:double;
    input d_theta:double;
    input phi:double;
    input d_phi:double;
    
    output control:double; 
    
    state phi0:double(0.0);
    
    initial mode Initial {
        reaction(startup) -> control, SwingUp {=
            SET(control, 0.0);
            SET_MODE(SwingUp);            
        =}
    }
    
    mode SwingUp {
        reaction(theta, d_theta) -> control, Catch {=
            double E = 0.5 * d_theta->value * d_theta->value / (self->w0 * self->w0)
                    + cos(theta->value) - 1.0;
            double c = sign(d_theta->value * cos(theta->value));
            double out = sign(E) * MIN(fabs(self->k * E), self->n) * c;
            SET(control, out);
            
            if (fabs(theta->value) < self->region1) {
                SET_MODE(Catch);
            }
        =}
    }
    
    mode Catch {
        reaction(theta, d_theta, phi, d_phi) -> control, Stabilize {=
            SET(control, -1.0 * (
                theta->value * self->ci1
                + d_theta->value * self->ci2
                + (phi->value - self->phi2) * self->ci3
                + d_phi->value * self->ci4
            ));
            if (fabs(d_phi->value) < self->maxSpeed) {
                SET_MODE(Stabilize);
                self->phi0 = phi->value;
            }
        =}
    }

    mode Stabilize {
        reaction(theta, d_theta, phi, d_phi) -> control, SwingUp {=
            SET(control, -1.0 * (
                theta->value * self->si1
                + d_theta->value * self->si2
                + (phi->value - self->phi0) * self->si3
                + d_phi->value * self->si4
            ));
            
            if (fabs(theta->value) > self->region2) {
                SET_MODE(SwingUp);
            }
        =}
    }
}
main reactor {
    s1 = new Sensor();
    s2 = new Sensor();
    a = new Actuator();
    c = new Controller();
    
    s1.angle, s1.d_angle -> c.theta, c.d_theta;
    s2.angle, s2.d_angle -> c.phi, c.d_phi;
    
    c.control -> a.control;
}