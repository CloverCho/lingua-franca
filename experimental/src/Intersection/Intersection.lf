/**
 * Model of a smart intersection with a road-side unit (RSU)
 * that regulates the flow of automated vehicles through the
 * intersection. Vehicles that are approaching the intersection
 * send an initial message to the RTU with their speed and
 * distance to the intersection. The RTU responds with a
 * reservation for when the vehicle can enter the intersection
 * and what its average speed through the intersection should be.
 * 
 * This is meant as a supervisory controller, and it assumes that
 * the vehicle is equipped with a low-level controller (or a human)
 * that is responsible for lane keeping, collision avoidance, etc.
 * 
 * This is a very rough starting point that needs a lot of work.
 */
target C {
    timeout: 5 sec,
    flags: ["-lm"]
}

preamble {=
    #include <math.h>
    
    typedef struct {
        double x;
        double y;
        double z;
    } coordinate_t;
    
    double distance (coordinate_t coordinate1, coordinate_t coordinate2) {
        double sqr_x = coordinate2.x - coordinate1.x;
        double sqr_y = coordinate2.y - coordinate1.y;
        double sqr_z = coordinate2.z - coordinate1.z;
        
        return sqrt(sqr_x + sqr_y + sqr_z);
    }
    
    typedef struct {
        double speed;
        coordinate_t current_pos; // Current GPS position of the vehicle;
    } request_message_t;
    
    typedef struct {
        // Average speed vehicle should maintain in the intersection.
        double target_speed;  // FIXME: Deadline.  = t/w
        // Time at which the vehicle can enter the intersection.
        instant_t arrival_time;
    } grant_message_t;
    
            
    typedef struct {
        // The CARLA vehicle control data
        // Target velocity in the x direction
        float x_target_velocity;
        // FIXME velocity in the y and z direction
        // FIXME angular velocity  (x, y, z)

		// 0. <= throttle <= 1.
		// float throttle;
		
		// -1. <= steer <= 1.
		// float steer;
		
		// 0. <= brake <= 1.
		// float brake;
		
		// hand_brake 0 or 1
		// bool hand_brake;
		
		// reverse 0 or 1
		// bool reverse;
		
		// gear
		// int gear;
		
		// manual gear shift
		// bool manual_gear_shift;
    } vehicle_command_t;
    
    typedef struct {
        float velocity; // Velocity of the vehicle in m/s
        // Fetching acceleration and orientation is also possible,
        // but both involve very complex structures.
        coordinate_t current_pos; // Current GPS position of the vehicle
    } vehicle_status_t;
    
    #define SAFETY_THRESHOLD MSEC(200)
=}

reactor Vehicle (
    speed:double(42.0)    // in km per hour. About 11.7 m/sec
) {
    input vehicle_stat:vehicle_status_t;

    input grant:grant_message_t;
    
    output request:request_message_t;    
    
    output control:vehicle_command_t;
    
    logical action delay;
    
    state current_pos:coordinate_t;
    
    // Give an initial velocity to the vehicle, for testing purposes
    reaction(startup) -> control, request {=
        float init_velocity = self->speed / 3.6;
        
        vehicle_command_t command = (vehicle_command_t) {
            .x_target_velocity = init_velocity
        };
        SET(control, command);
    =} 
    
    reaction(vehicle_stat) -> request {=        
        // Record the speed (convert from m/h to km/h)
        self->speed = vehicle_stat->value.velocity * 3.6;
        self->current_pos = vehicle_stat->value.current_pos;
        
        request_message_t message;
       	message.speed = self->speed;
       	message.current_pos = self->current_pos;
       	SET(request, message);
    =}
    
    reaction(grant) -> control {=
        
        // Prepare and send the target velocity as a vehicle command
        vehicle_command_t cmd = {
            .x_target_velocity = grant->value.target_speed
        };
        SET(control, cmd);
        
        info_print("Granted access at elapsed logical time %lld. Physical time is %lld. "
            "Setting target velocity to %d.",
            get_elapsed_logical_time(),
            get_elapsed_physical_time(),
            grant->value.target_speed
        );
    =}
}

reactor RSU (
	num_entries:int(4),
	intersection_width:double(42.0), // in meters.
	// If the vehicle is told to slow down, then its target
	// average speed in the intersection should be at least this.
	nominal_speed_in_intersection:double(10.0), // In km/hr. 2.8 m/sec. 15 sec to traverse.
	intersection_pos:coordinate_t({=(coordinate_t){0,0,0}=}) // GPS coordinates for the intersection
) {
    input[num_entries] request:request_message_t;
    output[num_entries] grant:grant_message_t;
    
    state earliest_free:time(0);
    
    reaction(request) -> grant {=
        for (int i = 0; i < self->num_entries; i++) {
			if (request[i]->is_present) {
        		// Calculate the time it will take the approaching vehicle to
        		// arrive at its current speed. Note that this is
        		// time from the time the vehicle sends the message
        		// according to the arriving vehicle's clock.
        		double speed_in_m_per_sec = request[i]->value.speed * 1000.0 / 3600.0;
        		double dr = distance(self->intersection_pos, request[i]->value.current_pos);
        		double arrival_in = dr / speed_in_m_per_sec;
      		        		
        		instant_t time_message_sent = get_logical_time();
        		
        		// Convert the time interval to nsec (it is seconds).
        		interval_t arrival_time_ns = time_message_sent + (interval_t) (arrival_in * BILLION);
        		
        		grant_message_t response;
        		if (arrival_time_ns >= self->earliest_free) {
                    // Vehicle can maintain speed.
                    response.target_speed = request[i]->value.speed;
                    response.arrival_time = arrival_time_ns;
                } else {
                    // Vehicle has to slow down and maybe stop.
                    response.arrival_time = self->earliest_free;
                    // Could be smarter than this, but just send the nominal speed in intersection.
                    response.target_speed = self->nominal_speed_in_intersection;
                }
                
                SET(grant[i], response);
                // Update earliest free on the assumption that the vehicle
                // maintains its target speed (on average) within the intersection.
                interval_t time_in_intersection 
                		= (interval_t)(BILLION * self->intersection_width * 3600 
                            / (1000 * response.target_speed)
                        );
                self->earliest_free = response.arrival_time + time_in_intersection;
                
                info_print("*** Grant access to vehicle %d to enter at time %lld. Next available time is %lld",
                    i,
                    response.arrival_time - start_time,
                    self->earliest_free - start_time
                );
            }
        }
    =}
}

main reactor {
    vehicles = new[4] Vehicle();
    
    rsu = new RSU();
    vehicles.request -> rsu.request;
    rsu.grant -> vehicles.grant;
}