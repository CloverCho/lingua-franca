/**
 * This example illustrates the classic problem in concurrent
 * computing called the "sleeping barber problem," often attributed
 * to Edsger Dijkstra (see https://en.wikipedia.org/wiki/Sleeping_barber_problem).
 * Using the logical times of Lingua Franca, many of the potential
 * problems that can arise do not arise.
 * 
 * Upon startup, the barber goes to sleep and is woken up by
 * the arrival of a customer. After serving each customer,
 * the barber checks the waiting room for the next customer.
 * If there is no customer waiting, the barber goes back 
 * to sleep. Customers arrive independently from each other
 * at random times. If the barber is sleeping, the customer
 * gets served right away. Otherwise, if there is room in the
 * waiting room, the customer waits. If the waiting room is
 * full, the customer goes away and returns a random amount
 * of time later. Execution ends when all customers have been
 * served.
 * 
 * This example is inspired by Savina benchmark by the same name,
 * which has a C target implementation here:
 * [https://github.com/lf-lang/lingua-franca/blob/master/benchmark/C/Savina/src/concurrency/SleepingBarber.lf].
 * Like the benchmark, this example illustrates a direct
 * implementation that takes advantage of the semantics of
 * Lingua Franca to simplify the problem.
 * 
 * @author Thee Ho
 * @author Edward A. Lee
 */
 
target C {
    fast: true,
    files: ["/lib/C/util/deque.c", "/lib/C/util/deque.h"]
};
reactor Barber(
    cut_time:time(10 minutes), // (Logical) time spent serving a customer.
    num_chairs:int(5),
    num_customers:int(10)
) {
    preamble {=
        #include "deque.h"

        // Return the customer waiting in the first non-empty
        // chair or -1 if there are no customers waiting.
        // Note that this is not fair. It is not FIFO.
        int get_customer(int chairs[], int num_chairs) {
            for (int i = 0; i < num_chairs; i++){
            	int id = chairs[i];
            	if (id >= 0){
                    chairs[i] = -1;   
                    return id;
                }
            }
            return -1;
        }
        // Put a customer in the first empty chair, if there is one,
        // and return true. If there is no empty chair, return false.
        bool put_customer(int chairs[], int num_chairs, int ID){
	   		for (int i = 0; i < num_chairs; i++){
            	if (chairs[i] < 0){
                    chairs[i] = ID;
                    return true;
                }
            }
            return false;
        }
    =}
    input[num_customers] cut:bool;
    
    output[num_customers] full:bool;
   
    state customerID:int;
    state customers_served:int;
    state chairs:int[]; // store customerID of waiting customers
    state sleep:bool;

    logical action done_cutting;
    
    reaction(startup) {=
        self->chairs = calloc(self->num_chairs, sizeof(int));
        // Mark the chairs empty.
        for (int i=0; i < self->num_chairs; i++) {
            self->chairs[i] = -1;
        }
        self->customers_served = 0;
        self->sleep = true;
    	self->customerID = -1;
    =}
     
    reaction(cut) -> done_cutting, full {=
        char readable_time[LF_TIME_BUFFER_LENGTH];
        lf_readable_time(readable_time, get_elapsed_logical_time());
        for (int i = 0; i < self->num_customers; i++){
            if (cut[i]->is_present){
                info_print("Customer %d arrives at time %s.", i, readable_time);
        		if (self->sleep){
            		self->sleep = false;
            		info_print("*** Barber begins cut.");
            		schedule(done_cutting, self->cut_time);
            		self->customerID = i;
        		} else if (put_customer(self->chairs, self->num_chairs, i)) {
                    info_print("+++ Customer waiting.");
        		} else {
                    info_print("--- All chairs are full. Customer is turned away.");
            		SET(full[i], true);
        		}
        	}
        }
    =}
    
    reaction(done_cutting) -> done_cutting {=
        char readable_time[LF_TIME_BUFFER_LENGTH];
        lf_readable_time(readable_time, get_elapsed_logical_time());
        info_print("Barber is done serving customer %d at time %s.", 
            self->customerID, readable_time
        );
        self->customerID = -1;
        self->customers_served++; 
        
        // Check the waiting room.
        int id = get_customer(self->chairs, self->num_chairs);
        if (id >= 0){
            self->customerID = id;
            schedule(done_cutting, self->cut_time);
            info_print("*** Barber begins cut for customer %d.", id);
        } else {
            self->sleep = true;
            info_print("=== No waiting customers. Barber going to sleep.");
        }
    =}
    
    reaction(shutdown) {=
        info_print("Barber served a total of %d customers.", self->customers_served);
        free(self->chairs);
    =}
}

reactor WaitingRoom(capacity:size_t(5), numCustomers:size_t(2000)) {    
    input receiveCustomer: size_t;
    
    output[numCustomers] full: bool;
    output[numCustomers] wait: bool;
    
    input barberNext: bool;
    output barberEnter: size_t;
    output barberWait: bool;
    
    state queue: deque_t;
    state barberAsleep: bool(true);
    
    reaction (receiveCustomer) -> full, wait, barberEnter {=
         size_t customer_id = receiveCustomer->value;
         
         if (self->queue.size == self->capacity) {
             SET(full[customer_id], true);
         } else {
            if (self->barberAsleep) {
                self->barberAsleep = false;
                SET(barberEnter, customer_id);
            } else {
                deque_push_back(self->queue, customer_id);
                SET(wait[customer_id], true);    
            }
        }
    =}
    
    reaction (barberNext) -> barberEnter, barberWait {=
        if (deque_is_empty(self->queue)) {
            self->barberAsleep = true;
            SET(barberWait, true);
        } else {
            SET(barberEnter, deque_peek_front(self->queue));
            deque_pop_front(self->queue);
        }
    =}
}

reactor Customer(
    bank_index:int(0), 
    retry_time:time(1 hour) // Maximum time between attempts to enter.
){
    preamble {=
        // Return a random time uniformly distributed between
        // 0 and max_time.
        interval_t random_time(interval_t max_time) {
            double scale = (double) rand() / RAND_MAX;
            return (interval_t) (max_time * scale);
        }
    =}
    input full:bool;
    
    logical action enter;
    
    output cut:bool;
    
    reaction(startup) -> enter {=
        // Schedule random customer arrivals
        schedule(enter, random_time(self->retry_time)); 
    =}
    reaction(enter) -> cut {=
        SET(cut,true); 
    =}
    reaction(full) -> enter {=
        schedule(enter, random_time(self->retry_time));
    =}
}

main reactor (
    cut_time:time(10 minutes), 
    num_chairs:int(2), 
    num_customers:int(15),
    retry_time:time(2 hours)
){  
    barber = new Barber(
        cut_time=cut_time, 
        num_chairs=num_chairs,
        num_customers=num_customers
    );
    customers = new[num_customers] Customer(
        retry_time = retry_time
    );

    customers.cut -> barber.cut;
    barber.full -> customers.full;
}
