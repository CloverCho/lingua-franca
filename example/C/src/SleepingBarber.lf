/**
 * This example illustrates the classic problem in concurrent
 * computing called the "sleeping barber problem," often attributed
 * to Edsger Dijkstra (see https://en.wikipedia.org/wiki/Sleeping_barber_problem).
 * Using the logical times of Lingua Franca, many of the potential
 * problems that can arise do not arise.
 * 
 * Upon startup, the barber goes to sleep and is woken up by
 * the arrival of a customer. After serving each customer,
 * the barber checks the waiting room for the next customer.
 * If there is no customer waiting, the barber goes back 
 * to sleep. Customers arrive independently from each other
 * at random times. If the barber is sleeping, the customer
 * gets served right away. Otherwise, if there is room in the
 * waiting room, the customer waits. If the waiting room is
 * full, the customer goes away and returns a random amount
 * of time later. Execution ends when all customers have been
 * served.
 * 
 * This example is inspired by Savina benchmark by the same name,
 * which has a C target implementation here:
 * [https://github.com/lf-lang/lingua-franca/blob/master/benchmark/C/Savina/src/concurrency/SleepingBarber.lf].
 * Unlike the benchmark, this example is a direct implementation
 * of the problem at hand using the features of Lingua Franca.
 * It resembles the Savina benchmark only in overall structure.
 * 
 * @author Christian Menard
 * @author Hannes Klein
 * @author Matthew Chorlian
 * @author Edward A. Lee
 * @author Thee Ho
 */
 
target C {
    fast: true,
    threads: 0,
    files: ["/lib/c/reactor-c/util/deque.h", "/lib/c/reactor-c/util/deque.c"]
};

preamble {=    
    /**
     * Return a random time that is uniformly distributed between
     * 0 and max. This assumes interval_t is a 64-bit integer and
     * that max is less that (2^63)/RAND_MAX so that RAND_MAX * max
     * does not overflow.
     */
    interval_t random_time(interval_t max) {
        interval_t maxp = max * ;
        interval_t result = ((interval_t)rand()) * RAND_MAX) % max;
        info_print("***** FIXME %d", result);
        return result;
    }
=}

/**
 * Upon startup or the triggering of the `next` action,
 * produce the send_customer output, then schedule another occurrence of the
 * action `next` a random amount of time later.
 * The first customer will be produced at logical time 0.
 * The time between new customers is uniformly between 0 and
 * `max_time_between_customers`.
 * 
 * When a `customer_returned` input arrives, schedule a
 * resending of the same customer a random amount of time later,
 * where the random number is again uniformly distributed between
 * 0 and `max_time_between_customers`.
 * 
 * This reactor uses the customer_done input to count customers and request
 * halting the program when all customers have been served.
 */
reactor CustomerFactory(
    num_customers:size_t(20), 
    max_time_between_customers:time(10 minutes)
) {    
    output send_customer: size_t;
    input[num_customers] customer_done: bool;
    input[num_customers] customer_returned: bool;

    logical action next; // Next new customer.
    logical action again:int; // Returning customer. Payload is customer ID.
    
    state done_customers: size_t(0);    // Count of finished customers.
    state attempts: size_t(0);          // Count of customer attempts.
    state next_customer_id: size_t(0);  // ID of next new customer.
    
    reaction(startup, next) -> send_customer, next {=                
        // send the new customer to the waiting room
        self->attempts++;
        SET(send_customer, self->next_customer_id++);
        
        if (self->next_customer_id < self->num_customers) {
            // Schedule again.
            interval_t delay = random_time(max_time_between_customers);
            schedule(next, delay);
        }
    =}
    
    reaction (again) -> send_customer {=
        size_t customer_id = send_customerAgain->value;
        self->attempts++;
        SET(send_customer, customer_id);
    =}
    
    reaction (customer_returned) -> again {=
        for (int i = 0; i < self->num_customers; i++) {
            if (customer_returned[i]->is_present) {
                // The customer returned because the waiting room is full.
                schedule_int(send_customerAgain, 0, i);                
                // Schedule again.
                interval_t delay = random_time(max_time_between_customers);
                schedule_int(next, delay, i);
            }
        }
    =}
    
    reaction (customer_done) {=
        // Only one customer can be done at any logical tag, so we
        // only need to count invocations of this reaction.
        self->done_customers++;
        if (self->done_customers >= self->num_customers) {
            request_stop();
        }
    =}
    
    reaction (shutdown) {=
        info_print("Finished: %d customers got haircuts in %d attempts.", 
                self->done_customers, self->attempts
        };
    =}
}

/**
 * When a customer_enters input arrives, if the barber is asleep,
 * then wake the barber up and send the customer ID to the 
 * `barber_leaves_with_customer` output. If the barber is
 * awake and there is room in the queue,
 * then put the customer ID on the queue and produce a wait output
 * on the channel corresponding to the customer ID. If the queue
 * is full, then produce a full output on the channel corresponding
 * to the customer ID.
 */
reactor WaitingRoom(capacity:size_t(1000), num_customers:size_t(2000)) {
    preamble {=
        #include "deque.c"
    =}
    input customer_enters: size_t;
    
    output[num_customers] full: bool;
    output[num_customers] wait: bool;
    
    input barber_arrives: bool;
    output barber_leaves_with_customer: size_t;
    
    state queue: deque_t;
    state barber_asleep: bool(true);
    
    reaction (customer_enters) -> full, wait, barber_leaves_with_customer {=
         size_t customer_id = customer_enters->value;
         
         if (deque_size(&self->queue) == self->capacity) {
             SET(full[customer_id], true);
         } else {
            if (self->barber_asleep) {
                self->barber_asleep = false;
                SET(barber_leaves_with_customer, customer_id);
            } else {
                // Note that the customer_id is being cast to a pointer
                // because the payload of a queue element is a pointer.
                // As long as we never dereference that pointer, it is OK
                // to recast it to size_t, assuming void* has at least as
                // many bits as size_t, which it must.
                deque_push_back(&self->queue, (void*)customer_id);
                SET(wait[customer_id], true);    
            }
        }
    =}
    
    reaction (barber_arrives) -> barber_leaves_with_customer {=
        if (deque_is_empty(&self->queue)) {
            self->barber_asleep = true;
        } else {
            SET(barber_leaves_with_customer, (size_t)deque_pop_front(&self->queue));
        }
    =}
}

/**
 * This reactor simply relays a roomFull input to its returned
 * output and its doneCutting input to its done output.
 * It ignores the other two inputs.
 */
reactor Customer(bank_index:size_t(0)) {
    input roomFull: bool;
    input wait: bool;
    input startCutting: bool;
    input doneCutting: bool; 

    output returned: bool;
    output done: bool;
    
    reaction (roomFull) -> returned {=
        SET(returned, true);
    =}
    
    reaction (wait) {=
    =}
    
    reaction (startCutting) {= 
    =}
    
    reaction (doneCutting) -> done {=
        SET(done, true);
    =}
}

/**
 * Upon receiving an `enter` input (whose value is a customer ID),
 * send a `startCutting` output to corresponding customer, then
 * busy wait for some amount of time, and then schedule the physical
 * action `done`. Upon triggering the `done` action, send a
 * `doneCutting` output to the corresponding customer and a
 * `next` output to ask for the next customer.
 * 
 * Note that because of the physical action, the logical time
 * spent cutting hair is determined by the amount of time busy
 * waiting. This is not at all a Lingua Franca style of design
 * and introduces an intrinsic handicap compared to an actor
 * implementation. In particular, downstream reactors cannot
 * react to startCutting until the busy wait is complete, which
 * would not be true in an actor design.
 */
reactor Barber(
    averageHaircutRate:size_t(1000), // NOTE: The Savina benchmark calls this
                                     // an average, but it is not an averate.
                                     // It specifies a maximum amount of busy-wait
                                     // work to be done minus 10, oddly,
                                     // in arbitrary units.
    num_customers:size_t(2000)
) {
    input enter: size_t;
        
    output[num_customers] startCutting: bool;
    output[num_customers] doneCutting: bool;
    output next: bool;
    
    physical action done: size_t;
    
    state random: PseudoRandom;
    
    reaction(startup) {=
        // Use the same seed as in the C++ and Akka benchmarks.
        self->random.mValue = 74755;
    =}
          
    reaction (done) -> doneCutting, next {=
        size_t customer_id = done->value;
        SET(doneCutting[customer_id], true);
        SET(next, true);
    =}
    
    reaction (enter) -> startCutting, done {=
        size_t customer_id = enter->value;
        SET(startCutting[customer_id], true);
        
        // Calculate a random delay.
        // The second argument is an upper bound (exclusive).
        int delay = nextIntEMax(&self->random, self->averageHaircutRate) + 10;
        
        // do the actual cutting and apply a physical delay
        busyWait(delay);
        
        // Notify the customer 
        schedule(done, customer_id);
    =}
}


/* [[[cog
    cog.outl(f'main reactor (
        waitingRoomSize:size_t({waitingRoomSize}),
        averageProductionRate:size_t({averageProductionRate}),
        averageHaircutRate:size_t({averageHaircutRate}),
        numHaircuts:size_t({numHaircuts})
    )')
]]] */
main reactor (
    waitingRoomSize:size_t(10),
    max_time_between_customers:time(10 minutes),
    averageHaircutRate:size_t(10),
    numHaircuts:size_t(20)
)
/// [[[end]]]

{
    
    factory = new CustomerFactory(
        num_customers=numHaircuts, 
        max_time_between_customers=max_time_between_customers
    );
    room = new WaitingRoom(capacity=waitingRoomSize, num_customers=numHaircuts);
    barber = new Barber(averageHaircutRate=averageHaircutRate, num_customers=numHaircuts)
    customers = new[numHaircuts] Customer();
        
    factory.send_customer -> room.customer_enters;
    room.full -> customers.roomFull;
    room.wait -> customers.wait;
    room.barber_leaves_with_customer -> barber.enter;
    barber.next -> room.barber_arrives;
    barber.startCutting -> customers.startCutting;
    barber.doneCutting -> customers.doneCutting;
    customers.done -> factory.customer_done;
    
    customers.returned -> factory.customer_returned;
}