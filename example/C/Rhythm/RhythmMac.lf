/**
 * Simple demonstration of asynchronous input and timed output.
 * This version is not portable. It runs on MacOS.
 * It serves as a demonstration for how to write Lingua Franca
 * programs that use Apple's AudioToolbox.
 * 
 * This program opens a simple, terminal-based user interface for
 * specifying a rhythmic audio output. The rhythm is displayed in
 * the terminal as it is generated and produced as audio using
 * sample audio files.
 * 
 * This program also uses ncurses, which needs to be installed on your machine
 * for this to work. It also uses the library utility sensor_simulator,
 * provided with Lingua Franca, which uses keyboard input to simulate
 * asynchronous sensors and beeps to simulate timed output.
 * See sensor_simulator.h for documentation.
 * 
 * The merengue rhythm comes from here: 
 * https://www.8notes.com/school/lessons/percussion/merengue.asp
 * 
 * The sound files come from here:
 * https://freewavesamples.com
 * 
 * Sound files are assumed to be wav files with sample rate 44,100,
 * 16-bit samples, linear PCM encoded.
 * Use afconvert on Mac to convert to the assumed input format.
 * 
 * @author Edward A. Lee
 */
target C {
    flags: "-lncurses -framework AudioToolbox -framework CoreFoundation -lm",
    files: ["/lib/C/util/sensor_simulator.c", "/lib/C/util/sensor_simulator.h",
            "/lib/C/util/wave_file_reader.c", "/lib/C/util/wave_file_reader.h",
            "/lib/C/util/audio_loop_mac.c", "/lib/C/util/audio_loop_mac.h",
            "Bass-Drum-1.wav", "Hi-Bongo.wav", "Claves.wav", "High-Conga-1.wav",
            "Cowbell-1.wav", "Cuica-1.wav", "Guiro.wav",
            "Ensoniq-ESQ-1-Snare.wav", "Floor-Tom-1.wav"] 
}; 
preamble {= 
    #include <ncurses.h>
    #include "wave_file_reader.c"
    #include "sensor_simulator.c"
    #if __APPLE__
    #include "audio_loop_mac.c"
    #elif __linux__
    #include "audio_loop_linux.c"
    #else
    #error "Platform not supported."
    #endif
    
    /////////////////////////////
    // Configuration of the audio.
    
    // Beat pattern with 1 note followed by 7 silences, repeated.
    #define DOWNBEAT 0x0101
    
    // Merenque in binary covers two bars (in temporal order):  1001 1010 1010 1111
    // Reverse the order to get the bit sequence: 1111 0101 0101 1001
    #define MERENGUE 0xf559
    // Merengue emphasis in binary (in temporal order): 1001 0010 0010 1000
    // Reverse the order to get the bit sequence: 0001 0100 0100 1001
    #define MERENGUE_EMPHASIS 0x1449
    
    // Bossa nova: In temporal order: 1001 0010 0010 0110
    // Note: last '1' is questionable. Held over from previous '1'.
    // Reverse order: 0110 0100 0100 1001
    #define BOSSA_NOVA 0x6449
    #define BOSSA_NOVA_EMPHASIS 0x2449
    
    // Samba: Temporal order: 0000 1010 1101 1010
    // Reversed: 0101 1011 0101 0000
    // Alt: 0101 1011 1011 1011
    // Rev: 1101 1101 1101 1010
    #define SAMBA 0xddda
    #define SAMBA_EMPHASIS 0x99ca
    
    // wav files giving the waveforms.
    // These have to also be included in the files target directive.
    #define NUM_WAVEFORMS 9  // Number of waveforms.
    char* waveform_files[] = { "Bass-Drum-1.wav", "Hi-Bongo.wav",
            "Claves.wav", "High-Conga-1.wav",
            "Cowbell-1.wav", "Cuica-1.wav", "Guiro.wav",
            "Ensoniq-ESQ-1-Snare.wav", "Floor-Tom-1.wav"};
            
    // The waveforms themselves.
    lf_waveform_t* waveforms[NUM_WAVEFORMS + 1];
    
    lf_waveform_t empty_waveform = { 0 };
    
    //////////////////////////////////////
    // Configuration of the user interface.

    char* message[] = {
        "Basic control:",
        "  x: quit",
        "  +: speed up",
        "  -: slow down",
        "Instrument:",
        "  0: none",
        "  1: bass drum",
        "  2: bongo",
        "  3: claves",
        "  4: conga",
        "  5: cowbell",
        "  6: cuica",
        "  7: guiro",
        "  8: snare",
        "  9: tom",
        "Rhythm:",
        "  d: down beat",
        "  m: merengue",
        "  b: bossa nova",
        "  s: samba"
    };
    int message_length = 20;
        
=}

/**
 * Reactor that outputs notes (which carry an emphasis))
 * according to a specified rhythm. The minimum time
 * between notes is given by the 'tick_duration' state
 * variable. This can be adjusted up or down.
 */
reactor RhythmSource(sixteenth:time(200 msec)) {    
    output note:float;     // To play a note with the given emphasis.
    output instrument:int; // Instrument selection.
    
    state tick_duration:time(200 msec);
    logical action tick;
    
    // Count of sixteenth notes.
    state count:int(0);
    
    // Action to be invoked when a key is pressed.
    physical action key:char;
    
    // Indicator of when to make a sound.
    state rhythm:int({=DOWNBEAT=});
    
    // Indicator of whether to emphasize the sound.
    state emphasis:int({=DOWNBEAT=});

   // Currently active rhythm. This becomes
    // active from rhythm on the downbeat.
    state active_rhythm:int({=DOWNBEAT=});
    
    // Currently active emphasis. This becomes
    // active from rhythm on the downbeat.
    state active_emphasis:int({=DOWNBEAT=});
        
    // Position of the cursor in the terminal window.
    state cursor:int(0);
    
    reaction(startup) -> key, note, tick {=
        // FIXME: See whether a note can be sent at the start time.
        SET(note, 1.0);
        // Start the sensor simulator, which starts ncurses.
        if (start_sensor_simulator(message, message_length, 16)) {
            error_print_and_exit("ERROR: Failed to start sensor simulator.");
        }
        
        // Register action to trigger on key press.
        register_sensor_key('\0', key);
        
        schedule(tick, self->tick_duration);
    =}
    
    reaction(key) -> instrument {=
        int numeric;
        switch (key->value) {
            case '0':
                SET(instrument, 0);
                break;
            case 'd':
                self->rhythm = DOWNBEAT;
                self->emphasis = DOWNBEAT;
                break;
            case 'm':
                self->rhythm = MERENGUE;
                self->emphasis = MERENGUE_EMPHASIS;
                break;
            case 'b':
                self->rhythm = BOSSA_NOVA;
                self->emphasis = BOSSA_NOVA_EMPHASIS;
                break;
            case 's':
                self->rhythm = SAMBA;
                self->emphasis = SAMBA_EMPHASIS;
                break;
            case 'x':
                request_stop();
                break;
            case '+':
                self->tick_duration -= MSEC(20);
                if (self->tick_duration < MSEC(20)) {
                    self->tick_duration = MSEC(20);
                }
                break;
            case '-':
                self->tick_duration += MSEC(20);
                break;
            default:
                numeric = (int)key->value;
                if (numeric >= 49 && numeric <= 57) {
                    // A digit between 1 and 9.
                    SET(instrument, numeric - 48);
                }
        }
    =}

    reaction(tick) -> note, tick {=
        int beeped = 0;
        int position = 0;
        position = 1 << self->count;
        if (position & self->active_rhythm) {
            double emphasis = 0.25;
            if (position & self->active_emphasis) {
                emphasis = 1.0;
            }
            SET(note, emphasis);
            beeped++;
        }
        if (beeped > 0) {
            if (position & self->active_emphasis) {
                show_tick("!");
            } else {
                show_tick("*");
            }
        } else {
            show_tick(".");
        }
        self->count++;
        if (self->count == 16) {
            self->active_rhythm = self->rhythm;
            self->active_emphasis = self->emphasis;
            self->count = 0;
        } 

        schedule(tick, self->tick_duration);
    =}
}
 
/**
 * Produce a note when a `note` input is received.
 * 
 * This reactor provides a small collection of built-in audio
 * waveforms which are read at startup time from .wav files.
 * The waveform input specifies which of the waveforms to play
 * upon the next `note` input received.
 * It is a number between 0 and NUM_WAVEFORMS. If a number outside
 * this range is received, then simple tick sounds will be produced.
 * Number 0 is specially interpreted for silence.
 *
 * The `note` input is a number, normally between 0.0 and 1.0,
 * that specifies the loudness of the note. If the loudness exceeds
 * 1.0, or if too many notes are played at once, clipping may occur.
 * 
 */
reactor PlayWaveform {
    input note:float;
    input waveform:int;
    
    /**
     * Index of the current waveform.
     * -1 means no waveform (just make ticks)).
     */
    state waveform_id:int(0);
        
    reaction(startup) {=
        
        // First waveform is empty.
        waveforms[0] = &empty_waveform;
        
        // Open and read waveform files.
        for (int i = 0; i < NUM_WAVEFORMS; i++) {
            waveforms[i + 1] = read_wave_file(waveform_files[i]);
        }
        
        // Start an audio loop that will become ready to receive
        // amplitude samples of audio data.
        lf_start_audio_loop(get_logical_time());
    =}
    
    reaction(waveform) {=
        self->waveform_id = waveform->value;
    =}
    
    reaction(note) {=
        if (self->waveform_id < 0 || self->waveform_id > NUM_WAVEFORMS) {
            lf_play_audio_waveform(NULL, note->value, get_logical_time());
        } else {
            lf_play_audio_waveform(waveforms[self->waveform_id], note->value, get_logical_time());
        }
    =} deadline (10 msec) {=  // NOTE: deadline has to match BUFFER_DURATION_NS.
        warning_print("Missed deadline!");
    =}
    
    reaction(shutdown) {=
        lf_stop_audio_loop();
    =}
}

main reactor RhythmMac {
    source = new RhythmSource();
    play = new PlayWaveform();
    source.note -> play.note;
    source.instrument -> play.waveform;
}
