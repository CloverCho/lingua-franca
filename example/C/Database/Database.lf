/**
 * Test program illustrating the architecture of a replicated distributed
 * database. It models a web server in each of two platforms that accepts
 * queries and updates to the database and passes them on the database
 * reactor.
 * 
 * @author Edward A. Lee
 */
target C {
    timeout: 1 sec
}

/**
 * Mockup for a web server. This reactor simply produces a
 * query output periodically, with period query_period, and
 * an update output periodically, with period update_period.
 * In a real server, these outputs would not be periodic, but
 * rather would be triggered by external events, such as incoming
 * HTTP requests.
 * 
 * The value of the update output is the timestamp at which the
 * update is produced, emulating the timestamping of incoming
 * HTTP requests.
 * 
 * This reactor expects a reply to each query. It prints those
 * replies. It produces an error in its shutdown reaction if
 * the number of replies does not match the number of queries.
 * @param query_period The period of query outputs.
 * @param update_period The period of update outputs.
 * @input reply Accepts the reply.
 * @output query Issue a query, expecting a reply.
 * @output update Issue an update.
 */
reactor Server(query_period:time(150 msec), update_period:time(100 msec)) {
    timer query_trigger(0, query_period);
    timer update_trigger(0, update_period);
    input reply:time;
    output query:bool;
    output update:time;
    state queries_outstanding:int(0);
    
    reaction(query_trigger) -> query {=
        SET(query, true);
        self->queries_outstanding++;
    =}
    reaction(update_trigger) -> update {=
        SET(update, get_elapsed_logical_time());
    =}
    reaction(reply) {=
        info_print("At logical time %lld, received reply %lld.",
            get_elapsed_logical_time(), reply->value
        );
        self->queries_outstanding++;
    =}
}

/**
 * A mockup for a database. This simple database contains only one
 * record, and the value of that record is the timestamp of the latest
 * update to the record. It accepts a local_update input, which has type time
 * and contains the timestamp value of the update. Note that the timestamp
 * need not match the logical time at which this reactor receives the
 * input. The query input is used to retrieve the record. The stored
 * time will be sent to the reply output in response to a query input.
 * 
 * This reactor also has a remote_update input that also updates the
 * local copy of the record. If local_update and remote_update inputs
 * are present simultaneously, then the remote update always prevails
 * and the local update is discarded.
 * 
 * @param update_deadline A deadline imposed on the reaction to update inputs.
 * @input update A time-valued update to the record.
 * @output publish This is just the update passed through.
 * @input query A trigger to read the current value of the record.
 * @output reply The time value of the record.
 */
reactor Database(update_deadline:time(100 msec)) {
    input local_update:time;
    input remote_update:time;
    input query:bool;
    output publish:time;
    output reply:time;
    state record:time(0); // FIXME: Should be NEVER
    
    reaction(local_update) -> publish {=
        self->record = local_update->value;
        SET(publish, local_update->value);
    =}
    
    reaction(remote_update) -> publish {=
        self->record = remote_update->value;
        SET(publish, remote_update->value);
    =} tardy {=
        error_print("Update is tardy. Rejecting update.");
    =}
    reaction(query) -> reply {=
        SET(reply, self->record);
    =}
}

/**
 * A mockup of a platform (e.g. a pod, a virtual machine, a physical
 * machine, etc.) that hosts a replicated database and a web server.
 * When the platform receives an update input, it publishes that
 * update on its publish output.
 * @input update An update notification from another replica.
 * @output publish A copy of the update just received.
 */
reactor Platform {
    input update:time;
    output publish:time;
    server = new Server();
    database = new Database();
    server.query -> database.query;
    server.update -> database.local_update;
    database.reply -> server.reply;
    database.publish -> publish;
    update -> database.remote_update;
}

main reactor ReplicatedDatabase(STP:time(30 msec)) {
    a = new Platform();
    b = new Platform();
    a.publish -> b.update;
}
