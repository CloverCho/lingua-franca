target Python {
    files: [gui.py, keys.png, soundfont.sf2],
    keepalive: true
};

preamble {=
    import sensor_simulator
    import threading
    import multiprocessing.connection
    from multiprocessing.connection import Pipe
    
    piano_keys = {
        "z": ("C", 0),
        "s": ("C#", 0),
        "x": ("D", 0),
        "d": ("D#", 0),
        "c": ("E", 0),
        "v": ("F", 0),
        "g": ("F#", 0),
        "b": ("G", 0),
        "h": ("G#", 0),
        "n": ("A", 0),
        "j": ("A#", 0),
        "m": ("B", 0),
        "w": ("C", 1),
        "3": ("C#", 1),
        "e": ("D", 1),
        "4": ("D#", 1),
        "r": ("E", 1),
        "t": ("F", 1),
        "6": ("F#", 1),
        "y": ("G", 1),
        "7": ("G#", 1),
        "u": ("A", 1),
        "8": ("A#", 1),
        "i": ("B", 1)
    }
=}

reactor GetUserInput {
    preamble {=
        import threading
        def listen_for_input(self, user_response):
            while 1:
                try:
                    c = self.user_input.recv()
                except EOFError:
                    request_stop()
                    return
                # Each time a key press is received, schedule a user_response event 
                user_response.schedule(0, c)
    =}
    physical action user_response;
    input user_input_pipe_init;
    output user_input;
    state user_input({=None=}) # multiprocessing.connection.PipeConnection
    
    reaction(user_input_pipe_init) -> user_response {=
        self.user_input = user_input_pipe_init.value
        t = self.threading.Thread(target=self.listen_for_input, args=(user_response, ))
        t.start()
    =}
    
    reaction(user_response) -> user_input {=
        user_input.set(user_response.value)
    =}
}

reactor UpdateGraphics {
    input note;
    input update_graphics_pipe_init;
    state update_graphics({=None=}); # multiprocessing.connection.PipeConnection
    state pressed_keys({=set()=})
    
    reaction(update_graphics_pipe_init) {=
        self.update_graphics = update_graphics_pipe_init.value
    =}
    
    reaction(note) {=
        key_down, note_t = note.value
        if key_down and note_t not in self.pressed_keys:
            self.pressed_keys.add(note_t)
            self.update_graphics.send(self.pressed_keys)
        if not key_down and note_t in self.pressed_keys:
            self.pressed_keys.remove(note_t)
            self.update_graphics.send(self.pressed_keys)
    =}
}

reactor TranslateKeyToNote {
    input user_input;
    output note;
    
    reaction(user_input) -> note {=
        key_down, c = user_input.value
        if c in piano_keys:
            note.set((key_down, piano_keys[c]))
    =}
}

reactor StartGui {
    preamble {=
        import gui
    =}
    
    output user_input_pipe;
    output update_graphics_pipe;
    
    reaction(startup) -> user_input_pipe, update_graphics_pipe {=
          user_input_pout, update_graphics_pin = self.gui.start_gui(piano_keys)
          user_input_pipe.set(user_input_pout)
          update_graphics_pipe.set(update_graphics_pin)
    =}
}

main reactor {
    gui = new StartGui()
    translate = new TranslateKeyToNote()
    update_graphics = new UpdateGraphics()
    get_user_input = new GetUserInput() 
    gui.user_input_pipe -> get_user_input.user_input_pipe_init
    gui.update_graphics_pipe -> update_graphics.update_graphics_pipe_init
    get_user_input.user_input -> translate.user_input
    translate.note -> update_graphics.note
}
