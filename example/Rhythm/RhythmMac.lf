/**
 * Simple demonstration of asynchronous input and timed output.
 * This version is not portable. It runs on MacOS.
 * 
 * This program opens a simple, terminal-based user interface for
 * specifying a rhythmic audio output. The rhythm is displayed in
 * the terminal as it is generated and produced as audio using
 * the terminal's "beep" functionality. Note that not all terminal
 * implementation provide audio output, so you may not hear any
 * audible beeps. Moreover, many terminal implementations implement
 * the beep in such a way that it occupies a fixed amount of time
 * that may be longer than the 'sixteenth' parameter given here,
 * in which case the audible rhythm will not be accurate.
 * Regrettably, this "beep" functionality is the closest we have
 * been able to find to any sort of even remotely portable audio
 * output.
 * 
 * This program uses ncurses, which needs to be installed on your machine
 * for this to work. It also uses the library utility sensor_simulator,
 * provided with Lingua Franca, which uses keyboard input to simulate
 * asynchronous sensors and beeps to simulate timed output.
 * See lingua-franca/lib/C/sensor_simulator.h.
 * 
 * You can construct simple rhythms with this program.
 * The sixteenth parameter determines the duration of a sixteenth note,
 * the finest resolution this example supports.
 * You can turn on and off several beeps to occur within the bar
 * with keyboard input.
 * 
 * The merengue rhythm comes from here: https://www.8notes.com/school/lessons/percussion/merengue.asp
 */
target C {
    flags: "-lncurses -framework AudioToolbox -framework CoreFoundation -lm",
    files: ["/lib/C/sensor_simulator.c", "/lib/C/sensor_simulator.h"] 
};
preamble {=
    #include <ncurses.h>
    #include <unistd.h>
    #include "AudioToolbox/AudioToolbox.h"
    #include "sensor_simulator.c"
    
    #define CLEAR 0x0000
    #define DOWNBEAT 0x0101
    // Merenque in binary covers two bars (in temporal order):  1001 1010 1010 1111
    // Reverse the order to get the bit sequence: 1111 0101 0101 1001
    #define MERENGUE 0xf559
    // Merengue emphasis in binary (in temporal order): 1001 0010 0010 1000
    // Reverse the order to get the bit sequence: 0001 0100 0100 1001
    #define MERENGUE_EMPHASIS 0x1449
        
    // Constants for playback. These are all coupled.
    #define SAMPLE_RATE 44100
    #define BUFFER_SIZE  4410  // 1/10 second
    #define BUFFER_DURATION_NS 100000000LL;
    #define MAX_AMPLITUDE 32765
    
    char* message[] = {
        "Type the following keys:",
        "  x: quit",
        "  d: down beat",
        "  m: merengue",
        "  c: clear"
    };
    int message_length = 5;
    
    unsigned int sample_count = 0;
    
    pthread_mutex_t audio_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t audio_cond = PTHREAD_COND_INITIALIZER;
    
    // Pointer to the buffer into which to currently write.
    // This is null before the buffer is ready.
    short* next_buffer = NULL;
    instant_t next_buffer_start_time = NEVER;
    
    /**
     * Function that is called by the audio loop to fill the audio buffer
     * with the next batch of audio data.  When this callback occurs,
     * this grabs the mutex lock, copies the buffer that the main program 
     * has been filling into the destination buffer, clears the next
     * buffer, and updates the start time of the next buffer.
     */
    void callback (void *ignored, AudioQueueRef queue, AudioQueueBufferRef buf_ref) {
        // Get a C pointer from the reference passed in.
        AudioQueueBuffer *buf = buf_ref;
        
        // Array of samples in the buffer.
        short *samples = buf->mAudioData;
        
        pthread_mutex_lock(&audio_mutex);
        // Make this the new buffer to write into.
        next_buffer = buf->mAudioData;
        // Clear out the next buffer.
        memset(next_buffer, 0, BUFFER_SIZE * sizeof(short));
        next_buffer_start_time += BUFFER_DURATION_NS;
        
        // FIXME: Fill the buffer with any trailing sample data that
        // didn't fit in the previous buffer.

        // Reinsert this same audio buffer at the end of the queue.
        AudioQueueEnqueueBuffer (queue, buf_ref, 0, NULL);
        
        // In case the other thread is waiting for this event, notify
        // (the other thread should not be waiting).
        pthread_cond_signal(&audio_cond);
        pthread_mutex_unlock(&audio_mutex);
    }
    
    /**
     * Run the audio loop indefinitely.
     */
    void* run_audio_loop(void* ignored) {
        // Create an audio format description.
        AudioStreamBasicDescription fmt = { 0 };
        fmt.mSampleRate = 44100;
        fmt.mFormatID = kAudioFormatLinearPCM;
        fmt.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked;
        fmt.mFramesPerPacket = 1;
        fmt.mChannelsPerFrame = 1; // 2 for stereo
        fmt.mBytesPerPacket = fmt.mBytesPerFrame = 2; // x2 for stereo
        fmt.mBitsPerChannel = 16;

        AudioQueueRef queue;

        // Double buffering. 
        AudioQueueBufferRef buf_ref1, buf_ref2;
        
        int buffer_size_bytes = BUFFER_SIZE * 2;
        
        // Create an audio queue output with the specified format.
        // Third argument is an optional pointer to pass to the callback function.
        if (AudioQueueNewOutput(&fmt, callback, NULL, CFRunLoopGetCurrent(), kCFRunLoopCommonModes, 0, &queue) != 0
            || AudioQueueAllocateBuffer (queue, buffer_size_bytes, &buf_ref1) != 0
            || AudioQueueAllocateBuffer (queue, buffer_size_bytes, &buf_ref2) != 0
        ) {
            fprintf(stderr, "WARNING: Failed to create audio output. No audio will be produced");
            return NULL;
        }
        // Convert reference to a C pointer.
        AudioQueueBuffer* buf1 = buf_ref1;
        AudioQueueBuffer* buf2 = buf_ref2;
        
        // Set buffer size
        buf1->mAudioDataByteSize = buffer_size_bytes;
        buf2->mAudioDataByteSize = buffer_size_bytes;
        
        // Put both buffers in the queue.
        callback (NULL, queue, buf_ref1);
        callback (NULL, queue, buf_ref2);
        // At this point, next_buffer_start_time == start time of the model.
        
        // Set the second buffer to be the one being currently written into.
        next_buffer = buf2->mAudioData;
        
        // Set the volume. (Ignoring errors)
        AudioQueueSetParameter (queue, kAudioQueueParam_Volume, 1.0);
        
        // Start audio at start time plus one buffer duration.
        struct AudioTimeStamp time_stamp = { 0 };
        time_stamp.mHostTime = next_buffer_start_time + BUFFER_DURATION_NS;
        
        // Start as soon as possible.
        if (AudioQueueStart (queue, &time_stamp) != 0) {
            fprintf(stderr, "WARNING: Failed to start audio output. No audio will be produced");
        }
        CFRunLoopRun();
        return NULL;
    }
=}

reactor RhythmSource(sixteenth:time(200 msec)) {
    timer t(0, sixteenth);
    
    output note:double; // Emphasis only, for now.
    
    // Count of sixteenth notes.
    state count:int(0);
    
    // Action to be invoked when a key is pressed.
    physical action key:char;
    
    // Indicator of when to make a sound.
    state rhythm:int({=DOWNBEAT=});
    
    // Indicator of whether to emphasize the sound.
    state emphasis:int({=DOWNBEAT=});

   // Currently active rhythm. This becomes
    // active from rhythm on the downbeat.
    state active_rhythm:int({=DOWNBEAT=});
    
    // Currently active emphasis. This becomes
    // active from rhythm on the downbeat.
    state active_emphasis:int({=DOWNBEAT=});
        
    // Position of the cursor in the terminal window.
    state cursor:int(0);
    
    reaction(startup) -> key, note {=
        // FIXME: See whether a note can be sent at the start time.
        SET(note, 1.0);
        // Start the sensor simulator, which starts ncurses.
        if (start_sensor_simulator()) {
            fprintf(stderr, "ERROR: Failed to start sensor simulator.\n");
            exit(1);
        }

        show_message(message, message_length);
        
        // Register action to trigger on key press.
        register_sensor_key('\0', key);
    =}
    
    reaction(key) {=
        switch (key->value) {
            case 'c':
                self->rhythm =  CLEAR;
                break;
            case 'd':
                self->rhythm = DOWNBEAT;
                self->emphasis = DOWNBEAT;
                break;
            case 'm':
                self->rhythm =  MERENGUE;
                self->emphasis =  MERENGUE_EMPHASIS;
                break;
            case 'x':
                request_stop();
                break;
        }
    =}

    reaction(t) -> note {=
        int beeped = 0;
        int position = 0;
        position = 1 << self->count;
        if (position & self->active_rhythm) {
            double emphasis = 0.25;
            if (position & self->active_emphasis) {
                emphasis = 1.0;
            }
            SET(note, emphasis);
            beeped++;
        }
        pthread_mutex_lock(&sensor_mutex);
        if (beeped > 0) {
            if (position & self->active_emphasis) {
                printw("!");
            } else {
                printw("*");
            }
        } else {
            printw(".");
        }
        self->count++;
        if (self->count == 16) {
            self->active_rhythm = self->rhythm;
            self->active_emphasis = self->emphasis;
            self->count = 0;
            int term_height, term_width;
            getmaxyx(stdscr, term_height, term_width);   // Get the size of the terminal window.
            self->cursor++;
            if (self->cursor >= term_height) {
                self->cursor = 0;
            }
            move(self->cursor, 0);
        }
        refresh();
        pthread_mutex_unlock(&sensor_mutex);
    =}
}

/**
 * Produce an audio tick when an input is received.
 */
reactor Tick {
    input emphasis:double;
    
    state loop_thread_id:pthread_t({=NULL=});
    
    reaction(startup) {=
        // Set the start time of the current buffer to the current time
        // minus twice the buffer duration. The two calls to callback()
        // during setup will increment this to equal to the start time.
        // Then create a thread to
        // start the audio loop. That thread will place
        // two empty audio buffers in the queue and will schedule the
        // audio to start at the current logical time plus the buffer
        // duration. The current buffer being filled (the second buffer)
        // will have logical start time 0, but will play later by less
        // than the buffer duration.
        next_buffer_start_time = get_logical_time() - 2 * BUFFER_DURATION_NS;
        
        // Start the audio loop thread.
        pthread_create(&self->loop_thread_id, NULL, &run_audio_loop, NULL);
    =}
    reaction(emphasis) {=
        pthread_mutex_lock(&audio_mutex);
        
        // If the buffer into which to write has not yet been set up, wait.
        while (next_buffer == NULL) {
            pthread_cond_wait(&audio_cond, &audio_mutex);
        }
        instant_t time_offset = get_logical_time() - next_buffer_start_time;
        // If this is late, then tick right away.
        if (time_offset < 0) {
            printf("WARNING: note is early by %lld.\n", time_offset);
            time_offset = 0;
        }
        // Calculate the index of the tick.
        size_t index_offset = (time_offset * SAMPLE_RATE) / BILLION;
        
        // If the offset is beyond the end of the audio buffer, then the program
        // has gotten ahead of the audio. Wait for audio to catch up.
        // This happens when a timestamp is at or close to the start time
        // for the buffer because the audio system has not yet invoked the
        // callback to swap buffers.  Here, we wait for the callback to
        // occur.
        while (index_offset >= BUFFER_SIZE) {
            pthread_cond_wait(&audio_cond, &audio_mutex);
            time_offset = get_logical_time() - next_buffer_start_time;
            index_offset = (time_offset * SAMPLE_RATE) / BILLION;
        }
        next_buffer[index_offset] = MAX_AMPLITUDE * emphasis->value;
        
        pthread_mutex_unlock(&audio_mutex);
    =} // FIXME: Should have a deadline here. But need to couple it to BUFFER_DURATION_NS, which isn't allowed.
}

main reactor Rhythm {
    source = new RhythmSource();
    tick = new Tick();
    source.note -> tick.emphasis;
}
