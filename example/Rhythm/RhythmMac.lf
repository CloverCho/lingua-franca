/**
 * Simple demonstration of asynchronous input and timed output.
 * This version is not portable. It runs on MacOS.
 * It serves as a demonstration for how to write Lingua Franca
 * programs that use Apple's AudioToolbox.
 * 
 * This program opens a simple, terminal-based user interface for
 * specifying a rhythmic audio output. The rhythm is displayed in
 * the terminal as it is generated and produced as audio using
 * sample audio files.
 * 
 * This program also uses ncurses, which needs to be installed on your machine
 * for this to work. It also uses the library utility sensor_simulator,
 * provided with Lingua Franca, which uses keyboard input to simulate
 * asynchronous sensors and beeps to simulate timed output.
 * See sensor_simulator.h for documentation.
 * 
 * The merengue rhythm comes from here: 
 * https://www.8notes.com/school/lessons/percussion/merengue.asp
 * 
 * The sound files come from here:
 * https://freewavesamples.com
 * 
 * Sound files are assumed to be wav files with sample rate 44,100,
 * 16-bit samples, linear PCM encoded.
 * Use afconvert on Mac to convert to the assumed input format.
 * 
 * @author Edward A. Lee
 */
target C {
    flags: "-lncurses -framework AudioToolbox -framework CoreFoundation -lm",
    files: ["/lib/C/util/sensor_simulator.c", "/lib/C/util/sensor_simulator.h",
            "/lib/C/util/wave_file_reader.c", "/lib/C/util/wave_file_reader.h",
            "/lib/C/util/audio_loop_mac.c", "/lib/C/util/audio_loop_mac.h",
            "Bass-Drum-1.wav", "Hi-Bongo.wav", "Claves.wav", "High-Conga-1.wav",
            "Cowbell-1.wav", "Cuica-1.wav", "Guiro.wav",
            "Ensoniq-ESQ-1-Snare.wav", "Floor-Tom-1.wav"] 
}; 
preamble {= 
    #include <ncurses.h>
    #include "wave_file_reader.c"
    #include "sensor_simulator.c"
    #include "audio_loop_mac.c"
    
    /////////////////////////////
    // Configuration of the audio.
    
    // Beat pattern with 1 note followed by 7 silences, repeated.
    #define DOWNBEAT 0x0101
    
    // Merenque in binary covers two bars (in temporal order):  1001 1010 1010 1111
    // Reverse the order to get the bit sequence: 1111 0101 0101 1001
    #define MERENGUE 0xf559
    // Merengue emphasis in binary (in temporal order): 1001 0010 0010 1000
    // Reverse the order to get the bit sequence: 0001 0100 0100 1001
    #define MERENGUE_EMPHASIS 0x1449
    
    // wav files giving the waveforms.
    // These have to also be included in the files target directive.
    #define NUM_WAVEFORMS 9  // Number of waveforms.
    char* waveform_files[] = { "Bass-Drum-1.wav", "Hi-Bongo.wav",
            "Claves.wav", "High-Conga-1.wav",
            "Cowbell-1.wav", "Cuica-1.wav", "Guiro.wav",
            "Ensoniq-ESQ-1-Snare.wav", "Floor-Tom-1.wav"};
            
    // The waveforms themselves.
    lf_waveform_t* waveforms[NUM_WAVEFORMS + 1];
    
    lf_waveform_t empty_waveform = { 0 };
    
    //////////////////////////////////////
    // Configuration of the user interface.

    char* message[] = {
        "Basic control:",
        "  x: quit",
        "Instrument:",
        "  0: none",
        "  1: bass drum",
        "  2: bongo",
        "  3: claves",
        "  4: conga",
        "  5: cowbell",
        "  6: cuica",
        "  7: guiro",
        "  8: snare",
        "  9: tom",
        "Rhythm:",
        "  d: down beat",
        "  m: merengue"
    };
    int message_length = 16;
        
=}

reactor RhythmSource(sixteenth:time(200 msec)) {
    timer t(0, sixteenth);
    
    output note:float;     // To play a note with the given emphasis.
    output instrument:int; // Instrument selection.
    
    // Count of sixteenth notes.
    state count:int(0);
    
    // Action to be invoked when a key is pressed.
    physical action key:char;
    
    // Indicator of when to make a sound.
    state rhythm:int({=DOWNBEAT=});
    
    // Indicator of whether to emphasize the sound.
    state emphasis:int({=DOWNBEAT=});

   // Currently active rhythm. This becomes
    // active from rhythm on the downbeat.
    state active_rhythm:int({=DOWNBEAT=});
    
    // Currently active emphasis. This becomes
    // active from rhythm on the downbeat.
    state active_emphasis:int({=DOWNBEAT=});
        
    // Position of the cursor in the terminal window.
    state cursor:int(0);
    
    reaction(startup) -> key, note {=
        // FIXME: See whether a note can be sent at the start time.
        SET(note, 1.0);
        // Start the sensor simulator, which starts ncurses.
        if (start_sensor_simulator()) {
            fprintf(stderr, "ERROR: Failed to start sensor simulator.\n");
            exit(1);
        }

        show_message(message, message_length);
        
        // Register action to trigger on key press.
        register_sensor_key('\0', key);
    =}
    
    reaction(key) -> instrument {=
        int numeric;
        switch (key->value) {
            case '0':
                SET(instrument, 0);
                break;
            case 'd':
                self->rhythm = DOWNBEAT;
                self->emphasis = DOWNBEAT;
                break;
            case 'm':
                self->rhythm =  MERENGUE;
                self->emphasis =  MERENGUE_EMPHASIS;
                break;
            case 'x':
                request_stop();
                break;
            default:
                numeric = (int)key->value;
                if (numeric >= 49 && numeric <= 57) {
                    // A digit between 1 and 9.
                    SET(instrument, numeric - 48);
                }
        }
    =}

    reaction(t) -> note {=
        int beeped = 0;
        int position = 0;
        position = 1 << self->count;
        if (position & self->active_rhythm) {
            double emphasis = 0.25;
            if (position & self->active_emphasis) {
                emphasis = 1.0;
            }
            SET(note, emphasis);
            beeped++;
        }
        pthread_mutex_lock(&sensor_mutex);
        if (beeped > 0) {
            if (position & self->active_emphasis) {
                printw("!");
            } else {
                printw("*");
            }
        } else {
            printw(".");
        }
        self->count++;
        if (self->count == 16) {
            self->active_rhythm = self->rhythm;
            self->active_emphasis = self->emphasis;
            self->count = 0;
            int term_height, term_width;
            getmaxyx(stdscr, term_height, term_width);   // Get the size of the terminal window.
            self->cursor++;
            if (self->cursor >= term_height) {
                self->cursor = 0;
            }
            move(self->cursor, 0);
        }
        refresh();
        pthread_mutex_unlock(&sensor_mutex);
    =}
}

/**
 * Produce a note when a `note` input is received.
 * 
 * This reactor provides a small collection of built-in audio
 * waveforms which are read at startup time from .wav files.
 * The waveform input specifies which of the waveforms to play
 * upon the next `note` input received.
 * It is a number between 0 and NUM_WAVEFORMS. If a number outside
 * this range is received, then simple tick sounds will be produced.
 * Number 0 is specially interpreted for silence.
 *
 * The `note` input is a number, normally between 0.0 and 1.0,
 * that specifies the loudness of the note. If the loudness exceeds
 * 1.0, or if too many notes are played at once, clipping may occur.
 * 
 */
reactor PlayWaveform {
    input note:float;
    input waveform:int;
    
    /**
     * Index of the current waveform.
     * -1 means no waveform (just make ticks)).
     */
    state waveform_id:int(0);
        
    reaction(startup) {=
        
        // First waveform is empty.
        waveforms[0] = &empty_waveform;
        
        // Open and read waveform files.
        for (int i = 0; i < NUM_WAVEFORMS; i++) {
            waveforms[i + 1] = read_wave_file(waveform_files[i]);
        }
        
        // Start an audio loop that will become ready to receive
        // amplitude samples of audio data.
        lf_start_audio_loop(get_logical_time());
    =}
    
    reaction(waveform) {=
        self->waveform_id = waveform->value;
    =}
    
    reaction(note) {=
        if (self->waveform_id < 0 || self->waveform_id > NUM_WAVEFORMS) {
            lf_play_audio_waveform(NULL, note->value, get_logical_time());
        } else {
            lf_play_audio_waveform(waveforms[self->waveform_id], note->value, get_logical_time());
        }
    =} deadline (10 msec) {=  // NOTE: deadline has to match BUFFER_DURATION_NS.
        fprintf(stderr, "WARNING: Missed deadline!\n");
    =}
    
    reaction(shutdown) {=
        lf_stop_audio_loop();
    =}
}

main reactor RhythmMac {
    source = new RhythmSource();
    play = new PlayWaveform();
    source.note -> play.note;
    source.instrument -> play.waveform;
}
