target C {threads: 1, keepalive: true, flags: "-lncurses"};

preamble {=
    #include <stdio.h>
	#include <stdlib.h>
	#include <curses.h>

	struct {
        void* brake;
        void* accelerate;
    } pedals;

	int calc_torque(int angle) {  // ~0-600 Nm in Tesla Model 3
        return 100 * angle;
    }

	int calc_force(int angle) {
        return 100 * angle;
    }

	void* read_input(void* arg) {
        initscr();
	    noecho();		   // Don't echo input
	    cbreak();          // Don't interrupt for user input
	    timeout(1);        // Wait for key press in ms
	    printw("***************************************************************\n");
        printw("Press '1-6' to change the angle of the accelerator\n");
        printw("Press 'q-y' to change the angle of the brake pedal\n");
	    int c = 0;         // Command: [1-6|q-y]
	    int v = 0;
	    while (true) {
	    	bool skip = false; // Whether to schedule and event or not  	
	      	c = getch();
	      	switch(c) {
                case 'q':
                	v = 0;
                	break;
                case 'w':
                	v = 1;
                	break;
                case 'e':
                	v = 2;
                	break;
                case 'r':
                	v = 3;
                	break;
                case 't':
                	v = 4;
                	break;
                case 'y':
                	v = 5;
                	break;
                default:
                	skip = true;
                	break;
            }
	      	
	      	if (!skip) {
                schedule_int(pedals.brake, 0, v);
            }
            
           	skip = false;
	      	switch(c) {
                case '1':
                	v = 0;
                	break;
                case '2':
                	v = 1;
                	break;
                case '3':
                	v = 2;
                	break;
                case '4':
                	v = 3;
                	break;
                case '5':
                	v = 4;
                	break;
                case '6':
                	v = 5;
                	break;
                default:
                	skip = true;
                	break;
            }
	      	
	      	if (!skip) {
                schedule_int(pedals.accelerate, 0, v);
            }	         
	   }
	   endwin();
	   return 0;
	}   
=}

reactor EngineControl {
	
	input applied:bool;
	input angle:int;
	output torque:int;
	state braking:bool(true);
	state accelerating:bool(false);
	
	reaction(applied) -> torque {=
		self->braking = applied->value; 
	=}
	
	reaction(angle) -> torque {= 
		if (!self->braking) {
			SET(torque, calc_torque(angle->value));
			if (angle->value > 0) {
            	self->accelerating = true; 
            } else {
                self->accelerating = false;
            }
			
		} else if (angle->value > 0){
            printw("Cannot accelerate; release brake pedal first.\n");
        }
	=}
	
	reaction(applied) -> torque {=
        if(self->braking && self->accelerating) {
			SET(torque, 0);
		}
    =}
}

reactor BrakePedal { 
	output angle:int;
	output applied:bool;
	
	physical action a(0, 1 msec, "replace"):int;
	state last:int(1);
	
   	reaction(startup) -> a {=
        pedals.brake = a;
	=}
   
    reaction(a) -> angle, applied {=
    	if (self->last != a->value) {
        	if (self->last == 0) {
                SET(applied, true); // zero to nonzero
            } else if (a->value == 0) {
                SET(applied, false); // nonzero to zero
            }
            
        	self->last = a->value;
        	
 			SET(angle, a->value);       	
        }
     =}
}

reactor Accelerator {
       
    state pedal:int(-1);
    physical action a(0, 2 msec, "replace"):int;
    output angle:int;
    state last:int(0);
    
    // Swapping these two reactions creates a cycle.
    
    reaction(startup) -> a {=
        pedals.accelerate = a;
	=}
    
    reaction(a) -> angle {=
        if (self->last != a->value) {
			SET(angle, a->value);
			self->last = a->value;
        }
    =}    
    
}

// Simply apply the requested force
reactor Brakes {
	input force:int;
	
	reaction(force) {=
        printw("Adjusting brake power to %dN; on time!\n", force->value);
    =} deadline (3 msec) {=
        printw("Adjusting brake power to %dN; too late!\n", force->value);
    =}
}

// Simply apply the requested torque
reactor Engine {
	input torque:int;
	
	reaction(torque) {=
        printw("Adjusting engine torque to %dNm; on time!\n", torque->value);
    =} deadline (5 msec) {=
        printw("Adjusting engine torque to %dNm; too late!\n", torque->value);
    =}
}

reactor BrakeControl {
	input angle:int;
	output force:int;
	
	reaction(angle) -> force {=
        SET(force, calc_force(angle->value));
    =}
}

main reactor PowerTrain {
    reaction(startup) {=
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, &read_input, NULL);
    =}
    
	bp = new BrakePedal();
	a = new Accelerator();
	bc = new BrakeControl();
	ec = new EngineControl();
	b = new Brakes();
	e = new Engine();
	
	bp.angle -> bc.angle;
	bc.force -> b.force;
	bp.applied -> ec.applied;
	ec.torque -> e.torque;
	a.angle -> ec.angle;
	
}