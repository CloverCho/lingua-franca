// Code generated by the Lingua Franca compiler from file:
// /Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf
#include "ctarget.h"
#define NUMBER_OF_FEDERATES 1
#include "core/reactor_threaded.c"
// =============== START reactor class MQTTPublisher
// *********** From the preamble, verbatim:
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
#include "MQTTClient.h"
#include "util.h"

// Timeout for completion of message sending in milliseconds.
#define TIMEOUT     10000L
 
// Connection options for the client.
// Making this global means that all instances of this reactor have
// the same connection options.
MQTTClient_connectOptions pub_connect_options = MQTTClient_connectOptions_initializer;
 
// Struct type used to keep track of messages in flight between reactions.
typedef struct inflight_t {
    bool message_in_flight;
    MQTTClient_deliveryToken delivery_token;
    char* message;
} inflight_t;

// Callback invoked once delivery is complete.
void pub_delivered(void *inflight, MQTTClient_deliveryToken dt) {
    // printf("DEBUG: Message with token value %d delivery confirmed\n", dt);
    ((inflight_t*)inflight)->message_in_flight = false;
    free(((inflight_t*)inflight)->message);
}
// Callback invoked if the connection is lost.
void pub_connection_lost(void *context, char *cause) {
    printf("\nMQTTPublisher: Connection lost\n");
    printf("  cause: %s\n", cause);
}
    

// *********** End of preamble.
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    char* value;
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int num_destinations;
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    token_t* token;
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int length;
#line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} mqttpublisher_in_t;
typedef struct {
    int bank_index;
    #line 37 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    string topic;
    #line 38 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    string address;
    #line 39 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    string clientID;
    #line 40 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int include_physical_timestamp;
    #line 80 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    inflight_t inflight;
    #line 83 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    MQTTClient client;
    #line 86 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    MQTTClient_message mqtt_msg;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    mqttpublisher_in_t* __in;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // width of -2 indicates that it is not a multiport.
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int __in__width;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Default input (in case it does not get connected)
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    mqttpublisher_in_t __default__in;
    #line 89 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_0;
    #line 120 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_1;
    #line 178 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_2;
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    trigger_t ___shutdown;
    reaction_t* ___shutdown_reactions[1];
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___in;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t* ___in_reactions[1];
} mqttpublisher_self_t;
void mqttpublisherreaction_function_0(void* instance_args) {
    mqttpublisher_self_t* self = (mqttpublisher_self_t*)instance_args;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    MQTTClient_create(&self->client, self->address, self->clientID, MQTTCLIENT_PERSISTENCE_NONE, NULL);
    pub_connect_options.keepAliveInterval = 20;
    pub_connect_options.cleansession = 1;
    
    // Set up callback functions.
    // Second to last argument should be a pointer to a function
    // to handle notification of delivery of a message.
    // But this reactor isn't sending any messages.
    // Second argument is a pointer to context that will be passed to pub_delivered,
    // which in this case is a pointer to the inflight state variable.
    MQTTClient_setCallbacks(self->client, &self->inflight, pub_connection_lost, NULL, pub_delivered);
    
    // Connect to the broker.
    int rc; // response code.
    if ((rc = MQTTClient_connect(self->client, &pub_connect_options)) != MQTTCLIENT_SUCCESS) {
        fprintf(stderr, "MQTTPublisher: Failed to connect to MQTT broker.\n");
        fprintf(stderr, "Perhaps one is not running? Return code: %d\n", rc);
        exit(EXIT_FAILURE);
    }
    // printf("DEBUG: MQTTPublisher connected to broker.\n");
        
}
void mqttpublisherreaction_function_1(void* instance_args) {
    mqttpublisher_self_t* self = (mqttpublisher_self_t*)instance_args;
    mqttpublisher_in_t* in = self->__in;
    if (in->is_present) {
        in->length = in->token->length;
        in->value = (char*)in->token->value;
    } else {
        in->length = 0;
    }
    int in_width = self->__in__width;
    #line 121 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    if(self->inflight.message_in_flight) {
        // Wait for message delivery to be complete.
        // printf("DEBUG: Waiting for publication of previous message\n");
        int rc = MQTTClient_waitForCompletion(self->client, self->inflight.delivery_token, TIMEOUT);
        if (rc != MQTTCLIENT_SUCCESS) {
            fprintf(stderr, "ERROR: Message delivery failed with error code %d.\n", rc);
            fprintf(stderr, "Message: %s\n", in->value);
            fprintf(stderr, "On topic '%s' for publisher with ClientID: %s\n", self->topic, self->clientID);
        }
    }
     //printf("DEBUG: Publishing message: %s\n", in->value);
    // printf("DEBUG: on topic '%s' for publisher with ClientID: %s\n", self->topic, self->clientID);
    
    // Allocate memory for a copy of the message.
    // The length includes the null-terminator of the string and 8 bytes for the timestamp.
    int length = strlen(in->value) + 1 + sizeof(instant_t);
    if (self->include_physical_timestamp) {
        length += sizeof(instant_t);
    }
    self->inflight.message = malloc(sizeof(char) * length);
    memcpy(self->inflight.message, in->value, strlen(in->value) + 1);
    
    // Append the current timestamp to the message.
    // This is always last, after the physical timestamp if it is included.
    encode_ll(get_logical_time(), 
        (unsigned char*)(self->inflight.message + length - sizeof(instant_t))
    );
    // printf("DEBUG: Timestamp of sending message: %lld.\n", *timestamp);
    
    self->mqtt_msg.payload = self->inflight.message;
    self->mqtt_msg.payloadlen = length;
    
    // QoS 2 means that the message will be delivered exactly once.
    self->mqtt_msg.qos = 2;
    
    // Retained messages are held by the server and sent to future new subscribers.
    // Specify that this message should not be retained.
    // It will be sent only to subscribers currently subscribed.
    self->mqtt_msg.retained = 0;
    
    // As close as possible to the publishing of the message, insert
    // the physical timestamp if it has been requested.
    if (self->include_physical_timestamp) {
        encode_ll(get_physical_time(),
            (unsigned char*)(self->inflight.message + length - 2 * sizeof(instant_t))
        );
    }
    //For Dashboard, echo physical time stamp
    else {
        printf("EVENT: sender_pts: %lld\n", get_physical_time());
    }        
    
    MQTTClient_publishMessage(self->client, self->topic, &self->mqtt_msg, &self->inflight.delivery_token);
    self->inflight.message_in_flight = true;        
        
}
void mqttpublisherreaction_function_2(void* instance_args) {
    mqttpublisher_self_t* self = (mqttpublisher_self_t*)instance_args;
    #line 179 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    printf("MQTTPublisher: Client ID %s disconnecting.\n", self->clientID);
    MQTTClient_disconnect(self->client, 10000);
    MQTTClient_destroy(&self->client);
        
}
mqttpublisher_self_t* new_MQTTPublisher() {
    mqttpublisher_self_t* self = (mqttpublisher_self_t*)calloc(1, sizeof(mqttpublisher_self_t));
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Set input by default to an always absent default input.
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->__in = &self->__default__in;
    #line 89 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.function = mqttpublisherreaction_function_0;
    #line 89 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.self = self;
    #line 89 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 89 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.tardy_handler = NULL;
    #line 120 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.function = mqttpublisherreaction_function_1;
    #line 120 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.self = self;
    #line 120 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 120 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.tardy_handler = NULL;
    #line 178 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.function = mqttpublisherreaction_function_2;
    #line 178 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.self = self;
    #line 178 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.deadline_violation_handler = NULL;
    #line 178 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.tardy_handler = NULL;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    self->___shutdown_reactions[0] = &self->___reaction_2;
    self->___shutdown.last = NULL;
    self->___shutdown.reactions = &self->___shutdown_reactions[0];
    self->___shutdown.number_of_reactions = 1;
    self->___shutdown.is_timer = false;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___in.last = NULL;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___in_reactions[0] = &self->___reaction_1;
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___in.reactions = &self->___in_reactions[0];
    #line 77 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___in.number_of_reactions = 1;
    self->___in.element_size = sizeof(char);
    return self;
}
void delete_MQTTPublisher(mqttpublisher_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    free(self);
}
// =============== END reactor class MQTTPublisher

// =============== START reactor class phaseChanger
// *********** From the preamble, verbatim:
#line 24 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
#define BILLION 1000000000LL
        typedef struct spat_status{
            int signal_phase; //integer code for signal 1-Red, 2-Green, 3-Yellow
            long long unsigned residual; // remaining time for phase change
        } spat_status;
        
     

// *********** End of preamble.
#line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int value;
#line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int num_destinations;
#line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_in_t;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    char* value;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int num_destinations;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    token_t* token;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int length;
#line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_out_t;
#line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    spat_status value;
#line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int num_destinations;
#line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_outStruct_t;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t* trigger;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int value;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool has_value;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    token_t* token;
#line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_red_t;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t* trigger;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int value;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool has_value;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    token_t* token;
#line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_green_t;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
typedef struct {
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t* trigger;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int value;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool is_present;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    bool has_value;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    token_t* token;
#line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
} phasechanger_yellow_t;
typedef struct {
    int bank_index;
    #line 36 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    spat_status status;
    #line 39 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    interval_t phase_start_time;
    #line 40 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    interval_t phase_duration;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_red_t __red;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_green_t __green;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_yellow_t __yellow;
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_in_t* __in;
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // width of -2 indicates that it is not a multiport.
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int __in__width;
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Default input (in case it does not get connected)
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_in_t __default__in;
    #line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_out_t __out;
    #line 33 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int __out__width;
    #line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_outStruct_t __outStruct;
    #line 34 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    int __outStruct__width;
    #line 46 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_0;
    #line 51 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_1;
    #line 71 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_2;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_3;
    #line 110 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t ___reaction_4;
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___t;
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t* ___t_reactions[1];
    trigger_t ___startup;
    reaction_t* ___startup_reactions[1];
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___red;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t* ___red_reactions[1];
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___green;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t* ___green_reactions[1];
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___yellow;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    reaction_t* ___yellow_reactions[1];
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    trigger_t ___in;
} phasechanger_self_t;
void phasechangerreaction_function_0(void* instance_args) {
    phasechanger_self_t* self = (phasechanger_self_t*)instance_args;
    phasechanger_red_t* red = &self->__red;
    #line 47 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    schedule_int(red, MSEC(100), 1);
    self->phase_start_time = get_logical_time();
        
}
void phasechangerreaction_function_1(void* instance_args) {
    phasechanger_self_t* self = (phasechanger_self_t*)instance_args;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Expose the action struct as a local variable whose name matches the action name.
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_red_t* red = &self->__red;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Set the fields of the action struct to match the current trigger.
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    red->is_present = self->___red.is_present;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    red->has_value = ((self->___red.token) != NULL && (self->___red.token)->value != NULL);
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    red->token = (self->___red.token);
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    if (red->has_value) {
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
        red->value = *(int*)(self->___red.token)->value;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    }
    phasechanger_green_t* green = &self->__green;
    phasechanger_out_t* out = &self->__out;
    phasechanger_outStruct_t* outStruct = &self->__outStruct;
    #line 52 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->status.signal_phase = red->value;
    self->phase_duration = MSEC(5000);
    self->phase_start_time = get_logical_time();
    
    self->status.residual = self->phase_duration;
            int length = snprintf(NULL, 0, "%d %llu", self->status.signal_phase, self->status.residual) + 1;
            // Dynamically allocate memory for the output.
            SET_NEW_ARRAY(out, length);
            // Populate the output string and increment the count.
            snprintf(out->value, length, "%d %llu", self->status.signal_phase, self->status.residual);
            printf("spatRecommender: At phy time %lld, phase change message: %s\n",
                get_physical_time(),
                out->value
            );
            
            
            SET(outStruct, self->status);
    schedule_int(green, self->phase_duration, 2);
        
}
void phasechangerreaction_function_2(void* instance_args) {
    phasechanger_self_t* self = (phasechanger_self_t*)instance_args;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Expose the action struct as a local variable whose name matches the action name.
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_green_t* green = &self->__green;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Set the fields of the action struct to match the current trigger.
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    green->is_present = self->___green.is_present;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    green->has_value = ((self->___green.token) != NULL && (self->___green.token)->value != NULL);
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    green->token = (self->___green.token);
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    if (green->has_value) {
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
        green->value = *(int*)(self->___green.token)->value;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    }
    phasechanger_yellow_t* yellow = &self->__yellow;
    phasechanger_out_t* out = &self->__out;
    #line 72 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->status.signal_phase = green->value;
    self->phase_duration = MSEC(3000);
    self->phase_start_time = get_logical_time();
    
    self->status.residual = self->phase_duration;
            int length = snprintf(NULL, 0, "%d %llu", self->status.signal_phase, self->status.residual) + 1;
            // Dynamically allocate memory for the output.
            SET_NEW_ARRAY(out, length);
            // Populate the output string and increment the count.
            snprintf(out->value, length, "%d %llu", self->status.signal_phase, self->status.residual);
            printf("spatRecommender: At phy time %lld, phase change message: %s\n",
                get_physical_time(),
                out->value
            );
    
    schedule_int(yellow, self->phase_duration, 3);
        
}
void phasechangerreaction_function_3(void* instance_args) {
    phasechanger_self_t* self = (phasechanger_self_t*)instance_args;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Expose the action struct as a local variable whose name matches the action name.
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    phasechanger_yellow_t* yellow = &self->__yellow;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Set the fields of the action struct to match the current trigger.
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    yellow->is_present = self->___yellow.is_present;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    yellow->has_value = ((self->___yellow.token) != NULL && (self->___yellow.token)->value != NULL);
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    yellow->token = (self->___yellow.token);
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    if (yellow->has_value) {
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
        yellow->value = *(int*)(self->___yellow.token)->value;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    }
    phasechanger_red_t* red = &self->__red;
    phasechanger_out_t* out = &self->__out;
    #line 91 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->status.signal_phase = yellow->value;
    self->phase_duration = MSEC(1000);
    self->phase_start_time = get_logical_time();
    
    self->status.residual = self->phase_duration;
            int length = snprintf(NULL, 0, "%d %llu", self->status.signal_phase, self->status.residual) + 1;
            // Dynamically allocate memory for the output.
            SET_NEW_ARRAY(out, length);
            // Populate the output string and increment the count.
            snprintf(out->value, length, "%d %llu", self->status.signal_phase, self->status.residual);
            printf("spatRecommender: At phy time %lld, phase change message: %s\n",
                get_physical_time(),
                out->value
            );
            
            schedule_int(red, self->phase_duration, 1);
        
}
void phasechangerreaction_function_4(void* instance_args) {
    phasechanger_self_t* self = (phasechanger_self_t*)instance_args;
    phasechanger_out_t* out = &self->__out;
    #line 111 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    
    self->status.residual = self->phase_duration - get_logical_time() + self->phase_start_time;
    int length = snprintf(NULL, 0, "%d %llu", self->status.signal_phase, self->status.residual) + 1;
            // Dynamically allocate memory for the output.
            SET_NEW_ARRAY(out, length);
            // Populate the output string and increment the count.
            snprintf(out->value, length, "%d %llu", self->status.signal_phase, self->status.residual);
            printf("spatRecommender: At phy time %lld, publish message: %s\n",
                get_physical_time(),
                out->value
            );
        
}
phasechanger_self_t* new_phaseChanger() {
    phasechanger_self_t* self = (phasechanger_self_t*)calloc(1, sizeof(phasechanger_self_t));
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->__red.trigger = &self->___red;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->__green.trigger = &self->___green;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->__yellow.trigger = &self->___yellow;
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    // Set input by default to an always absent default input.
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->__in = &self->__default__in;
    #line 46 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.function = phasechangerreaction_function_0;
    #line 46 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.self = self;
    #line 46 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.deadline_violation_handler = NULL;
    #line 46 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_0.tardy_handler = NULL;
    #line 51 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.function = phasechangerreaction_function_1;
    #line 51 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.self = self;
    #line 51 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.deadline_violation_handler = NULL;
    #line 51 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_1.tardy_handler = NULL;
    #line 71 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.function = phasechangerreaction_function_2;
    #line 71 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.self = self;
    #line 71 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.deadline_violation_handler = NULL;
    #line 71 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_2.tardy_handler = NULL;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_3.function = phasechangerreaction_function_3;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_3.self = self;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_3.deadline_violation_handler = NULL;
    #line 90 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_3.tardy_handler = NULL;
    #line 110 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_4.function = phasechangerreaction_function_4;
    #line 110 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_4.self = self;
    #line 110 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_4.deadline_violation_handler = NULL;
    #line 110 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___reaction_4.tardy_handler = NULL;
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___t.last = NULL;
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___t_reactions[0] = &self->___reaction_4;
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___t.reactions = &self->___t_reactions[0];
    #line 109 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___t.number_of_reactions = 1;
    self->___t.is_timer = true;
    self->___startup_reactions[0] = &self->___reaction_0;
    self->___startup.last = NULL;
    self->___startup.reactions = &self->___startup_reactions[0];
    self->___startup.number_of_reactions = 1;
    self->___startup.is_timer = false;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___red.last = NULL;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___red_reactions[0] = &self->___reaction_1;
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___red.reactions = &self->___red_reactions[0];
    #line 42 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___red.number_of_reactions = 1;
    self->___red.is_physical = false;
    self->___red.element_size = sizeof(int);
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___green.last = NULL;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___green_reactions[0] = &self->___reaction_2;
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___green.reactions = &self->___green_reactions[0];
    #line 43 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___green.number_of_reactions = 1;
    self->___green.is_physical = false;
    self->___green.element_size = sizeof(int);
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___yellow.last = NULL;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___yellow_reactions[0] = &self->___reaction_3;
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___yellow.reactions = &self->___yellow_reactions[0];
    #line 44 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___yellow.number_of_reactions = 1;
    self->___yellow.is_physical = false;
    self->___yellow.element_size = sizeof(int);
    #line 32 "file:/Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/spatRecommender.lf"
    self->___in.last = NULL;
    self->___in.element_size = sizeof(int);
    return self;
}
void delete_phaseChanger(phasechanger_self_t* self) {
    if (self->___reaction_0.output_produced != NULL) {
        free(self->___reaction_0.output_produced);
    }
    if (self->___reaction_0.triggers != NULL) {
        free(self->___reaction_0.triggers);
    }
    if (self->___reaction_0.triggered_sizes != NULL) {
        free(self->___reaction_0.triggered_sizes);
    }
    if (self->___reaction_1.output_produced != NULL) {
        free(self->___reaction_1.output_produced);
    }
    if (self->___reaction_1.triggers != NULL) {
        free(self->___reaction_1.triggers);
    }
    if (self->___reaction_1.triggered_sizes != NULL) {
        free(self->___reaction_1.triggered_sizes);
    }
    if (self->___reaction_2.output_produced != NULL) {
        free(self->___reaction_2.output_produced);
    }
    if (self->___reaction_2.triggers != NULL) {
        free(self->___reaction_2.triggers);
    }
    if (self->___reaction_2.triggered_sizes != NULL) {
        free(self->___reaction_2.triggered_sizes);
    }
    if (self->___reaction_3.output_produced != NULL) {
        free(self->___reaction_3.output_produced);
    }
    if (self->___reaction_3.triggers != NULL) {
        free(self->___reaction_3.triggers);
    }
    if (self->___reaction_3.triggered_sizes != NULL) {
        free(self->___reaction_3.triggered_sizes);
    }
    if (self->___reaction_4.output_produced != NULL) {
        free(self->___reaction_4.output_produced);
    }
    if (self->___reaction_4.triggers != NULL) {
        free(self->___reaction_4.triggers);
    }
    if (self->___reaction_4.triggered_sizes != NULL) {
        free(self->___reaction_4.triggered_sizes);
    }
    for(int i = 0; i < self->___reaction_0.num_outputs; i++) {
        free(self->___reaction_0.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_1.num_outputs; i++) {
        free(self->___reaction_1.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_2.num_outputs; i++) {
        free(self->___reaction_2.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_3.num_outputs; i++) {
        free(self->___reaction_3.triggers[i]);
    }
    for(int i = 0; i < self->___reaction_4.num_outputs; i++) {
        free(self->___reaction_4.triggers[i]);
    }
    free(self);
}
// =============== END reactor class phaseChanger

// =============== START reactor class spatRecommender
typedef struct {
    int bank_index;
} spatrecommender_self_t;
spatrecommender_self_t* new_spatRecommender() {
    spatrecommender_self_t* self = (spatrecommender_self_t*)calloc(1, sizeof(spatrecommender_self_t));
    return self;
}
void delete_spatRecommender(spatrecommender_self_t* self) {
    free(self);
}
// =============== END reactor class spatRecommender

char* __default_argv[] = {"X", "-k", "true", "-o", "60", "secs"};
void __set_default_command_line_options() {
    default_argc = 6;
    default_argv = __default_argv;
}
// Array of pointers to timer triggers to be scheduled in __initialize_timers().
trigger_t* __timer_triggers[1];
int __timer_triggers_size = 1;
// Array of pointers to timer triggers to be scheduled in __trigger_startup_reactions().
reaction_t* __startup_reactions[2];
int __startup_reactions_size = 2;
// Array of pointers to shutdown triggers.
trigger_t* __shutdown_triggers[1];
int __shutdown_triggers_size = 1;
trigger_t* __action_for_port(int port_id) {
    return NULL;
}
void __initialize_trigger_objects() {
    __tokens_with_ref_count_size = 4;
    __tokens_with_ref_count = (token_present_t*)malloc(4 * sizeof(token_present_t));
    // Create the array that will contain pointers to is_present fields to reset on each step.
    __is_present_fields_size = 5;
    __is_present_fields = (bool**)malloc(5 * sizeof(bool*));
    // ************* Instance spatRecommender of class spatRecommender
    spatrecommender_self_t* spatrecommender_self = new_spatRecommender();
    //***** Start initializing spatRecommender
    // ************* Instance spatRecommender.signal of class phaseChanger
    phasechanger_self_t* spatrecommender_signal_self = new_phaseChanger();
    //***** Start initializing spatRecommender.signal
    // width of -2 indicates that it is not a multiport.
    spatrecommender_signal_self->__out__width = -2;
    // width of -2 indicates that it is not a multiport.
    spatrecommender_signal_self->__outStruct__width = -2;
    __startup_reactions[0] = &spatrecommender_signal_self->___reaction_0;
    // width of -2 indicates that it is not a multiport.
    spatrecommender_signal_self->__in__width = -2;
    static spat_status spatrecommender_signal_initial_status = {1, 0};
    spatrecommender_signal_self->status = spatrecommender_signal_initial_status;
    spatrecommender_signal_self->phase_start_time = MSEC(0);
    spatrecommender_signal_self->phase_duration = MSEC(0);
    spatrecommender_signal_self->___red.offset = 0;
    spatrecommender_signal_self->___red.period = -1;
    spatrecommender_signal_self->___green.offset = 0;
    spatrecommender_signal_self->___green.period = -1;
    spatrecommender_signal_self->___yellow.offset = 0;
    spatrecommender_signal_self->___yellow.period = -1;
    spatrecommender_signal_self->___t.offset = 0;
    spatrecommender_signal_self->___t.period = MSEC(500);
    __timer_triggers[0] = &spatrecommender_signal_self->___t;
    spatrecommender_signal_self->___red.token = __create_token(sizeof(int));
    spatrecommender_signal_self->___red.is_present = false;
    __tokens_with_ref_count[0].token
            = &spatrecommender_signal_self->___red.token;
    __tokens_with_ref_count[0].is_present
            = &spatrecommender_signal_self->___red.is_present;
    __tokens_with_ref_count[0].reset_is_present = true;
    spatrecommender_signal_self->___green.token = __create_token(sizeof(int));
    spatrecommender_signal_self->___green.is_present = false;
    __tokens_with_ref_count[1].token
            = &spatrecommender_signal_self->___green.token;
    __tokens_with_ref_count[1].is_present
            = &spatrecommender_signal_self->___green.is_present;
    __tokens_with_ref_count[1].reset_is_present = true;
    spatrecommender_signal_self->___yellow.token = __create_token(sizeof(int));
    spatrecommender_signal_self->___yellow.is_present = false;
    __tokens_with_ref_count[2].token
            = &spatrecommender_signal_self->___yellow.token;
    __tokens_with_ref_count[2].is_present
            = &spatrecommender_signal_self->___yellow.is_present;
    __tokens_with_ref_count[2].reset_is_present = true;
    //***** End initializing spatRecommender.signal
    // ************* Instance spatRecommender.pub of class MQTTPublisher
    mqttpublisher_self_t* spatrecommender_pub_self = new_MQTTPublisher();
    //***** Start initializing spatRecommender.pub
    spatrecommender_pub_self->topic = "spat/rsu101"; 
    spatrecommender_pub_self->address = "tcp://localhost:1883"; 
    spatrecommender_pub_self->clientID = "Intersection Signal 101"; 
    spatrecommender_pub_self->include_physical_timestamp = 0; 
    __startup_reactions[1] = &spatrecommender_pub_self->___reaction_0;
    __shutdown_triggers[0] = &spatrecommender_pub_self->___shutdown;
    // width of -2 indicates that it is not a multiport.
    spatrecommender_pub_self->__in__width = -2;
    static inflight_t spatrecommender_pub_initial_inflight = {false, 0, NULL};
    spatrecommender_pub_self->inflight = spatrecommender_pub_initial_inflight;
    static MQTTClient spatrecommender_pub_initial_client = NULL;
    spatrecommender_pub_self->client = spatrecommender_pub_initial_client;
    static MQTTClient_message spatrecommender_pub_initial_mqtt_msg = MQTTClient_message_initializer;
    spatrecommender_pub_self->mqtt_msg = spatrecommender_pub_initial_mqtt_msg;
    //***** End initializing spatRecommender.pub
    //***** End initializing spatRecommender
    // Populate arrays of trigger pointers.
    spatrecommender_self->bank_index = 0;
    spatrecommender_signal_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    spatrecommender_signal_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_signal_self->___reaction_0.num_outputs > 0) {
        spatrecommender_signal_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_signal_self->___reaction_0.num_outputs);
        spatrecommender_signal_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_signal_self->___reaction_0.num_outputs);
        spatrecommender_signal_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_signal_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    spatrecommender_signal_self->___reaction_1.num_outputs = 2;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_signal_self->___reaction_1.num_outputs > 0) {
        spatrecommender_signal_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_signal_self->___reaction_1.num_outputs);
        spatrecommender_signal_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_signal_self->___reaction_1.num_outputs);
        spatrecommender_signal_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_signal_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    spatrecommender_signal_self->___reaction_1.output_produced[0]
    = &spatrecommender_signal_self->__out.is_present
    ;
    spatrecommender_signal_self->___reaction_1.output_produced[1]
    = &spatrecommender_signal_self->__outStruct.is_present
    ;
    // Total number of outputs produced by the reaction.
    spatrecommender_signal_self->___reaction_2.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_signal_self->___reaction_2.num_outputs > 0) {
        spatrecommender_signal_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_signal_self->___reaction_2.num_outputs);
        spatrecommender_signal_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_signal_self->___reaction_2.num_outputs);
        spatrecommender_signal_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_signal_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    spatrecommender_signal_self->___reaction_2.output_produced[0]
    = &spatrecommender_signal_self->__out.is_present
    ;
    // Total number of outputs produced by the reaction.
    spatrecommender_signal_self->___reaction_3.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_signal_self->___reaction_3.num_outputs > 0) {
        spatrecommender_signal_self->___reaction_3.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_signal_self->___reaction_3.num_outputs);
        spatrecommender_signal_self->___reaction_3.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_signal_self->___reaction_3.num_outputs);
        spatrecommender_signal_self->___reaction_3.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_signal_self->___reaction_3.num_outputs);
    }
    // Initialize the output_produced array.
    spatrecommender_signal_self->___reaction_3.output_produced[0]
    = &spatrecommender_signal_self->__out.is_present
    ;
    // Total number of outputs produced by the reaction.
    spatrecommender_signal_self->___reaction_4.num_outputs = 1;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_signal_self->___reaction_4.num_outputs > 0) {
        spatrecommender_signal_self->___reaction_4.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_signal_self->___reaction_4.num_outputs);
        spatrecommender_signal_self->___reaction_4.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_signal_self->___reaction_4.num_outputs);
        spatrecommender_signal_self->___reaction_4.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_signal_self->___reaction_4.num_outputs);
    }
    // Initialize the output_produced array.
    spatrecommender_signal_self->___reaction_4.output_produced[0]
    = &spatrecommender_signal_self->__out.is_present
    ;
    // Reaction 0 of spatRecommender.signal does not depend on one maximal upstream reaction.
    spatrecommender_signal_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of spatRecommender.signal depends on one maximal upstream reaction.
    spatrecommender_signal_self->___reaction_1.last_enabling_reaction = &(spatrecommender_signal_self->___reaction_0);
    // Reaction 1 of spatRecommender.signal triggers 1 downstream reactions through port spatRecommender.signal.out.
    spatrecommender_signal_self->___reaction_1.triggered_sizes[0] = 1;
    // For reaction 1 of spatRecommender.signal, allocate an
    // array of trigger pointers for downstream reactions through port spatRecommender.signal.out
    trigger_t** spatrecommender_signal_1_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    spatrecommender_signal_self->___reaction_1.triggers[0] = spatrecommender_signal_1_0;
    // Point to destination port spatRecommender.pub.in's trigger struct.
    spatrecommender_signal_1_0[0] = &spatrecommender_pub_self->___in;
    // Reaction 1 of spatRecommender.signal triggers 0 downstream reactions through port spatRecommender.signal.outStruct.
    spatrecommender_signal_self->___reaction_1.triggered_sizes[1] = 0;
    // Reaction 2 of spatRecommender.signal depends on one maximal upstream reaction.
    spatrecommender_signal_self->___reaction_2.last_enabling_reaction = &(spatrecommender_signal_self->___reaction_1);
    // Reaction 2 of spatRecommender.signal triggers 1 downstream reactions through port spatRecommender.signal.out.
    spatrecommender_signal_self->___reaction_2.triggered_sizes[0] = 1;
    // For reaction 2 of spatRecommender.signal, allocate an
    // array of trigger pointers for downstream reactions through port spatRecommender.signal.out
    trigger_t** spatrecommender_signal_2_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    spatrecommender_signal_self->___reaction_2.triggers[0] = spatrecommender_signal_2_0;
    // Point to destination port spatRecommender.pub.in's trigger struct.
    spatrecommender_signal_2_0[0] = &spatrecommender_pub_self->___in;
    // Reaction 3 of spatRecommender.signal depends on one maximal upstream reaction.
    spatrecommender_signal_self->___reaction_3.last_enabling_reaction = &(spatrecommender_signal_self->___reaction_2);
    // Reaction 3 of spatRecommender.signal triggers 1 downstream reactions through port spatRecommender.signal.out.
    spatrecommender_signal_self->___reaction_3.triggered_sizes[0] = 1;
    // For reaction 3 of spatRecommender.signal, allocate an
    // array of trigger pointers for downstream reactions through port spatRecommender.signal.out
    trigger_t** spatrecommender_signal_3_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    spatrecommender_signal_self->___reaction_3.triggers[0] = spatrecommender_signal_3_0;
    // Point to destination port spatRecommender.pub.in's trigger struct.
    spatrecommender_signal_3_0[0] = &spatrecommender_pub_self->___in;
    // Reaction 4 of spatRecommender.signal depends on one maximal upstream reaction.
    spatrecommender_signal_self->___reaction_4.last_enabling_reaction = &(spatrecommender_signal_self->___reaction_3);
    // Reaction 4 of spatRecommender.signal triggers 1 downstream reactions through port spatRecommender.signal.out.
    spatrecommender_signal_self->___reaction_4.triggered_sizes[0] = 1;
    // For reaction 4 of spatRecommender.signal, allocate an
    // array of trigger pointers for downstream reactions through port spatRecommender.signal.out
    trigger_t** spatrecommender_signal_4_0 = (trigger_t**)malloc(1 * sizeof(trigger_t*));
    spatrecommender_signal_self->___reaction_4.triggers[0] = spatrecommender_signal_4_0;
    // Point to destination port spatRecommender.pub.in's trigger struct.
    spatrecommender_signal_4_0[0] = &spatrecommender_pub_self->___in;
    spatrecommender_signal_self->__out.num_destinations
    = 1;
    spatrecommender_signal_self->__outStruct.num_destinations
    = 0;
    spatrecommender_pub_self->bank_index = 0;
    // Total number of outputs produced by the reaction.
    spatrecommender_pub_self->___reaction_0.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_pub_self->___reaction_0.num_outputs > 0) {
        spatrecommender_pub_self->___reaction_0.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_pub_self->___reaction_0.num_outputs);
        spatrecommender_pub_self->___reaction_0.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_pub_self->___reaction_0.num_outputs);
        spatrecommender_pub_self->___reaction_0.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_pub_self->___reaction_0.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    spatrecommender_pub_self->___reaction_1.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_pub_self->___reaction_1.num_outputs > 0) {
        spatrecommender_pub_self->___reaction_1.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_pub_self->___reaction_1.num_outputs);
        spatrecommender_pub_self->___reaction_1.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_pub_self->___reaction_1.num_outputs);
        spatrecommender_pub_self->___reaction_1.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_pub_self->___reaction_1.num_outputs);
    }
    // Initialize the output_produced array.
    // Total number of outputs produced by the reaction.
    spatrecommender_pub_self->___reaction_2.num_outputs = 0;
    // Allocate arrays for triggering downstream reactions.
    if (spatrecommender_pub_self->___reaction_2.num_outputs > 0) {
        spatrecommender_pub_self->___reaction_2.output_produced = (bool**)malloc(sizeof(bool*) * spatrecommender_pub_self->___reaction_2.num_outputs);
        spatrecommender_pub_self->___reaction_2.triggers = (trigger_t***)malloc(sizeof(trigger_t**) * spatrecommender_pub_self->___reaction_2.num_outputs);
        spatrecommender_pub_self->___reaction_2.triggered_sizes = (int*)malloc(sizeof(int) * spatrecommender_pub_self->___reaction_2.num_outputs);
    }
    // Initialize the output_produced array.
    // Reaction 0 of spatRecommender.pub does not depend on one maximal upstream reaction.
    spatrecommender_pub_self->___reaction_0.last_enabling_reaction = NULL;
    // Reaction 1 of spatRecommender.pub does not depend on one maximal upstream reaction.
    spatrecommender_pub_self->___reaction_1.last_enabling_reaction = NULL;
    // Reaction 2 of spatRecommender.pub depends on one maximal upstream reaction.
    spatrecommender_pub_self->___reaction_2.last_enabling_reaction = &(spatrecommender_pub_self->___reaction_1);
    // doDeferredInitialize
    spatrecommender_signal_self->__out.token = __create_token(sizeof(char));
    // Connect inputs and outputs for reactor spatRecommender.
    // Connect spatRecommender.signal.out to input port spatRecommender.pub.in
    spatrecommender_pub_self->__in = (mqttpublisher_in_t*)&spatrecommender_signal_self->__out;
    // Connect inputs and outputs for reactor spatRecommender.signal.
    // END Connect inputs and outputs for reactor spatRecommender.signal.
    // Connect inputs and outputs for reactor spatRecommender.pub.
    // END Connect inputs and outputs for reactor spatRecommender.pub.
    // END Connect inputs and outputs for reactor spatRecommender.
    // Add action spatRecommender.signal.red to array of is_present fields.
    __is_present_fields[0] 
            = &spatrecommender_signal_self->__red.is_present;
    // Add action spatRecommender.signal.green to array of is_present fields.
    __is_present_fields[1] 
            = &spatrecommender_signal_self->__green.is_present;
    // Add action spatRecommender.signal.yellow to array of is_present fields.
    __is_present_fields[2] 
            = &spatrecommender_signal_self->__yellow.is_present;
    __tokens_with_ref_count[3].token
            = &spatrecommender_pub_self->__in->token;
    __tokens_with_ref_count[3].is_present
            = &spatrecommender_pub_self->__in->is_present;
    __tokens_with_ref_count[3].reset_is_present = false;
    // Add port spatRecommender.signal.out to array of is_present fields.
    __is_present_fields[3] = &spatrecommender_signal_self->__out.is_present
    ;
    // Add port spatRecommender.signal.outStruct to array of is_present fields.
    __is_present_fields[4] = &spatrecommender_signal_self->__outStruct.is_present
    ;
    spatrecommender_signal_self->___reaction_0.chain_id = 15;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_signal_self->___reaction_0.index = 0x7fffffffffff0000LL;
    spatrecommender_signal_self->___reaction_1.chain_id = 15;
    // index is the OR of level 1 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_signal_self->___reaction_1.index = 0x7fffffffffff0001LL;
    spatrecommender_signal_self->___reaction_2.chain_id = 7;
    // index is the OR of level 2 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_signal_self->___reaction_2.index = 0x7fffffffffff0002LL;
    spatrecommender_signal_self->___reaction_3.chain_id = 3;
    // index is the OR of level 3 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_signal_self->___reaction_3.index = 0x7fffffffffff0003LL;
    spatrecommender_signal_self->___reaction_4.chain_id = 1;
    // index is the OR of level 4 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_signal_self->___reaction_4.index = 0x7fffffffffff0004LL;
    spatrecommender_pub_self->___reaction_0.chain_id = 16;
    // index is the OR of level 0 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_pub_self->___reaction_0.index = 0x7fffffffffff0000LL;
    spatrecommender_pub_self->___reaction_1.chain_id = 31;
    // index is the OR of level 5 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_pub_self->___reaction_1.index = 0x7fffffffffff0005LL;
    spatrecommender_pub_self->___reaction_2.chain_id = 31;
    // index is the OR of level 6 and 
    // deadline 140737488355327 shifted left 16 bits.
    spatrecommender_pub_self->___reaction_2.index = 0x7fffffffffff0006LL;
}
void __trigger_startup_reactions() {
    if (number_of_threads == 0) {
       number_of_threads = 1;
    }
    for (int i = 0; i < __startup_reactions_size; i++) {
        if (__startup_reactions[i] != NULL) {
            _lf_enqueue_reaction(__startup_reactions[i]);
        }
    }
}
void __initialize_timers() {
    for (int i = 0; i < __timer_triggers_size; i++) {
        if (__timer_triggers[i] != NULL) {
            _lf_initialize_timer(__timer_triggers[i]);
        }
    }
}
void logical_time_complete(instant_t time) {
}
instant_t next_event_time(instant_t time) {
    return time;
}
bool __wrapup() {
    __start_time_step();  // To free memory allocated for actions.
    for (int i = 0; i < __shutdown_triggers_size; i++) {
        __schedule(__shutdown_triggers[i], 0LL, NULL);
    }
    // Return true if there are shutdown actions.
    return (__shutdown_triggers_size > 0);
}
void __termination() {}
