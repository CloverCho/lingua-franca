// Code generated by the Lingua Franca compiler from file:
// /Users/ra/git/lingua-franca/example/Denso/SpatAnalysis/influxWrite.lf
import commandLineArgs from 'command-line-args'
import commandLineUsage from 'command-line-usage'
import {Args, Present, Parameter, State, Variable, Priority, Mutation, Read, Triggers, ReadWrite, Write, Named, Reaction, Action, Startup, Schedule, Timer, Reactor, Port, OutPort, InPort, App} from './reactor'
import {FederatedApp} from './federation'
import {TimeUnit, TimeValue, UnitBasedTimeValue, Tag, Origin} from './time'
import {Log} from './util'
import {ProcessedCommandLineArgs, CommandLineOptionDefs, CommandLineUsageDefs, CommandLineOptionSpec, unitBasedTimeValueCLAType, booleanCLAType} from './cli'

// Imports for protocol buffers

// ************* App Parameters
let __timeout: TimeValue | undefined = undefined;
let __keepAlive: boolean = false;
let __fast: boolean = false;

let __noStart = false; // If set to true, don't start the app.

// ************* Custom Command Line Arguments
let __additionalCommandLineArgs : CommandLineOptionSpec = [
];
let __customCommandLineArgs = CommandLineOptionDefs.concat(__additionalCommandLineArgs);
let __customCommandLineUsageDefs = CommandLineUsageDefs;
type __customCLTypeExtension = {};
__customCommandLineUsageDefs[1].optionList = __customCommandLineArgs;
const __clUsage = commandLineUsage(__customCommandLineUsageDefs);
             
// Set App parameters using values from the constructor or command line args.
// Command line args have precedence over values from the constructor
let __processedCLArgs: ProcessedCommandLineArgs & __customCLTypeExtension;
try {
    __processedCLArgs =  commandLineArgs(__customCommandLineArgs) as ProcessedCommandLineArgs & __customCLTypeExtension;
} catch (e){
    Log.global.error(__clUsage);
    throw new Error("Command line argument parsing failed with: " + e);
}

// Fast Parameter
if (__processedCLArgs.fast !== undefined) {
    if (__processedCLArgs.fast !== null) {
        __fast = __processedCLArgs.fast;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'fast' command line argument is malformed.");
    }
}

// KeepAlive parameter
if (__processedCLArgs.keepalive !== undefined) {
    if (__processedCLArgs.keepalive !== null) {
        __keepAlive = __processedCLArgs.keepalive;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'keepalive' command line argument is malformed.");
    }
}

// Timeout parameter
if (__processedCLArgs.timeout !== undefined) {
    if (__processedCLArgs.timeout !== null) {
        __timeout = __processedCLArgs.timeout;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'timeout' command line argument is malformed.");
    }
}

// Logging parameter (not a constructor parameter, but a command line option)
if (__processedCLArgs.logging !== undefined) {
    if (__processedCLArgs.logging !== null) {
        Log.global.level = __processedCLArgs.logging;
    } else {
        Log.global.error(__clUsage);
        throw new Error("'logging' command line argument is malformed.");
    }
} else {
    Log.global.level = Log.levels.ERROR; // Default from target property.
}

// Help parameter (not a constructor parameter, but a command line option)
// NOTE: this arg has to be checked after logging, because the help mode should
// suppress debug statements from it changes logging
if (__processedCLArgs.help === true) {
    Log.global.error(__clUsage);
    __noStart = true;
    // Don't execute the app if the help flag is given.
}

// Now the logging property has been set to its final value,
// log information about how command line arguments were set,
// but only if not in help mode.

// Runtime command line arguments 
if (__processedCLArgs.fast !== undefined && __processedCLArgs.fast !== null
    && !__noStart) {
    Log.global.info("'fast' property overridden by command line argument.");
}
if (__processedCLArgs.keepalive !== undefined && __processedCLArgs.keepalive !== null
    && !__noStart) {
    Log.global.info("'keepalive' property overridden by command line argument.");
}
if (__processedCLArgs.timeout !== undefined && __processedCLArgs.timeout !== null
    && !__noStart) {
    Log.global.info("'timeout' property overridden by command line argument.");
}
if (__processedCLArgs.logging !== undefined && __processedCLArgs.logging !== null
    && !__noStart) {
     Log.global.info("'logging' property overridden by command line argument.");
}

// Custom command line arguments

// Assign custom command line arguments
// =============== START reactor class influxConnector
// *********** From the preamble, verbatim:
        
import * as Influx from "influx";
import * as os from "os";

import * as fs from "fs";
import * as path from "path";

const databaseName = "LF_Events";
const measurementName = "event_times";
const traceFilePath = "../../my_trace";


        const influx = new Influx.InfluxDB({
          host: "localhost",
          database: databaseName,
          schema: [
            {
              measurement: measurementName,
              fields: {
                message_id: Influx.FieldType.INTEGER,
                sender_lts: Influx.FieldType.FLOAT,
                receiver_lts: Influx.FieldType.FLOAT,
                logical_latency: Influx.FieldType.INTEGER,
                sender_pts: Influx.FieldType.FLOAT,
                receiver_pts: Influx.FieldType.FLOAT,
                physical_latency: Influx.FieldType.INTEGER,
                residual: Influx.FieldType.INTEGER,
                phase: Influx.FieldType.INTEGER,
                deadline_miss: Influx.FieldType.BOOLEAN,
              },
              tags: []
            },
          ],
        });
    

// *********** End of preamble.
export class influxConnector extends App {
    t: Timer;
    constructor (
        timeout: TimeValue | undefined = undefined, 
        keepAlive: boolean = false, 
        fast: boolean = false, 
        success?: () => void, 
        fail?: () => void
    ) {
        super(timeout, keepAlive, fast, success, fail);
        this.t = new Timer(this, 0, new UnitBasedTimeValue(0, TimeUnit.msec));
        this.addReaction(
            new Triggers(this.startup),
            new Args(),
            function (this) {
                // =============== START react prologue
                const util = this.util;
                // =============== END react prologue
                try {
                    influx
                      .getDatabaseNames()
                      .then((names) => {
                        if (!names.includes(databaseName)) {
                          return influx.createDatabase(databaseName);
                        }
                      })
                      .then(() => {
                          console.log("Created new database if not exists");
                    
                      })
                      .catch((err) => {
                        console.error(`Error creating Influx database!`);
                      });
                        
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
        this.addReaction(
            new Triggers(this.t),
            new Args(this.t),
            function (this, __t: Read<Tag>) {
                // =============== START react prologue
                const util = this.util;
                let t = __t.get();
                // =============== END react prologue
                try {
                                    
                            
                    let fieldRecord: {[key:string] : number} = {};
                            
                            var lines;
                    try {
                                  
                                  const data = fs.readFileSync(path.resolve(__dirname, traceFilePath), 'utf8')
                                  lines = data.split(/\r?\n/);
                                  
                                          
                        lines.forEach((line) => {
                                    if(line.indexOf("EVENT") < 0){
                                        return;
                                    }
                                    var mod_line = line.replace("EVENT: ", "");
                                    var split_line = mod_line.split(": ");
                                    //console.log(split_line);
                                    var _timestamp = "";
                                    if(split_line[0] == "sender_pts")
                                        _timestamp = split_line[1];
                                    fieldRecord[split_line[0]] = parseInt(split_line[1]);
                            if(split_line[0] == 'deadline_miss'){
                                 influx
                                  .writePoints([
                                    {
                                      measurement: measurementName,
                                       tags: {},
                                       fields: fieldRecord,
                                       timestamp: _timestamp,
                                    },
                                  ])
                                  .catch((err) => {
                                    console.error(`Error saving data to InfluxDB! ${err.stack}`);
                                  });
                                    }
                                });
                       
                                  
                    } catch (err) {
                                  console.error(err)
                    }
                        
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
        this.addReaction(
            new Triggers(this.shutdown),
            new Args(),
            function (this) {
                // =============== START react prologue
                const util = this.util;
                // =============== END react prologue
                try {
                    influx
                                .query(
                                  `
                                select * from measurementName
                                where host = ${Influx.escape.stringLit(os.hostname())}
                                order by time desc
                                limit 10
                                      `
                                )
                                .then((result) => {
                                  console.log(result);
                                })
                                .catch((err) => {
                                  console.log(err.stack);
                             });
                        
                } finally {
                    // =============== START react epilogue
                    
                    // =============== END react epilogue
                }
            }
        );
    }
}
// =============== END reactor class influxConnector

// ************* Instance influxConnector of class influxConnector
let __app;
if (!__noStart) {
    __app = new influxConnector(__timeout, __keepAlive, __fast, );
}
// ************* Starting Runtime for influxConnector + of class influxConnector.
if (!__noStart && __app) {
    __app._start();
}
