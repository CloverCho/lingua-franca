target TypeScript;

/*
 * Uses another package @ https://github.com/node-influx/node-influx/tree/master/examples/express_response_times
 */

main reactor influxConnector {
   
    preamble{=
        
        import * as Influx from "influx";
        import * as os from "os";

        import * as fs from "fs";
        import * as path from "path";
        
        const databaseName = "LF_Events";
        const measurementName = "event_times";
        const traceFilePath = "../../trace280121exp6";
        
		const influx = new Influx.InfluxDB({
		  host: "localhost",
		  database: databaseName,
		  schema: [
		    {
		      measurement: measurementName,
		      fields: {
			    message_id: Influx.FieldType.INTEGER,
				sender_lts: Influx.FieldType.FLOAT,
				receiver_lts: Influx.FieldType.FLOAT,
				logical_latency: Influx.FieldType.INTEGER,
				sender_pts: Influx.FieldType.FLOAT,
				receiver_pts: Influx.FieldType.FLOAT,
				physical_latency: Influx.FieldType.INTEGER,
				residual: Influx.FieldType.INTEGER,
				true_residual: Influx.FieldType.INTEGER,
				phase: Influx.FieldType.INTEGER,
				//deadline_miss: Influx.FieldType.BOOLEAN,
		      },
		      tags: []
		    },
		  ],
		});
    =}
    
    reaction(startup){=
		influx
		  .getDatabaseNames()
		  .then((names) => {
		    if (!names.includes(databaseName)) {
		      return influx.createDatabase(databaseName);
		    }
		  })
		  .then(() => {
		      console.log("Created new database if not exists");

		  })
		  .catch((err) => {
		    console.error(`Error creating Influx database!`);
		  });
    =}
    
    timer t(0, 0 msec);
    
    reaction(t) {=
		        
		
		let fieldRecord: {[key:string] : number} = {};
		        
        var lines;
		try {
  			
  			const data = fs.readFileSync(path.resolve(__dirname, traceFilePath), 'utf8')
  			lines = data.split(/\r?\n/);

			//To keep track of read items
			var _platency = -1;
			var _llatency = -1;
			var _residual = -1;
  					
			lines.forEach((line) => {
	            if(line.indexOf("EVENT") < 0){
	        		return;
	            }
	        	var mod_line = line.replace("EVENT: ", "");
	        	var split_line = mod_line.split(": ");
	        	//console.log(split_line);
	        	var _timestamp = "";
	        	if(split_line[0] == "sender_pts")
	        		_timestamp = split_line[1];

				if(split_line[0] == "physical_latency")
	        		_platency = parseInt(split_line[1]);

				if(split_line[0] == "logical_latency")
	        		_llatency = parseInt(split_line[1]);

				if(split_line[0] == "residual"){
					//TODO: Deal with out of order writes to file
					_residual = parseInt(split_line[1]);
					if(_platency)
					   fieldRecord["true_residual"] = _residual - _platency;
					else if(_platency < 0 && _llatency > 0)
					    fieldRecord["true_residual"] = _residual - _llatency;
					else
					   	fieldRecord["true_residual"] = parseInt(split_line[1]); // same as residual
				}		

	            fieldRecord[split_line[0]] = parseInt(split_line[1]);
				if(split_line[0] == 'phase'){
			         influx
			     	 .writePoints([
			      	  {
			      	    measurement: measurementName,
			       	    tags: {},
			       	    fields: fieldRecord,
			       	    timestamp: _timestamp,
			       	 },
			     	 ])
			     	 .catch((err) => {
			      	  console.error(`Error saving data to InfluxDB! ${err.stack}`);
			      	});

					//Reset read checkers
					_platency = -1;
			        _llatency = -1;
					_residual = -1;
	            }
	    	});
		} catch (err) {
  			console.error(err)
		}
    =}
    
    reaction(shutdown){=
        influx
		    .query(
		      `
		    select * from measurementName
		    where host = ${Influx.escape.stringLit(os.hostname())}
		    order by time desc
		    limit 10
		  		`
		    )
		    .then((result) => {
		      console.log(result);
		    })
		    .catch((err) => {
		      console.log(err.stack);
		 });
    =}
}