// This example illustrates local deadline handling.
// Even numbers are sent by the Source immediately, whereas odd numbers
// are sent after a big enough delay to violate the deadline.
target Python {
    timeout: 4 sec,
    scheduler: GEDF_NP
};
reactor Source(period(2 sec)) {
    output y;
    timer t(0, period);
    state count(0);
    reaction(t) -> y {=
        if self.count % 2 != 0:
            # The count variable is odd.
            # Take time to cause a deadline violation.
            sleep_time = MSEC(500)
            start_time = get_physical_time()
            while (get_physical_time() < start_time + sleep_time):
                pass
        
        print("Source sends: ", self.count)
        y.set(self.count)
        self.count += 1
    =}
}

reactor Destination(timeout(1 sec)) {
    input x;
    state count(0);
    state expected(1);
    reaction(x) {=
        print("Destination receives: ", x.value)
        if self.count % 2 != 0:
            # The count variable is odd, so the deadline should have been violated.
            sys.stderr.write("ERROR: Failed to detect deadline.\n")
            exit(1)
        
        self.count += 1
    =} deadline(timeout) {=
        print("Destination deadline handler receives: ", x.value)
        if self.count % 2 == 0:
            # The count variable is even, so the deadline should not have been violated.
            sys.stderr.write("ERROR: Deadline miss handler invoked without deadline violation.\n")
            exit(2)
        self.count += 1
    =}

    reaction(x) {=
        print("Lower priority reaction invoked.")
        if self.count != self.expected:
            sys.stderr.write("ERROR: "
                "The reaction with the larger deadline was "
                "invoked before the reaction with the smaller deadline."
            )
            exit(3)
        self.expected+=1
    =}
}
main reactor Deadline {
    s = new Source();
    d = new Destination(timeout = 200 msec);
    s.y -> d.x;
}
