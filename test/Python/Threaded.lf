// Check for speedup of multithreaded execution on multicore machines.
// Each instance of TakeTime takes 200 ms to transport the input to the output.
// Four of them are instantiated.
// Note that without parallel execution, there is no way this can keep up with real time
// since in every 200 msec cycle it has 800 msec of work to do.
// On a quad-core machine, however, it does pretty well, completing 800 msec of work
// in about 225 msec.
// NOTE: This is the non-threaded version, showing that without threads, this takes more
// than 800 msec to complete 200 msec of logical time.
// See ThreadedMultiport for a parameterized version of this.
target Python {
    timeout: 2 sec
};
reactor Source {
	timer t(0, 200 msec);
	output out:int;
	state s:int(0);
	reaction(t) -> out {=
        out.set(self.s)
        self.s+=1
	=}
}
reactor TakeTime {
	input _in:int;
	output out:int;
	reaction(_in) -> out {=

        offset:int = 0
        for i in range(10000):
            offset+=1
        
        out.set(_in.value + offset)
	=}
}
reactor Destination(width:int(4)) {
	state s:int(40000);
	input[width] _in:int;
	reaction(_in) {=
		sm = 0
		for i in range(len(_in)):
            sm += _in[i].value

		print("Sum of received: " + str(sm))
		if sm != self.s:
			sys.stderr.write("ERROR: Expected " + str(self.s) +"\n")
			exit(1)
		self.s += len(_in)
	=}
}
main reactor ThreadedThreaded(width:int(4)) {
	a = new Source();
	t = new[width] TakeTime();
	(a.out)+ -> t._in;
    b = new Destination(width = width);
	t.out -> b._in;
}