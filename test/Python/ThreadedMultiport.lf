// Check multiport capabilities on Outputs.
target Python {
    timeout: 2 sec,
}; 
reactor Source(width(4)) {
	timer t(0, 200 msec);
	output[width] out;
	state s(0);
	reaction(t) -> out {=
        for i in range(len(out)):
            out[i].set(self.s)
        self.s += 1
	=}
}
reactor Computation(instance(0), iterations(10000)) {
	input _in;
	output out;
	reaction(_in) -> out {=
        offset = 0
        for i in range(self.iterations):
            offset += 1
        out.set(_in.value + offset)
	=}
}
reactor Destination(width(4), iterations(10000)) {
	state s(0);
	input[width] _in;
	reaction(_in) {=
        expected = self.iterations * self.width + self.s
        sm = 0
        for i in range(len(_in)):
            if _in[i].is_present:
                sm += _in[i].value
        print("Sum of received: ", sm)
        if sm != expected:
            sys.stderr.write("ERROR: Expected {:d}.\n".format(expected))
            exit(1)

        self.s += self.width
	=}
	reaction(shutdown) {=
        if self.s == 0:
            sys.stderr.write("ERROR: Destination received no input!\n")
            exit(1)

        print("Success.\n")
    =}
}

main reactor ThreadedMultiport(width(4), iterations(10000)) { 
	a = new Source(width = width);
	t = new[width] Computation(iterations = iterations);
	b = new Destination(width = width, iterations = iterations);
	a.out -> t._in;
	t.out -> b._in;
}