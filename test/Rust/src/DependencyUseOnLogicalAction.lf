/* Test that use-dependencies may be declared on logical actions and timers. */
target Rust {
    timeout: 10 msec
};

main reactor {
    logical action clock: u32;

    logical action a;

    timer t(0, 2msec);

    state tick: u32(0);

    reaction(startup) -> clock, a {=
        ctx.schedule(a, AfterMillis(3)); // out of order on purpose
        ctx.schedule(a, AfterMillis(1));
        ctx.schedule(a, AfterMillis(5));

        // not scheduled on milli 1 (action is)
        ctx.schedule_with_v(clock, Some(2), AfterMillis(2));
        ctx.schedule_with_v(clock, Some(3), AfterMillis(3));
        ctx.schedule_with_v(clock, Some(4), AfterMillis(4));
        ctx.schedule_with_v(clock, Some(5), AfterMillis(5));
        // not scheduled on milli 6 (timer is)
    =}

    reaction(clock) a, t {=
        match ctx.get(clock) {
            Some(2) | Some(4) => {
                assert!(ctx.is_present(t));   // t is there on even millis
                assert!(!ctx.is_present(a)); //
            },
            Some(3) | Some(5) => {
                assert!(!ctx.is_present(t));
                assert!(ctx.is_present(a));
            },
            it => unreachable!("{:?}", it)
        }
        self.tick += 1;
    =}

    reaction(shutdown) {=
        assert_eq!(self.tick, 4);
        println!("success");
    =}
}
